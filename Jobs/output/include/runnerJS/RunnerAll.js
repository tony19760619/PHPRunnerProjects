Runner.namespace('Runner.util');

(function() {
	/**
	 * Create a delayed for given number of milliseconds (delay) event handler	
	 * @param {function} hn
	 * @param {number} delay
	 * @param {object} scope
	 * @return {function}
	 */	
	var createDelayed = function( hn, delay, scope ) {
		return function() {
			var args = arguments;
			setTimeout( function() {
				hn.apply(scope, args);
			}, delay );
		};
	};
	
	/**
	 * Create an event handler that will be executed at most once
	 * @param {function} hn
	 * @param {object} e
	 * @param {function} fn
	 * @param {object} scope
	 * @return {function}	 
	 */		
	var createSingle = function( hn, e, fn, scope ) {
		return function() {
			e.removeListener(fn, scope);
			return hn.apply(scope, arguments);
		};
	};
	
	/**
	 * Create an event handler that won't be triggered, 
	 * as long as it continues to be invoked 
	 * during a given number of milliseconds (buffer). 	
	 * @param {function} hn
	 * @param {number} buffer
	 * @param {object} scope
	 * @return {function}	 
	 */
	var createBuffered = function( hn, buffer, scope ) {
		var task = new Runner.util.DelayedTask();
		return function() {
			task.delay( buffer, hn, scope, Array.prototype.slice.call( arguments ) );
		};
	};
	
	/**
	 * Runner.util.Event constructor
	 * @param {object} obj
	 * @param {string} name
	 */ 
	Runner.util.Event = function( obj, name ) {
		this.name = name;
		this.obj = obj;
		this.listeners = [];
	};
	
	
	Runner.util.Event.prototype = {
		/**
		 * Create a custom event listener object
		 * @param {function} fn
		 * @param {object} scope
		 * @param {objct} options
		 * @return {object}
		 */		
		createListener: function( fn, scope, options ) {
			var hn = fn;
			
			scope = scope || this.obj;
			options = options || {};

			if ( options.delay ) {
				hn = createDelayed(hn, options.delay, scope);
			}
			if ( options.single ) {
				hn = createSingle(hn, this, fn, scope);
			}
			if ( options.buffer ) {
				hn = createBuffered(hn, options.buffer, scope);
			}
			
			return {
				fn: fn, 
				fireFn: hn,
				scope: scope,
				options: options
			};
		},
		
		fire: function() {
			var i, ls;
				
			if ( this.listeners.length > 0 ) {
				this.firing = true;
				for (i = 0; i < this.listeners.length; i++) {
					ls = this.listeners[i];
					
					if ( ls.fireFn.apply(ls.scope || this.obj || window, arguments) === false ) {
						this.firing = false;
						return false;
					}
				}
				this.firing = false;
			}
			return true;
		},
		
		on: function( fn, scope, options ) {
			scope = scope || this.obj;
			if ( !this.isListening(fn, scope) ) {
				var ls = this.createListener(fn, scope, options);

				/*if (this.firing) {
					this.listeners = this.listeners.slice(0);
				}*/
				this.listeners.push(ls);
			}
		},
		
		isListening: function( fn, scope ) {
			return this.getListenerIndex(fn, scope) != -1;
		},
		
		getListenerIndex: function( fn, scope ) {
			var length = this.listeners.length,
				i, ls;
				
			scope = scope || this.obj;	
				
			for (i = 0; i < length; i++) {
				ls = this.listeners[i];
				if ( ls.fn == fn && ls.scope == scope ) {
					return i;
				}
			}
			return -1;
		},		
		
		/**
		 * Remove a listener
		 * @param {function} fn
		 * @param {object} scope
		 */
		removeListener: function( fn, scope ) {
			var index = this.getListenerIndex(fn, scope);
			if ( index === -1 ) {
				return;
			}
			
			if (this.firing) {
				this.listeners = this.listeners.slice(0);
			}
			this.listeners.splice(index, 1);
		}
	};
})();


/**
 * @class Runner.util.Observable
 * Observer-subscriber class
 * Provides base functionality for PHPRunner's custom events handling
 */
Runner.util.Observable = Runner.extend( Runner.emptyFn, {	
	/**
	 * The cutom event objects storage
	 * @type {Object}
	 */
	events: null,
	
	/**
	 * The regexp checking if the string is otions string
	 * @type {RegExp}
	 */
	filterOptRe: /^(?:scope|delay|buffer|single)$/,
	
	/**
	 * Add the events with names that are listed in arguments
	 */
	addEvents: function() {
		var eventsNames = Array.prototype.slice.call( arguments ),
			evName, i;
		
		this.events = this.events || {};
		
		for (i = 0; i < eventsNames.length; i++) {
			evName = eventsNames[i].toLowerCase();
			this.events[ evName ] = this.events[ evName ] || true;
		}	
	},
	
	/**
	 * Fire a custom event
	 * The first argument must be an event name,
	 * the other will be passed as the event's arguments 
	 * @return {boolean}
	 */
	fireEvent: function() {
		var evName = arguments[0],
			ce;
		
		if ( this.isEventExist( evName ) ) {
			ce = this.events[ evName.toLowerCase() ];
			return ce.fire.apply( ce, Array.prototype.slice.call(arguments, 1) );
		}
		return true;
	},
	
	/**
	 * Check if a custom event with a particualr name exists
	 * @param {string} evName
	 * @return {boolean}
	 */
	isEventExist: function( evName ) {
		if ( this.eventsSuspended === true ) {
			return false;	
		}
		
		var ce = this.events[ evName.toLowerCase() ];
		return ce instanceof Runner.util.Event;
	},

	/**
	 * Subscribe a custom event's handler
	 * @param {string | object} evName
	 * @param {function} fn
	 * @param {object} scope
	 * @param {object} options
	 */ 	
	on: function( evName, fn, scope, options ) {
		var event, ce;
		
		if ( typeof evName === "object" ) {
			options = evName;
			
			for (event in options) {
				if ( this.filterOptRe.test( event ) ) {
					continue;
				}
				
				if ( typeof options[ event ] === "function" ) {
					this.on( event, options[ event ], options.scope, options );
				} else {
					this.on( event, options[ event ].fn, options[ event ].scope, options[ event ] );
				}
			}
			
			return;
		}
		
		options = options || {};
		evName = evName.toLowerCase();
		
		ce = this.events[ evName ];

		if ( !(ce instanceof Runner.util.Event) ) {
			ce = new Runner.util.Event(this, evName);
			this.events[ evName ] = ce;
		}
		
		ce.on( fn, scope, options );
	},
	
	/**
	 * Unsubscribe a custom event's handler
	 * @param {string} evName
	 * @param {function} fn
	 * @param {object} scope
	 */ 
	un: function( evName, fn, scope ) {
		var ce = this.events[ evName.toLowerCase() ];
				
		if ( ce instanceof Runner.util.Event ) {
			ce.removeListener(fn, scope);
		}
	},
	
	/**
	 * Purge (clear) array of listeners for events
	 */
	purgeListeners: function() {
		for ( var event in this.events ) {
			if ( this.events[ event ] instanceof Runner.util.Event ) {
				this.events[ event ].listeners = [];
			}
		}
	},
	
	/**
	 * Make events suspended (delayed) for fire
	 */
	suspendEvents: function() {
		this.eventsSuspended = true;
	},
	
	/**
	 * Make events available for fire
	 */
	resumeEvents: function() {
		this.eventsSuspended = false;
	}
});

// register new namespace
Runner.namespace('Runner.util');


Runner.util.getHiddenDimensions = function( $elem ) {
	var position, cloned = false;
	
	if( $elem.is(":hidden") ) {
		$elem = $elem.clone()
			.css({ 
				display: "inline-block",
				position: "absolute",
				visibility: "hidden"
			})
			.appendTo( $elem.closest(":visible") );
		cloned = true;
	}

	position = { outerWidth: $elem.outerWidth( ),
		outerHeight: $elem.outerHeight( ),
		width: $elem.width(),
		height: $elem.height()
	};
	if( cloned )
		$elem.remove();
	return position;
};


/**
 * @class Runner.util.DelayedTask
 * method for performing setTimeout where a new timeout cancels the old timeout. 
 * @param {Function} fn (optional) The default function to timeout
 * @param {Object} scope (optional) The default scope of that timeout
 * @param {Array} args (optional) The default Array of arguments
 */
Runner.util.DelayedTask = function(fn, scope, args) {
	var id = null, 
		delay, time;
	
	var call = function() {
		var now = new Date().getTime();
		if (now - time >= delay) {
			clearInterval(id);
			id = null;
			fn.apply(scope, args || []);
		}
	};
	
	/**
	 * Cancels any pending timeout and queues a new one
	 * @param {Number} delay The milliseconds to delay
	 * @param {Function} newFn (optional) Overrides function passed to constructor
	 * @param {Object} newScope (optional) Overrides scope passed to constructor
	 * @param {Array} newArgs (optional) Overrides args passed to constructor
	 */
	this.delay = function(newDelay, newFn, newScope, newArgs) {
		if (id && delay != newDelay) {
			this.cancel();
		}
		delay = newDelay;
		time = new Date().getTime();
		fn = newFn || fn;
		scope = newScope || scope;
		args = newArgs || args;
		if (!id) {
			id = setInterval(call, delay);
		}
	};
	
	/**
	 * Cancel the last queued timeout
	 */
	this.cancel = function() {
		if (id) {
			clearInterval(id);
			id = null;
		}
	};
};

/**
 * Global object for loading scripts and css files
 * @object
 */
Runner.util.ScriptLoader = Runner.extend( Runner.util.Observable, {
	/**
	 * Array of CSS files for loading
	 * @type {array}
	 */
	cssFiles: [],
	
	/**
	 * Array of file names for load
	 * @type {array}
	 */
	jsFiles: [],

	/**
	 * The number of JS files loading session 	
	 * @type {number}
	 */
	session: 0,	
	
	/**
	 * An array storing the closed sessions of JS files loading.
	 * Each session is started with the 'load' method and is closed 
	 * when all the session's JS files are loaded
	 * @type {array}	
	 */
	loadedSes:[],	
	
	constructor: function( cfg ) {
		Runner.util.ScriptLoader.superclass.constructor.call(this, cfg);
		
		this.addEvents();
		
		this.onFilesLoaded( function() {
			if ( Runner.pages ) {
				Runner.pages.PageManager.initPages();
			}
		}, this );
	},
	
	/**
	 * Add js file to load queue
	 * @param {array} files
	 * @param any param except first is added to requirements array
	 */
	addJS: function( files ) {
		var isAdded, i, j;
		// loop through all files to add
		for (i = 0; i < files.length; i++) {
			isAdded = false;
			
			// check if such file was added before
			for (j = 0; j < this.jsFiles.length; j++) {
				if ( this.jsFiles[j].name == files[i] ) {
					isAdded = true;
					break;
				}
			}
			// add only new files
			if ( !isAdded ) {
				// add files to array of file names
				this.jsFiles.push({
					name: files[i],
					isLoaded: false,
					// add requirements, all passed arguments, except first
					requirements: Array.prototype.slice.call(arguments, 1),
					session: parseInt( this.session )
				});
			}
		}
	},
	
	/**
	 * Method produces a link to IE8-compatible stylesheet if needed 
	 * @param {string} url
	 * @return {string} url
	 */
	cssProxy: (function() {
		if ( Runner.isIE8 ) {
			return function(url) {
				return Runner.getPageUrl('ie8css', '', url);
			}
		}
		return function(url) {
			return url;
		}
	})(),
	
	/**
	 * Check if the css file with a particular name is loaded
	 * @param {string} fileName
	 * @return {boolean}
	 */
	isCSSfileLoaded: function( fileName ) {	
		for (var i = 0; i < this.cssFiles.length; i++) {
			if ( this.cssFiles[i].name == fileName && this.cssFiles[i].isLoaded ) {
				return true;
			}
		}
		return false;
	},	
	
	/**
	 * Method for load CSS files
	 * @param files {array}
	 */
	loadCSS: function( files ) {
		var _self = this;
		
		if ( !files ) {
			return;
		}
		
		files = typeof files === "string" ? [ files ] : files;

		jQuery.each( files, function(i, file) {
			if ( !file ) {
				return;
			}
			file = _self.cssProxy( file );

			// return if file is already added and loaded
			if ( _self.isCSSfileLoaded( file ) ) {
				return;
			}

			_self.cssFiles.push({
				name: file,
				isLoaded: true
			})
			
			var existInHead = false,
				head, css, filePath;
			
			$('head link[rel="stylesheet"]').each( function(index, element) {
				if ( $(element).attr('href') == file ) {
					existInHead = true;
					return false;
				}
			});
			
			// load file
			if ( !existInHead ) {
				head = $(document).find('head')[0];
				
						filePath = files[i];
		
				css = document.createElement('link');
				css.setAttribute('rel', 'stylesheet');
				css.setAttribute('type', 'text/css');
				css.setAttribute('href', filePath);
				head.appendChild(css);
			}
		});
	},
	
	load: function() {
		if ( this.jsFiles.length == 0 ) {
			this.fireEvent( 'filesLoaded' + this.session );
		}
		
		this.session = this.session + 1;
		
		for (var i = 0; i < this.jsFiles.length; i++) {
			this.loadJS( i );
		}
	},
	
	/**
	 * Load a file from the files queue
	 * @param {number} idx file index
	 * @return {boolean} true if success
	 * @method
	 * @private
	 */
	loadJS: function( idx ) {
		// return if no file obj for this file
		if ( !this.jsFiles[idx] ) {
			return false;
		}
		// if loaded, load dependent files
		if ( this.jsFiles[idx].isLoaded ) {
			this.jsFiles[idx].session = this.session - 1;
			this.postLoad( idx );
			return true;
		}
		// check requirements
		if ( !this.checkReq( this.jsFiles[idx] ) ) {
			return false;
		}
		// file loading started already
		if ( this.jsFiles[idx].isStarted ) {
			return false;
		}
		// load file
		this.jsFiles[idx].isStarted = true;		
				
		var self = this,
			js = document.createElement('script'),
			runnerWebRootPath = decodeURIComponent( window.runnerWebRootPath ),	
			// a definition of such a function is the way to invoke Runner custom code when the external js file is loaded
			initFuncName = this.jsFiles[idx].name.replace('.js', '').replace(/[\/\\.\-]/g, "_").replace(/^_+/,'') + '_init',
			postLoadFunction = function() {
				var tl = true;
				
				if ( typeof Runner[ initFuncName ] === "function" ) {
					tl = Runner[ initFuncName ].call(self, idx);
				}
				
				if ( tl !== false ) {
					self.postLoad( idx );
				}
			};

		if ( runnerWebRootPath !== "" && initFuncName.indexOf( runnerWebRootPath ) == 0 ) {
			initFuncName = initFuncName.substring(runnerWebRootPath.length);
		}

		js.setAttribute('type', 'text/javascript');
		
		if ( Runner.isIE ) {
			js.onreadystatechange = function() {
				if ( js.readyState == 'complete' || js.readyState == 'loaded' ) {
					postLoadFunction();
				}
			};
		} else {
			js.onload = postLoadFunction;
		}
		
		js.setAttribute( 'src', this.jsFiles[idx].name );
		document.getElementsByTagName('HEAD')[0].appendChild( js );
		return true;
	},
	
	/**
	 * Checks is required files are loaded
	 * @param {object} fileObj
	 * @return {Boolean}
	 */
	checkReq: function( fileObj ) {
		// loop through all files
		for (var i = 0; i < fileObj.requirements.length; i++) {
			// loop through all req
			for (var j = 0; j < this.jsFiles.length; j++) {
				// if req cotains loaded file, than try to load it
				if ( fileObj.requirements[i] == this.jsFiles[j].name && !this.jsFiles[j].isLoaded ) { 
					return false;
				}
			}
		}
		return true;
	},
	
	/**
	 * After event handler. Called after file loaded.
	 * @param {number} idx
	 * @param {session} session
	 * @method
	 */
	postLoad: function( idx, session ) {
		var loadedAll = true;
		if (idx !== undefined) {
			this.jsFiles[idx].isLoaded = true;
			this.loadDependent(idx);
			var session = this.jsFiles[idx].session;
		}
		for (var i = 0; i < this.jsFiles.length; i++) {
			if ( !this.jsFiles[i].isLoaded ) {
				loadedAll = false;
				break;
			}
		}
		if ( loadedAll ) {
			if ( $.inArray(session, this.loadedSes) == -1 ) {
				this.fireEvent( 'filesLoaded' + session );
				this.loadedSes.push( session );
			}
			if ( idx !== undefined ) {
				for (var i = 0; i < this.session; i++ ) {
					this.postLoad( undefined, i );
				}
			}
		}
	},

	/**
	 * Add the loading session's 'filesLoaded' event and its handler
	 * @param {function} callback
	 * @param {object} scope
	 */	 
	onFilesLoaded: function( callback, scope ) {
		this.on('filesLoaded' + this.session, callback, scope, { single: true });
	},
	
	/**
	 * Call load for files, which are dependent to file with index = idx
	 * @param {number} idx
	 */
	loadDependent: function( idx ) {
		// loop through all files
		for (var i = 0; i < this.jsFiles.length; i++) {
			// loop through all req
			for (var j = 0; j < this.jsFiles[i].requirements.length; j++) {
				// if req cotains loaded file, than try to load it
				if ( i != idx && this.jsFiles[i].requirements[j] == this.jsFiles[idx].name ) { 
					this.loadJS(i);
				}
			}
		}
	}	
});

Runner.util.ScriptLoader = new Runner.util.ScriptLoader();


/**
 * Update a chart
 * @param {string} chartname
 * @param {boolean} showDetails
 * @param {boolean} dashChart
 */
Runner.updateChart = function( chartname, showDetails, dashChart ) {
	var page = Runner.getPageUrl("dchartdata") + '?chartname=' + chartname + '&showDetails=' + showDetails.toString(),
		params = {
			action: 'refresh',
			rndval: Math.random()
		};
		
	if ( dashChart ) {
		page += '&dashChart=' + dashChart.toString();
	}	
		
	$.get( page, params, function( xml ) {
		var arr = xml.split("\n");
		
		for (var i = 0; i < arr.length; i += 2) {
			chart.removeSeries( arr[i] );
			chart.addSeries( arr[i + 1] );
		}
		chart.refresh();
	});
};

/**
 * Update details for dashboard chart
 * @param {object} masterKeys
 * @param {number} pageId
 */
Runner.updateDetailsForDashboardChart = function( masterKeys, pageId ) {
	var pageObj = Runner.pages.PageManager.getById( pageId );
	if ( pageObj ) {
		pageObj.dependentElementsVisible = !!masterKeys;
		pageObj.loadDependencies( masterKeys ? $.parseJSON( masterKeys ) : {} );
		pageObj.dashboard.toggleDependentElements( pageObj.getDependentElements(), true );
	}
};

/**
 * Update a Gauge chart
 * @param {string} chartname
 */
Runner.updateGaugeChart = function( chartname ) {
	var page = Runner.getPageUrl('dchartdata')+'?chartname=' + chartname,
		params = {
			action: 'refresh',
			rndval: Math.random()
		};
	$.get( page, params, function( xml ) {
		var arr = xml.split("\n");
		
		for (var i = 0; i < arr.length; i += 2) {
			chart.updatePointData( arr[i] + "_gauge", arr[i] + "_point", { value: arr[i + 1] });
		}
		chart.refresh();
	});
};

/**
 * Runner.Async constructor
 * 	Usage: 
	Runner.Async.loop( collection, handler );
	
	Runner.Async.loop( handler ) 
	is equal to 
	Runner.Async.loop( [null], handler )
	
 *	Sample code:
	------------------------
		Runner.Async.loop( [1,2,3], function(i, n) {
			console.log(n);
			Runner.Async.loop( ['a','b','c'], function(i, n) {
				console.log(n);
			});
			Runner.Async.loop( ['x','y','z'], function(i, n) {
				console.log(n);
			});
		})	
	------------------------
	Output:
	------------------------
	1
	a
	b
	c
	x
	y
	z
	2
	a
	b
	c
	x
	y
	z
	3
	a
	b
	c
	x
	y
	z
	------------------------	
 */
Runner.Async = function() {
	/**
	 * The asynchronous loops data storage
	 * @type {array}
	 */
	this.stack = [];
	
	/**
	 * Register a new asynchronous loop block,
	 * start the loop handler async execution 
	 * @param {array | function} _collection
	 * @param {function} _handler
	 */
	this.loop = function( _collection, _handler ) {
		var stackHead;
		
		//	only one parameter passed
		if ( typeof _handler === "undefined" ) {
			_handler = _collection;
			_collection = [ null ];
		}
		
//		if ( !_collection.length ) {
//			return;
//		}
		
		if ( !this.stack.length ) {
			this.stack.push({ 
				buffer: [] 
			});
		}
		
		stackHead = this.stack[ this.stack.length - 1 ];
		stackHead.buffer.push({ 
			collection: _collection,
			index: 0,
			handler: _handler
		});
		
		setTimeout( this.processFunc, 0 );
	}

	/**
	 * Choose the loop handler to execute along with
	 * its context and params.
	 * Set the priotity to new loops added during 
	 * the loop handler execution
	 */
	this.processFunc = $.proxy( function() {
		var stackHead, element, bufLength, handlerResult,
			stackLength = this.stack.length;
		
		if ( !stackLength ) {
			return;
		}
		
		stackHead = this.stack[ stackLength - 1 ];
		// an element containig handler data
		element = stackHead.buffer[0];		
		
		if ( element.index < element.collection.length ) {

			bufLength = stackHead.buffer.length;
			handlerResult = element.handler.call( null, element.index, element.collection[ element.index ] );
		
			if ( stackHead.buffer.length > bufLength ) {
				//	new tasks were added during the step execution
				//	move them to the stack head
				this.stack.push({
					buffer: stackHead.buffer.splice( bufLength, stackHead.buffer.length - bufLength )
				});
			}
		}
		
		element.index++;
		if ( element.index >= element.collection.length && this.stack.length == stackLength || handlerResult === false ) {
			// there is no elements left in the loop collection
			stackHead.buffer.splice(0, 1);
			
			if ( !stackHead.buffer.length ) {
				this.stack.splice( stackLength - 1, 1 );
			}			
		}
		
		setTimeout( this.processFunc, 0 );
	}, this );
}

/**
 * Runner asynchronous loops controller
 */
Runner.Async = new Runner.Async();

/**
 * Generate Runner.md5
 * Source http://www.myersdaily.org/joseph/javascript/md5.js
 * @param {mixed}
 * @return {string}
 */
Runner.md5 = ( function() {
	function md5cycle(x, k) {
		var a = x[0], b = x[1], c = x[2], d = x[3];

		a = ff(a, b, c, d, k[0], 7, -680876936);
		d = ff(d, a, b, c, k[1], 12, -389564586);
		c = ff(c, d, a, b, k[2], 17,  606105819);
		b = ff(b, c, d, a, k[3], 22, -1044525330);
		a = ff(a, b, c, d, k[4], 7, -176418897);
		d = ff(d, a, b, c, k[5], 12,  1200080426);
		c = ff(c, d, a, b, k[6], 17, -1473231341);
		b = ff(b, c, d, a, k[7], 22, -45705983);
		a = ff(a, b, c, d, k[8], 7,  1770035416);
		d = ff(d, a, b, c, k[9], 12, -1958414417);
		c = ff(c, d, a, b, k[10], 17, -42063);
		b = ff(b, c, d, a, k[11], 22, -1990404162);
		a = ff(a, b, c, d, k[12], 7,  1804603682);
		d = ff(d, a, b, c, k[13], 12, -40341101);
		c = ff(c, d, a, b, k[14], 17, -1502002290);
		b = ff(b, c, d, a, k[15], 22,  1236535329);

		a = gg(a, b, c, d, k[1], 5, -165796510);
		d = gg(d, a, b, c, k[6], 9, -1069501632);
		c = gg(c, d, a, b, k[11], 14,  643717713);
		b = gg(b, c, d, a, k[0], 20, -373897302);
		a = gg(a, b, c, d, k[5], 5, -701558691);
		d = gg(d, a, b, c, k[10], 9,  38016083);
		c = gg(c, d, a, b, k[15], 14, -660478335);
		b = gg(b, c, d, a, k[4], 20, -405537848);
		a = gg(a, b, c, d, k[9], 5,  568446438);
		d = gg(d, a, b, c, k[14], 9, -1019803690);
		c = gg(c, d, a, b, k[3], 14, -187363961);
		b = gg(b, c, d, a, k[8], 20,  1163531501);
		a = gg(a, b, c, d, k[13], 5, -1444681467);
		d = gg(d, a, b, c, k[2], 9, -51403784);
		c = gg(c, d, a, b, k[7], 14,  1735328473);
		b = gg(b, c, d, a, k[12], 20, -1926607734);

		a = hh(a, b, c, d, k[5], 4, -378558);
		d = hh(d, a, b, c, k[8], 11, -2022574463);
		c = hh(c, d, a, b, k[11], 16,  1839030562);
		b = hh(b, c, d, a, k[14], 23, -35309556);
		a = hh(a, b, c, d, k[1], 4, -1530992060);
		d = hh(d, a, b, c, k[4], 11,  1272893353);
		c = hh(c, d, a, b, k[7], 16, -155497632);
		b = hh(b, c, d, a, k[10], 23, -1094730640);
		a = hh(a, b, c, d, k[13], 4,  681279174);
		d = hh(d, a, b, c, k[0], 11, -358537222);
		c = hh(c, d, a, b, k[3], 16, -722521979);
		b = hh(b, c, d, a, k[6], 23,  76029189);
		a = hh(a, b, c, d, k[9], 4, -640364487);
		d = hh(d, a, b, c, k[12], 11, -421815835);
		c = hh(c, d, a, b, k[15], 16,  530742520);
		b = hh(b, c, d, a, k[2], 23, -995338651);

		a = ii(a, b, c, d, k[0], 6, -198630844);
		d = ii(d, a, b, c, k[7], 10,  1126891415);
		c = ii(c, d, a, b, k[14], 15, -1416354905);
		b = ii(b, c, d, a, k[5], 21, -57434055);
		a = ii(a, b, c, d, k[12], 6,  1700485571);
		d = ii(d, a, b, c, k[3], 10, -1894986606);
		c = ii(c, d, a, b, k[10], 15, -1051523);
		b = ii(b, c, d, a, k[1], 21, -2054922799);
		a = ii(a, b, c, d, k[8], 6,  1873313359);
		d = ii(d, a, b, c, k[15], 10, -30611744);
		c = ii(c, d, a, b, k[6], 15, -1560198380);
		b = ii(b, c, d, a, k[13], 21,  1309151649);
		a = ii(a, b, c, d, k[4], 6, -145523070);
		d = ii(d, a, b, c, k[11], 10, -1120210379);
		c = ii(c, d, a, b, k[2], 15,  718787259);
		b = ii(b, c, d, a, k[9], 21, -343485551);

		x[0] = add32(a, x[0]);
		x[1] = add32(b, x[1]);
		x[2] = add32(c, x[2]);
		x[3] = add32(d, x[3]);
	}

	function cmn(q, a, b, x, s, t) {
		a = add32(add32(a, q), add32(x, t));
		return add32((a << s) | (a >>> (32 - s)), b);
	}

	function ff(a, b, c, d, x, s, t) {
		return cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}

	function gg(a, b, c, d, x, s, t) {
		return cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}

	function hh(a, b, c, d, x, s, t) {
		return cmn(b ^ c ^ d, a, b, x, s, t);
	}

	function ii(a, b, c, d, x, s, t) {
		return cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	function md51(s) {
		var n = s.length,	
			tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
			state = [1732584193, -271733879, -1732584194, 271733878], 
			i;
		
		for (i = 64; i <= s.length; i += 64) {
			md5cycle( state, md5blk( s.substring(i - 64, i) ) );
		}
		s = s.substring(i - 64);
		
		for (i = 0; i < s.length; i++) {
			tail[ i>>2 ] |= s.charCodeAt(i) << ((i%4) << 3);
		}
		tail[ i>>2 ] |= 0x80 << ((i%4) << 3);
		
		if (i > 55) {
			md5cycle(state, tail);
			for (i = 0; i < 16; i++) {
				tail[i] = 0;
			}
		}
		
		tail[14] = n * 8;
		md5cycle(state, tail);
		
		return state;
	}

	/* there needs to be support for Unicode here,
	 * unless we pretend that we can redefine the MD-5
	 * algorithm for multi-byte characters (perhaps
	 * by adding every four 16-bit characters and
	 * shortening the sum to 32 bits). Otherwise
	 * I suggest performing MD-5 as if every character
	 * was two bytes--e.g., 0040 0025 = @%--but then
	 * how will an ordinary MD-5 sum be matched?
	 * There is no way to standardize text to something
	 * like UTF-8 before transformation; speed cost is
	 * utterly prohibitive. The JavaScript standard
	 * itself needs to look at this: it should start
	 * providing access to strings as preformed UTF-8
	 * 8-bit unsigned value arrays.
	 */
	function md5blk(s) { /* I figured global was faster.   */
		var md5blks = [], i; /* Andy King said do it this way. */
		for (i = 0; i < 64; i += 4) {
			md5blks[ i>>2 ] = s.charCodeAt(i)
			+ (s.charCodeAt(i + 1) << 8)
			+ (s.charCodeAt(i + 2) << 16)
			+ (s.charCodeAt(i + 3) << 24);
		}
		return md5blks;
	}

	var hex_chr = '0123456789abcdef'.split('');

	function rhex(n) {
		for ( var s = '', j = 0; j < 4; j++ ) {
			s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
		}
		return s;
	}

	function hex(x) {
		for (var i = 0; i < x.length; i++) {
			x[i] = rhex( x[i] );
		}
		return x.join('');
	}

	function md5(s) {
		return hex( md51(s) );
	}

	/* this function is much faster,
	so if possible we use it. Some IEs
	are the only ones I know of that
	need the idiotic second function,
	generated by an if clause.  */

	function add32(a, b) {
		return (a + b) & 0xFFFFFFFF;
	}

	if ( md5('hello') != '5d41402abc4b2a76b9719d911017c592' ) {
		function add32(x, y) {
			var lsw = (x & 0xFFFF) + (y & 0xFFFF),
				msw = (x >> 16) + (y >> 16) + (lsw >> 16);
			return (msw << 16) | (lsw & 0xFFFF);
		}
	}
	
	return md5;
} () ); 
// create namespace
Runner.namespace('Runner.bricks');

/**
 * General class for manage bricks and containers
 * @class Runner.bricks.BrickManager
 */
Runner.bricks.BrickManager = Runner.extend( Runner.emptyFn, {
	/**
	 * jQuery element
	 * Block, container or element wich contain brick
	 * @type {object}
	 */
	elem: null,
	/**
	 * Indicates whether brick is from old layout
	 * @type {boolean}
	 */
	oldLayout: false,
	/**
	 * Name of container, brick or block
	 * Without contain 'runner-c-', 'runner-b-' or 'runner-'
	 * @type {string}
	 */
	name: '',
	/**
	 * Page container
	 * Dom element
	 * @type {string}
	 */
	pageCont: null,
	/**
	 * First part of all Runner-related classes
	 * @type {string}
	 */
	baseName: '',
	/**
	 * First part of base class
	 * Without contain name
	 * @type {string}
	 */
	baseClass: '',
	/**
	 * Class Name for hide container, brick or block
	 * @type {string}
	 */
	hiddenClass: '',
		
		
	constructor: function(cfg) {
		Runner.apply(this, cfg);
		this.baseName = this.oldLayout ? "runner-" : "rnr-";
	},
	
	/**
	 * Get element name of brick, container or block 
	 * without base part of class name
	 * @param object element table for container
	 */
	getElemName: function(elem) {
		if (this.name) {
			return;
		}
		if (typeof elem == 'undefined') {
			elem = this.elem;
		}
		// always elem must has attribute "class"
		// this "if" only for against a risk
		if ( !elem.attr('class') ) {
			return;
		}
		
		var cls = elem.attr('class').split(' '),
			i, pos;
		for (i = 0; i < cls.length; i++) {
			if (cls[i]) {
				pos = cls[i].indexOf(this.baseClass);
				if (pos > -1) {
					this.name = cls[i].substr(pos + this.baseClass.length).trim();
					break;
				}
			}	
		}
	},
	
	/**
	 * Hide element 
	 * Add hidden class
	 */
	hide: function() {
		if ( !this.elem.hasClass( this.hiddenClass ) ) {
			this.elem.addClass( this.hiddenClass );
		}
	},
	
	/**
	 * Show element 
	 * Remove hidden class
	 */
	show: function() {
		if ( this.elem.hasClass( this.hiddenClass ) ) {
			this.elem.removeClass( this.hiddenClass );
		}
	},
	
	/**
	 * Show/hide element basing on the toggler value
	 * @param {boolean} toggler
	 */
	toggle: function( toggler ) {
		toggler ? this.show() : this.hide();
	},	
	
	/**
	 * Check on visible element
	 * @return {boolean}
	 */
	visible: function() {
		//if class of this.elem not contain 'runner-b-wrapper' that
		return !this.elem.hasClass( this.hiddenClass );
	}
});

/**
 * @class Runner.bricks.Brick
 */
Runner.bricks.Brick = Runner.extend( Runner.bricks.BrickManager, {
	
	contObj: false,
	
	contentElem: false,

	name: "",
	
	constructor: function(cfg) {
		Runner.bricks.Brick.superclass.constructor.call(this, cfg);
		
		this.baseClass = this.baseName + 'b-';
		this.hiddenClass = this.baseName + 'hiddenbrick';
		this.getElemName();
		this.getContainer();
		this.getContentElem();
		if ( this.elem.hasClass(this.baseClass + "wrapper") ) {
			this.hiddenClass = this.baseName + "hiddencontainer";
		}
	},
	
	/**
	 * Get all or a specific brick from a container 
	 * @param {String} name
	 * @param {DOM elem} pageCont
	 * @param {Boolean} all
	 * @method
	 */
	getBrickObjs: function(name, pageCont, all) {
		var crit = all ? '[class*=runner-b-], [class*=rnr-b-]' : '.runner-b-' + name + ',.rnr-b-' + name,
			brickObjs = [],
			self = this;
		
		$(crit, pageCont).each( function() {
			var $elem = $(this),
				$realPageContainer = $elem.parents().filter( function() {
					return self.hasPageClass( this );
				}),
				pageClass;
			
			if ( !$realPageContainer.is( pageCont ) ) {
				pageClass = self.getPageClass( $realPageContainer );
				
				if ( !$realPageContainer.is( $(pageCont).find("." + pageClass) ) ) {
					return false;
				}
			}
			
			brickObjs.push( new Runner.bricks.Brick({
				name: name,
				elem: $elem,
				pageCont: pageCont,
				oldLayout: $elem.attr("class").indexOf('runner-b-') >= 0
			}));
		});
		
		return brickObjs;
	},

	/**
	 * Check if the element has a class starting from "page-"
	 * @param {DOM element | jQuery object}
	 */
	hasPageClass: function( container ) {
		var $container = container instanceof jQuery ? container : $(container),
			classes = $container.attr("class"),
			classRegExp = /^\s*page-|\s*page-/;

		return classRegExp.test( classes ) ; 		
	},

	/**
	 * Get the element's class starting from "page-"
	 * @param {DOM element | jQuery object}
	 * @return {String}
	 */
	getPageClass: function( container ) {
		var $container = container instanceof jQuery ? container : $(container),
			classes = $container.attr("class"),
			classRegExp = /^\s*page-[^\s]+|\s*page-[^\s]+/;

		return classRegExp.exec( classes )[0].trim();	
	},
	
	/**
	 * Get content HTML element 
	 * If there isn't element with class runner-brickcontents in this brick
	 * Then content element it is this brick element
	 * @method
	 */
	getContentElem: function() {
		var brickContents = $('.' + this.baseName + 'brickcontents', this.elem);
		
		this.contentElem = brickContents.length ? brickContents : this.elem;
	},
	
	/**
	 * Assign the container HTML element 
	 * to the brik's 'contObj' prop 
	 * @method
	 */
	getContainer: function() {
		var contElem, 
			_self = this;
		
		// try finding the closest container: a div element with a class 'runner-s-...' 
		// not containing the class "not-container". 
		this.elem.parents('div:not(".not-container")').each(function() {	
			var classes = [], i,
				$elem = $(this);
				
			if ( $elem.attr('class') !== undefined ) {
			   classes = $elem.attr('class').split(' ');
			}

			for (i = 0; i < classes.length; i++) {
				if ( classes[i].indexOf( _self.baseName + "s-" ) === 0 ) {
					contElem = $elem;
					return false;
				}
			}		
		});
		
		if (contElem && contElem.length) {
			this.contObj = new Runner.bricks.Container({
				elem: contElem,
				pageCont: this.pageCont,
				oldLayout: this.oldLayout
			});
		}
	},
	
	/**
	 * Hide brick
	 * If this brick the single in the container
	 * Then the container must be hidden too!
	 */
	hide: function() {
		Runner.bricks.Brick.superclass.hide.call(this);
		if ( this.contObj ) {
			this.contObj.updateVisibility();
		}
	},
	
	/**
	 * Show brick
	 * If this brick position in the hidden container
	 * Than the container must be shown too!
	 */
	show: function() {
		Runner.bricks.Brick.superclass.show.call(this);
		if ( this.contObj ) {
			this.contObj.show();
		}
	},
	
	/**
	 * Hide/Show brick depending on newHTML
	 * @param {mixed} new HTML for replace
	 * @param {boolean} true, if new brick has hidden class
	 */
	prepareToReplaceWith: function( newHTML, isHidden ) {
		this.toggle( !isHidden && newHTML );
	},
	
	/**
	 * Replace brick elem
	 * @param {mixed} new html
	 */
	replaceWith: function( newHTML ) {
		this.prepareToReplaceWith( newHTML );
		this.elem.replaceWith( newHTML );
		
	},
	
	/**
	 * Replace html for brick
	 * @param {mixed} new html
	 */
	replaceHTMLWith: function( newHTML ) {
		this.prepareToReplaceWith( newHTML.html, newHTML.isHidden );
		this.elem.empty().html(newHTML.html);
	},
	
	/**
	 * Replace content elem of brick
	 * @param {mixed} new brick content
	 */
	replaceContentWith: function( newContent ) {
		this.prepareToReplaceWith( newContent );
		this.contentElem.replaceWith( newContent );
	},
	
	/**
	 * Replace html for brick content
	 * @param {mixed} new contents
	 */
	replaceContentHTMLWith: function( newHTML ) {
		this.prepareToReplaceWith( newHTML );
		this.contentElem.empty().html( newHTML );
	},
	
	/**
	 * Move brick to another container
	 * @param {mixed} Container object to move brick to
	 */
	moveTo: function( newContainer ) {
		var oldContainer = this.contObj;
		//	create a placeholder
		this.elem.after( this.createPlaceholder() );
		//	move the brick
		newContainer.addBrick(this);
		this.contObj = newContainer;
		newContainer.updateVisibility();
		oldContainer.updateVisibility();
	},
	
	/**
	* Construct brick placeholder
	*/
	createPlaceholder: function() {
		var tagName = this.elem.get(0).tagName;
		return $('<' + tagName + ' class="rnr-ph-' + this.name + '"></' + tagName + '>');
	},
	
	/**
	* Check if the brick is visible element
	* @return {boolean}
	*/
	visible: function() {
		var isVisible = Runner.bricks.Brick.superclass.visible.call(this);
		
		if (this.contObj) {
			isVisible = isVisible && this.contObj.visible();
		}
		
		return isVisible;
	}
});

/**
 * @class Runner.bricks.Container
 */
Runner.bricks.Container = Runner.extend( Runner.bricks.BrickManager, {
	
	blockObj: false,
	
	constructor: function(cfg) {
		Runner.bricks.Container.superclass.constructor.call(this, cfg);	
		this.baseClass = this.baseName + 'c-';
		this.hiddenClass = this.baseName + 'hiddencontainer';
		this.getElemName();
		this.getBlock();
	},
	
	getElemName: function() {
		Runner.bricks.Container.superclass.getElemName.call(this, $('.'+ this.baseName + 'c:first',this.elem));
	},
	
	/**
	 * Hide container if it contains no visible bricks and show otherwise
	 */
	updateVisibility: function() {
		var bricks = this.getBricks(),
			visible = false, i;
			
		for (i = 0; i < bricks.length; i++) {
			if ( bricks[i].visible() ) {
				visible = true;
				break;
			}
		}
		
		this.toggle( visible );
	},
	
	/**
	 * Hide container
	 * If this container the single in the block
	 * Then the block must be hidden too!
	 */
	hide: function() {
		Runner.bricks.Container.superclass.hide.call(this);
		//	hide wrapper if exists
		var $bWrapperParent = this.getBWrapperParent();
		
		if ( $bWrapperParent.length ) {
			new Runner.bricks.Brick({
				elem: $bWrapperParent,
				oldLayout: this.oldLayout
			}).hide();
			return;
		}
		
		if ( this.blockObj ) {
			this.blockObj.updateVisibility();
		}
	},
	
	/**
	 * Find the container's parent having 'runner-b-wrapper' class
	 * @return {jQuery object} 
	 */
	getBWrapperParent: function() {
		if ( this.pageCont ) {
			return $( this.pageCont ).find( $(this.elem).closest('.' + this.baseName + 'b-wrapper') );
		}

		return $(this.elem).closest('.' + this.baseName + 'b-wrapper');
	},
	
	/**
	 * Show container
	 * If this container position in the hidden block
	 * Than the block must be shown too!
	 */
	show: function() {
		Runner.bricks.Container.superclass.show.call(this);
		//	show wrapper if exists
		var $bWrapperParent = this.getBWrapperParent();
		
		if ( $bWrapperParent.length ) {
			new Runner.bricks.Brick({
				elem: $bWrapperParent,
				oldLayout: this.oldLayout
			}).show();
			return;
		}
		
		if ( this.blockObj ) {
			this.blockObj.show();
		}
	},
	
	/**
	 * Get array of bricks for container
	 * @method
	 * @return {array}  
	 */
	getBricks: function() {
		var bricksArr = [],
			_self = this;
			
		$('[class*="' + this.baseName + 'b-"]', this.elem).each( function() {
			bricksArr.push( new Runner.bricks.Brick({
				elem: $(this),
				oldLayout: _self.oldLayout
			}) );
		});
		
		return bricksArr;
	},
	
	/**
	 * Get block HTML element 
	 * @method
	 * @return {object}  
	 */
	getBlock: function( elem ) {
		var blockSelector, blockElem;
		
		if ( !this.oldLayout ) {
			blockSelector = '.rnr-top, .rnr-left, .rnr-center, .rnr-right, .rnr-bottom';
		} else {
			blockSelector = 'td';
		}
	
		if (typeof elem == 'undefined') {
			blockElem = this.elem.closest( blockSelector );
		} else {
			blockElem = elem.parent().closest( blockSelector );
		}
		
		if ( blockElem.hasClass(this.baseName + 'wrapper') ) {
			this.getBlock( blockElem );
			return;
		}
		if (blockElem.length) {
			this.blockObj = new Runner.bricks.Block({
				elem: blockElem,
				oldLayout: this.oldLayout
			});
		}
	},
	/**
	 * Clone container object and HTML structure
	 * @method
	 * @return {object}  
	 */
	cloneEmpty: function() {
		var bricks = this.getBricks(),
			clone = this.elem,
			cloner;
		
		cloner = function(_clone) {
			var cloned, i,
				$elem = $(this),
				matchedBrick = null;
			
			for (i = bricks.length - 1; i >= 0; --i) {
				if ( bricks[i].elem.is(this) ) {
					matchedBrick = bricks[i];
					break;
				}
			}
			if ( $elem.hasClass("rnr-hfiller") || $elem.hasClass("filler") ) {
				return;
			}
			if (matchedBrick) {
			//	insert brick placeholder instead of a brick
				if (_clone) {
					$(_clone).append( matchedBrick.createPlaceholder() );
				}
				return;
			}
			
			cloned = $elem.get(0).cloneNode(false);
			if (_clone) {
				$(_clone).append( cloned );
			}
			$elem.children().each( function() {
				cloner.call(this, cloned);
			});
			
			return cloned;
		}
		
		return new Runner.bricks.Container({
				elem: $( cloner.call( this.elem ) ),
				pageCont: this.pageCont,
				oldLayout: this.oldLayout
			});
	},

	/**
	 * Append container HTML code to element
	 * @method
	 */
	appendTo: function( elem ) {
		$(elem).append( this.elem );
	},

	/**
	 * add brick to container
	 * @method
	 * @param {Brick} Brick object
	 */
	addBrick: function( brick ) { 
		var placeholder = this.findPlaceholder( brick.name );
		
		if ( placeholder.length ) {
			placeholder.replaceWith( brick.elem );
		} else {
			this.elem.children().first().append( brick.elem );
		}
	},
	
	/**
	 * Find brick placeholder inside a container
	 */
	findPlaceholder: function( name ) {
		return $(".rnr-ph-" + name, this.elem);
	},
	
	/**
	 * Tests if container objects are equal
	 * @method
	 * @param {Container} Container object
	 * @return {bool} 
	 */
	is: function( contObj ) {
		return this.elem.is( contObj.elem );
	}
});

/**
 * @class Runner.bricks.Block
 */
Runner.bricks.Block = Runner.extend( Runner.bricks.BrickManager, {

	constructor: function(cfg) {
		Runner.bricks.Block.superclass.constructor.call(this, cfg);	
		this.baseClass = this.baseName;
		this.hiddenClass = this.baseName + 'hiddenblock';
		this.getElemName();
	},
	
	/**
	 * Get array of containers for block
	 * @method
	 * @return {array}  
	 */
	getContainers: function() {
		var contsArr = [];
		$('[class*="' + this.baseName + 's-"]', this.elem).each( function() {
			contsArr.push( new Runner.bricks.Container({
				elem: $(this),
				oldLayout: this.oldLayout
			}) );
		});
		return contsArr;
	},
	
	/**
	 * Hide block if it contains no visible bricks and show otherwise
	 */
	updateVisibility: function() {
		var conts = this.getContainers(),
			visible = false;
			
		for (var i = 0; i < conts.length; i++) {
			if ( conts[i].visible() ) {
				visible = true;
				break;
			}
		}
		this.toggle( visible );
	}
});

// create namespace
Runner.namespace('Runner.menu');

/**
 * @class Runner.menu.Manager
 * Abstract base class that provides common menu functionality. 
 */
Runner.menu.Manager = Runner.extend( Runner.emptyFn, {
	/**
	 * Is use RTL on page
	 * @param {boolean}
	 */	
	isDirRTL: false,
	
	init: function() {
		var dir = $('html').attr('dir') || '';
		if ( dir.toLowerCase() == 'rtl' ) {
			this.isDirRTL = true;
		}
	},
	
	/**
	 * Click handler function for menu items
	 * @param {object} event
	 */	
	itemClickHandler: function(event) {
		var target = event.target,
			link = $('a:first', this)[0];
		
		if (typeof link === "undefined") {
			return false;
		}
		
		if ($(this).hasClass('Group') && target.nodeName!='IMG' && !link.href) {
			$('.groupImg:first', this).click();
			return;
		}
		
		if (target.nodeName == "A" ) {
			if (target.rel == 'external') {
				$(target).attr('target', "_blank");
				//return !window.open(target.href);
			}
			return;
		}
		
		Runner.Event.prototype.stopEvent(event);
		if (link.href) {
			if (link.rel == 'external') {
				return !window.open(link.href);
			}
			window.location = link.href;
		}
	}
});

/**
 * @class Runner.menu.QuickJump
 * Class that provides quick jump menu functionality. 
 */
Runner.menu.QuickJump = Runner.extend( Runner.emptyFn, {
	/**
	 * Current selected item in dropdown
	 * @type Integer
	 */
	selectCurrent: -1,
	/**
	 * Init quickjump menu
	 * Bind events handlers on dropdown
	 */
	init: function() {
		var menuObj = this;
		$(".runner-quickjump:first").prop("initialized","true");
		$(".runner-quickjump").bind({
			focus: function() {
				menuObj.selectCurrent = this.selectedIndex; 
			},
			change: function() {
				if (this.options[this.selectedIndex].value) {
					if ($(this.options[this.selectedIndex]).attr('link') == 'External') {
						window.open(this.options[this.selectedIndex].value);
					} else {
						window.location.href = this.options[this.selectedIndex].value;
					}
				} else {
					this.selectedIndex = menuObj.selectCurrent;
				}
			}	
		});
	}	
});

/**
 * @class Runner.menu.Horizontal
 * Class that provides horizontal menu functionality. 
 */
Runner.menu.Horizontal = Runner.extend( Runner.menu.Manager, {
	/**
	 * Max submenu width
	 * @type Integer
	 */
	maxSubMenuWidth: 0, 
	/**
	 * Max group (ul) width
	 * @type Integer
	 */
	maxGroupWidth: 0,
	/**
	 * Max item (li) width
	 * @type Integer
	 */
	maxItemWidth: 0,
	/** 
	 * Absolute posution for top item
	 * @type object
	 */
	topItemAbsPos: null,
	/**
	 * Was item hovered or not
	 * @type Boolean
	 */
	itemHovered: false,
	/**
	 * Sub menu for hovered item
	 * @type array
	 */
	subMenu: [],
	
	init: function() {
		Runner.menu.Horizontal.superclass.init.call(this);
		this.bindHoverOnItems();
		this.bindClickOnItems();
		this.setRaquoToTopItems();
		$(".runner-hmenu:first").prop("initialized","true");
	},
	
	/**
	 * Find sub menu for item
	 * @param {obj} elem
	 */
	findSubMenu: function(elem) {
		this.subMenu = $('ul:first:has(li)', elem);
	},
	
	/**
	 * Manage add/remove class Active
	 * @param {obj} elem
	 * @param {boolean} toggle
	 */
	manageActiveClass: function(elem, toggle) {
		if ($(elem).hasClass('Separator')) {
			return;
		}
		if ($('table:first', elem).length) { 
			//elem is a top item 
			$('.runner-menutab', elem).toggleClass('active', toggle);
			return;	
		}
		$(elem).toggleClass('active', toggle);
	},
	
	/**
	 * Manage add/remove class "expanded"
	 * @param {obj} elem
	 * @param {boolean} toggle
	 */		
	manageExpandedClass: function(elem, toggle) {
		if ($('table:first', elem).length) {
			$('.runner-menutab', elem).toggleClass('expanded', toggle);
			return;
		}
		$(elem).toggleClass('expanded', toggle);
	},
	
	/**
	 * Bind hover event on every menu item
	 * For hovered items add class 'active'
	 * For items losted hover event remove class 'active'
	 * Add the "expanded" class on hover for items that have any sub-items and
	 * remove the "expanded" class for these items when the mouse pointer leaves them
	 */
	bindHoverOnItems: function() {
		var menuObj = this;
		
		$('.runner-hmenu td, .runner-hmenu ul li').hover(
			function() {
				var isTopItem, $raquo;
				
				menuObj.manageActiveClass(this, true);		
				menuObj.findSubMenu(this);
				if (!menuObj.subMenu.length) {
					return;
				}
				menuObj.manageExpandedClass(this, true);	
				menuObj.maxGroupWidth = 0;
				
				isTopItem = $(this).is("td");
				
				if (isTopItem) {
					menuObj.topItemAbsPos = $(this).position();
					menuObj.maxItemWidth = menuObj.topItemAbsPos.width;
				}
							
				$('li[parent=' + (menuObj.subMenu.attr('id')) + '] a', menuObj.subMenu).each(function() {
					if (menuObj.maxGroupWidth < this.offsetWidth) {
						menuObj.maxGroupWidth = this.offsetWidth
					}
				});
				
				if (isTopItem && menuObj.maxGroupWidth < menuObj.maxItemWidth) {
					menuObj.maxSubMenuWidth = menuObj.maxItemWidth;
				} else {
					menuObj.maxSubMenuWidth = menuObj.maxGroupWidth;
				}
				
				menuObj.maxSubMenuWidth += 10;
				menuObj.subMenu.css('width', menuObj.maxSubMenuWidth + 'px');
				
				if (isTopItem) { //td is hovered
					if (menuObj.isDirRTL) {
						menuObj.subMenu.css('left', menuObj.topItemAbsPos.left + ($(this).outerWidth() - menuObj.subMenu[0].offsetWidth) + 'px');
					} else {
						menuObj.subMenu.css('left', menuObj.topItemAbsPos.left + 'px');
					}
					menuObj.subMenu.css('top', menuObj.topItemAbsPos.top + $(this).outerHeight() - 1 + 'px');
				} else { //li is hovered
					$raquo = $('.raquo', this);
					leftPosition = $raquo.position().left + $raquo.get(0).offsetWidth - $raquo.position().left + 10;
					if ( $(this).outerWidth() < leftPosition ) {
						leftPosition = $(this).outerWidth() - 1;
					}
					menuObj.subMenu.css({
						'top': this.offsetTop + 'px',
						'left': leftPosition + 'px'
					});
				}
				
				$('li[parent=' + menuObj.subMenu.attr('id') + ']', menuObj.subMenu).each( function() {
					$(this).css('width', menuObj.maxSubMenuWidth + 'px');
					$('ul:first', this).css( (menuObj.isDirRTL ? 'right' : 'left'), menuObj.maxSubMenuWidth + 'px' );
				});		
			},
			function() {
				menuObj.findSubMenu(this);
				if ( menuObj.subMenu.length ) { 
					menuObj.manageExpandedClass(this, false);	
				}
				menuObj.manageActiveClass(this, false);
			}
		);
	},	
	
	/**
	 * Bind the click event's handler with the menu items
	 */
	bindClickOnItems: function() {
		$('.runner-hmenu td, .runner-hmenu ul li').click(this.itemClickHandler);
	},
	
	/**
	 * Set raquo for top items which has submenus
	 */	
	setRaquoToTopItems: function() {	
		var curTopItem;
		
		$('a:first', '.runner-hmenu td:has(ul:has(li)), .runner-hmenu li:has(ul:has(li))').each(function() {
			if (!$('b',this).length) {
				$(this).after('<b class="raquo">&nbsp;&raquo;</b>');
			}
		});
		//if submenus of top item has current item, then add current item title to top item after raquo 
		curTopItem = $('.runner-hmenu td:has(ul:has(li.current))');
		$('b.raquo:first', curTopItem).append("&nbsp;<b class='subcur'>" + $(".runner-hmenu .curlink").attr('itemtitle') + "</b>");
		$('tr.runner-menutab', curTopItem).addClass('current');
		$('.runner-hmenu ul li ul li ul').css('top','0px');
	}
});

/**
 * @class Runner.menu.SimpleVmenu
 * Class that provides vertical simple menu functionality. 
 */
Runner.menu.SimpleVmenu = Runner.extend( Runner.menu.Manager,{
	/**
	 * Sub menu for hovered item
	 * @type array
	 */
	subMenu: [],
	
	init: function() {
		Runner.menu.SimpleVmenu.superclass.init.call(this);
		this.bindHoverOnItems();
		this.bindClickOnItems();
		this.setRaquoToTopItems();	
		$(".runner-vmenu.simple:first").prop("initialized","true");
	},
	
	/**
	 * Find sub menu for item
	 * @param {obj} elem
	 */
	findSubMenu: function(elem) {
		this.subMenu = $('ul:first:has(li)', elem);
	},
	
	/**
	 * Manage add/remove class Active
	 * @param {obj} elem
	 * @param {boolean} toggle
	 */
	manageActiveClass: function(elem, toggle) {
		if ( !$(elem).hasClass('Separator') ) {
			$(elem).toggleClass('active', toggle);
		}
	},
	
	/**
	 * Manage add/remove class "expanded"
	 * @param {obj} elem
	 * @param {boolean} toggle
	 */	
	manageExpandedClass: function(elem, toggle) {
		$(elem).toggleClass('expanded', toggle);
	},
	
	/**
	 * Bind hover event on every menu item
	 * For hovered items add class 'active'
	 * For items losted hover event remove class 'active'
	 * Add the "expanded" class on hover for items that have any sub-items and
	 * remove the "expanded" class for these items when the mouse pointer leaves them
	 */
	bindHoverOnItems: function() {
		var menuObj = this;
		
		$('.runner-vmenu.simple, .runner-vmenu.simple ul li').hover(
			//hover: handlerIn
			function() {
				var	elParentUlPosition, elParentUlWidth, 
					offsetHSide, offsetValue, isTopItem;
				
				menuObj.manageActiveClass(this, true);	
				menuObj.findSubMenu(this);
				if (!menuObj.subMenu.length) {
					return;
				}
				menuObj.manageExpandedClass(this, true);
				
				isTopItem = $(this).hasClass("runner-vmenu"); //is true if the hovered element is tr	
				elParentUlWidth = isTopItem? $(this).width() : $(this).closest("ul").width();			
				elParentUlPosition = $(this).position(); //the element hasn't a positioned ancestor
				offsetHSide = menuObj.isDirRTL ? 'right': 'left';
				
				if (!isTopItem) {
					//li element is hovered
					offsetValue = elParentUlWidth;
				} else {
					//tr element is hovered			
					offsetValue = menuObj.isDirRTL ? $(window).width() - elParentUlPosition.left : elParentUlWidth + elParentUlPosition.left ;
				}
				
				menuObj.subMenu.css(offsetHSide , offsetValue + 'px');
				menuObj.subMenu.css('top', (elParentUlPosition.top) + 'px');
			},
			//hover: handlerOut
			function() {
				menuObj.findSubMenu(this);
				if (menuObj.subMenu.length) {
					menuObj.manageExpandedClass(this, false);
				}
				menuObj.manageActiveClass(this, false);
			}
		);
	},
	
	/**
	 * Bind the click event's handler with the menu items
	 */
	bindClickOnItems: function() {
		$('.runner-vmenu.simple, .runner-vmenu.simple ul li').click(this.itemClickHandler);
	},
	
	/**
	 * Set raquo for top items which has submenus
	 */
	setRaquoToTopItems: function() {
		var curTopItem;
		
		$('.runner-vmenu.simple:has(ul:has(li)), .runner-vmenu.simple li:has(ul:has(li))').find('a:first').each(function() {
			if (!$('b',this).length) {
				$(this).after('<b class="raquo">&nbsp;&raquo;</b>');
			}
		});
		//if submenus of top item has current item, then add current item title to top item after raquo 
		curTopItem = $('.runner-vmenu.simple:has(ul:has(li.current))');
		curTopItem.find("b.raquo:first").append("&nbsp;<b class='subcur'>" + $(".runner-vmenu.simple a.curlink").attr('itemtitle') + "</b>");
		curTopItem.addClass('current');
	}
});


/**
 * @class Runner.menu.TreeLikeVmenu
 * Class that provides vertical tree-like menu functionality. 
 */
Runner.menu.TreeLikeVmenu = Runner.extend( Runner.menu.Manager, {
	/**
	 * Cookie root
	 */
	cookieRoot: "",	
	/**
	 * Current item
	 */
	curItem: null,
	/**
	 * Id of current item
	 */
	curItemId: "",
	/**
	 * Level of current item
	 */
	curItemLevel: -1,
	
	init: function() {
		if ($('.runner-vmenu.tree .curlink').length) {
			this.curItem = $('.runner-vmenu.tree .curlink').closest('tr');
			this.curItemId = $(this.curItem).attr('id');
			this.curItemLevel = this.getItemLevel(this.curItem);
		}
		//hide all submenus
		$('.runner-vmenu.tree[parent]').addClass('runner-hiddenelem');
		
		//init menu
		this.bindHoverOnItems();
		this.setCurrentStyle();
		this.toggleMenuGroup();
		this.manageExpandCollapse();
		
		//open menu group saved in cookie
		this.openMenuOnLoad();
		$(".runner-vmenu.tree:first").prop("initialized","true");
	},
	
	/**
	 * Get menu item level
	 * There are 5 levels in tree like menu
	 * Top items have zero level
	 * Default value -1, level is not define
	 * @param {object} jquery item object
	 * @return {number} number of level
	 */
	getItemLevel: function(item) {
		var clsItem = $(item).attr('class'),
			pos = clsItem.indexOf("level");
		//if not found level, return zero - top item
		if (pos == -1) {
			return 0;
		}
		//cut number of level, parse it to int and return number
		return parseInt(clsItem.substr(pos + 5, 1), 10);
	},
	
	/**
	 * Bind hover event on every menu item
	 * For hovered items add class 'active'
	 * For items losted hover event remove class 'active'
	 */
	bindHoverOnItems: function() {
		$('.runner-vmenu.tree[id^=item]').hover(function() {
			if ($(this).parent().attr('class')!='Separator') {
				$(this).addClass('active');
			}
		},
		function() {
			if ($(this).parent().attr('class')!='Separator') {
				$(this).removeClass('active'); 
			}
		});
		
		$('.runner-vmenu.tree[id^=item]').click(this.itemClickHandler);
	},
	
	/**
	 * Set current style for top group
	 * which has current item in children
	 */
	setCurrentStyle: function() {
		$('.runner-vmenu.tree.Group[view=topitem]').each(function() {
			var group = this;
			$('.runner-vmenu.tree[topparent=' + this.id + ']').each(function() {
				if ($(this).hasClass('current')) {
					$(group).addClass('current');
				}
			});
		});
	},
	
	/**
	 * Bind click event on span to toggle menu group
	 */
	toggleMenuGroup: function() {
		var menuObj = this;
		
		$('.runner-vmenu.tree.Group span').click(function() {
			
			var spanItem = $(this).closest("tr"),
				spanItemId = spanItem.attr('id');
			
			if ($('.groupImg',this).attr('src') == Runner.pages.constants.PLUS_GIF) {
				//show all children to the current item
				menuObj.showGroupChildren(spanItem, spanItemId);
			}
			else if ($('.groupImg',this).attr('src') == Runner.pages.constants.MINUS_GIF) {
				
				//hide all children of closed group
				menuObj.hideGroupChildren(spanItem, spanItemId);
				
				if (spanItemId!=menuObj.curItemId && menuObj.curItemLevel > menuObj.getItemLevel(spanItem) && menuObj.hasCurrentItem(spanItem, spanItemId)) {
					spanItem.addClass('current');
				}
			}
			return false;
		});
	},
	
	/**
	 * Show all children of closed group
	 * If this group has current item,
	 * then show all groups in this group, which has current item 
	 * @param {object}
	 */
	showGroupChildren: function(item, itemId) {
		var menuObj = this;
		if (!itemId) {
			itemId = $(item).attr('id');
		}
		
		//set image minus for closed group
		$('.groupImg',item).attr('src', Runner.pages.constants.MINUS_GIF);
		
		if (itemId!=this.curItemId && $(item).hasClass('current'))
			$(item).removeClass('current');
		
		$('.runner-vmenu.tree[parent=' + itemId + ']').each(function() {
			$(this).removeClass('runner-hiddenelem');
			if ($(this).hasClass('Group') && menuObj.curItemLevel > menuObj.getItemLevel(this) && menuObj.hasCurrentItem(this)) {
				menuObj.showGroupChildren(this);
			}
		});
		
		// add to cookie opened group
		this.addToCookie(itemId);
	},
	
	/**
	 * Hide all children of group
	 * @param {object}
	 */
	hideGroupChildren: function(item, itemId) {
		var menuObj = this;
		if (!itemId) {
			itemId = $(item).attr('id');
		}
		
		//set image plus for closed group
		$('.groupImg',item).attr('src', Runner.pages.constants.PLUS_GIF);
		
		$('.runner-vmenu.tree[parent=' + itemId + ']').each(function() {
			$(this).addClass('runner-hiddenelem');
			if ($(this).hasClass('Group'))
				menuObj.hideGroupChildren(this);
		});
		
		// remove from cookie closed group
		this.removeFromCookie(itemId);
	},
	
	/**
	 * Check has item in children current item or not
	 * @param {object}
	 * @return {boolean}
	 */	
	hasCurrentItem: function(item, itemId) {
		if (!itemId) {
			itemId = $(item).attr('id');
		}
		if ($('.runner-vmenu.tree.[parent=' + itemId + ']').hasClass('current')) {			
			return true;
		}
		
		var colSubGroups = $('.runner-vmenu.tree.Group.[parent=' + itemId + ']').length;
		for (var i = 0; i < colSubGroups; i++) {
			if (this.hasCurrentItem($('.runner-vmenu.tree.Group.[parent=' + itemId + ']').get(i)))			
				return true;
		}
		return false;
	},
	
	/**
	 * Menage group menu with expand/collapse button control
	 */
	manageExpandCollapse: function() {
		
		var menuObj = this,
			expand = false;
		
		if ($('.runner-vmenu.tree.Group[view=topitem]').length) {
			$('.manage').css('display','inline');
			$('.manage a').click(function() {
				if (expand) {
					expand = false;
					
					$('.runner-vmenu.tree[parent]').addClass('runner-hiddenelem');
					$('.manage a').empty();
					$('img.groupImg').attr('src', Runner.pages.constants.PLUS_GIF);
					$('.manage a').append('<img src=\"' + Runner.pages.constants.PLUS_GIF + '\" border=0> &nbsp;&nbsp;' + Runner.lang.constants.TEXT_EXPAND_ALL);
					
					// on collapse all, remove all ids from cookie
					delete_cookie('openMenuGroupIds', menuObj.cookieRoot, '');
					
					if (menuObj.curItem) {
						$('#' + menuObj.curItem.attr('topparent')).addClass('current');
					}
				} else {
					expand = true;
					
					$('.runner-vmenu.tree[parent]').removeClass('runner-hiddenelem');
					$('.manage a').empty();
					$('img.groupImg').attr('src',Runner.pages.constants.MINUS_GIF);
					$('.manage a').append('<img src=\"' + Runner.pages.constants.MINUS_GIF 
							+ '\" border=0> &nbsp;&nbsp;' + Runner.lang.constants.TEXT_COLLAPSE_ALL);
					
					// on expand all add all group ids to cookie
					$('.runner-vmenu.tree.Group').each(function() {
						menuObj.addToCookie(this.id);
					});
					
					if (menuObj.curItem) {
						$('#' + menuObj.curItem.attr('topparent')).removeClass('current');
					}	
				}
				return false; 
			});
		}
	},
	
	/**
	 * Add opened menu group id to cookie
	 * @param {string} group id
	 */
	addToCookie: function(menuGroupId) {
		var openMenuGroupIds = get_cookie('openMenuGroupIds');
		
		if (openMenuGroupIds) {
			if (openMenuGroupIds.indexOf(menuGroupId) == -1) {
				openMenuGroupIds += ";" + menuGroupId;
			}
		} else {
			openMenuGroupIds = menuGroupId;
		}
		set_cookie( 'openMenuGroupIds', openMenuGroupIds, '', this.cookieRoot );
		this.toggleExpandCollapse();
	},
	
	/**
	 * Remove opened menu group id from cookie
	 * @param {string} group id
	 */ 
	removeFromCookie: function(menuGroupId) {
		var openMenuGroupIds = get_cookie('openMenuGroupIds');
		
		if (openMenuGroupIds) {
			openMenuGroupIds = openMenuGroupIds.replace((";" + menuGroupId), "");
			openMenuGroupIds = openMenuGroupIds.replace(menuGroupId, "");
		
			if (openMenuGroupIds.indexOf(';')==0)
				openMenuGroupIds = openMenuGroupIds.substr(1,openMenuGroupIds.length);
			
			set_cookie( 'openMenuGroupIds', openMenuGroupIds, '', this.cookieRoot );
		}
		
		setTimeout(function() {
			Runner.menu.TreeLikeVmenu.prototype.toggleExpandCollapse();
		},500);
	},
	
	/**
	 * Expand/Collapse button control
	 * If all menu groups was opened then change img for minus
	 * Else if all menu groups was closed then change img for minus
	 */
	toggleExpandCollapse: function() {
		var visibleLength = $(".runner-vmenu.tree.subitem:visible").length,
			hiddenLength = $(".runner-vmenu.tree.subitem:hidden").length;
		
		if (visibleLength == 0 && hiddenLength > 0) {
			$('.manage a').empty();
			$('.groupImg').attr('src', Runner.pages.constants.PLUS_GIF);
			$('.manage a').append('<img src=\"' + Runner.pages.constants.PLUS_GIF + '\" border=0> &nbsp;&nbsp;' + Runner.lang.constants.TEXT_EXPAND_ALL);	
		} else if (visibleLength != 0 && hiddenLength == 0) {
			$('.manage a').empty();
			$('.groupImg').attr('src', Runner.pages.constants.MINUS_GIF);
			$('.manage a').append('<img src=\"' + Runner.pages.constants.MINUS_GIF + '\" border=0> &nbsp;&nbsp;' + Runner.lang.constants.TEXT_COLLAPSE_ALL);
		}
	},
	
	/**
	 * Open menu's group on page after load
	 */
	openMenuOnLoad: function() {
		this.cookieRoot = Runner.getCookieRoot();
		
		var openMenuGroupIds = get_cookie('openMenuGroupIds');
		if (openMenuGroupIds) {
			var groupForOpenArr = openMenuGroupIds.split(";");
			for (var i = 0; i < groupForOpenArr.length; i++) {
				if (groupForOpenArr[i].indexOf('item') == -1) {
					continue;
				}
				var group = $('#' + groupForOpenArr[i]);
				group.removeClass('runner-hiddenelem');
				$('.runner-vmenu.tree[parent=' + groupForOpenArr[i] + ']').removeClass('runner-hiddenelem');
				$(".groupImg", group).attr("src", Runner.pages.constants.MINUS_GIF);
			}
			this.afterOpenMenuOnLoad();
		}
		this.toggleExpandCollapse();
	},
	
	/**
	 * Set current style to opened group after open menu on load
	 * @param {object}
	 */
	afterOpenMenuOnLoad: function(item) {
		if (typeof item == 'undefined') {
			if (this.curItem)
				item = this.curItem;
			else
				return;
		}
		//if item topItem 
		if (item.attr('view') == 'topitem')
			return;
		//remove current class from top item
		$('#' + item.attr('topparent')).removeClass('current');
		//get item parent
		var itemPar = $('#' + item.attr('parent'));
		//if parent open, then check recursively next parent 
		if ($(".groupImg", itemPar).attr('src') == Runner.pages.constants.PLUS_GIF) {
			itemPar.addClass('current');
			if (itemPar.attr('view')!='topitem') {
				this.afterOpenMenuOnLoad(itemPar);
			}
		}
	}
});


/**
 * @class Runner.menu.QuickJumpNew
 * Class that provides new quick jump menu functionality. 
 */
Runner.menu.QuickJumpNew = Runner.extend( Runner.emptyFn, {
	/**
	 * Current selected item in dropdown
	 * @type Integer
	 */
	selectCurrent: -1,
	/**
	 * Init quickjump menu
	 * Bind events handlers on dropdown
	 */
	init: function() {
		var menuObj = this;
		$(".rnr-quickjump:first").prop("initialized", "true");
		
		$(".rnr-quickjump")
			.focus( function() {
				menuObj.selectCurrent = this.selectedIndex; 
			})
			.change( function() {
				if ( this.options[this.selectedIndex].value ) {
					if ( $(this.options[ this.selectedIndex ]).attr('link') == 'External' ) {
						window.open( this.options[ this.selectedIndex ].value );
						return;
					} 
					window.location.href = this.options[ this.selectedIndex ].value;
					return;
				} 
				this.selectedIndex = menuObj.selectCurrent;
			});	
	}	
});

/**
 * @class Runner.menu.SimpleVmenuNew
 * Class that provides simple vertical menu functionality. 
 */
Runner.menu.SimpleVmenuNew = Runner.extend( Runner.menu.Manager, {
	/**
	* The jQuery object representing 
	* the element containing a menu (ul)
	* @type {object}
	*/
	menuContainer: {},

	/**
	* @param {object } jQmenuElem 
	*/
	init: function( jQmenuElem ) {
		this.setMenuObject( jQmenuElem );
		
		this.bindHoverOnItems();
		this.bindClickOnItems();
		this.setRaquoToTopItems();	
		this.setRaquoToSubItems();	
	},
	
	/**
	* Assign the menu object with 
	* the corresponding jQuery element
	* @param {object} jQmenuElem
	*/
	setMenuObject: function( jQmenuElem ) {
		this.menuContainer = jQmenuElem;
	},
	
	/**
	* Bind the hover events with every menu item
	* Add the "expanded" class on hover for items 
	* that have any sub-items and
	* remove the "expanded" class for these items 
	* when the mouse pointer leaves them
	*/
	bindHoverOnItems: function() {	
		$('.current', this.menuContainer).attr('data-current', 1);
		
		$("li", this.menuContainer).hover(		
			function() {
				// add expanded class to all li parents up to .runner-b-vmenu
				$(this).parentsUntil(".rnr-b-vmenu.simple", ".rnr-b-vmenu.simple li").addClass("expanded").removeClass("current");
			},
			function() {
				var $items = $(this).parent().closest('.rnr-b-vmenu.simple li')				
					.removeClass("expanded");
				
				$items.filter("[data-current=1]")
					.addClass("current");
			}
		);
	},
	
	/**
	* Bind the click event's handler with the menu items
	*/
	bindClickOnItems: function() {
		$('li', this.menuContainer)
			.on('click', this.itemClickHandler)
			.on('touchend', function() {
				$(this).trigger('click');
			});
	},
	
	/**
	* Set raquo for top items that have submenus
	*/
	setRaquoToTopItems: function() {
		var curTopItem = this.menuContainer.children(':has(ul:has(li.current))'),
			title = this.menuContainer.find("li.current:last").find("a:first").attr('itemtitle'),
			currentSubitemText = "<b class='subcur'>&nbsp;&raquo;&nbsp;" + title + "&nbsp;</b>",
			raquo = '<b class="raquo">&raquo;</b>',
			margin = Runner.isDirRTL() ? "margin-left" : "margin-right";
		
		this.menuContainer.children('*:has(ul:has(li))').find('a:first').each( function( index, elem ) {	
			var $elem = $(elem),
				$rightMostElem = $elem;
			
			if ( $elem.siblings('b').length ) {
				return;
			}
			
			if ( $elem.closest(curTopItem).length ) {
				$rightMostElem = $(currentSubitemText).insertAfter($elem);
				
				if ( !$rightMostElem.is(":visible") ) {
					$rightMostElem = $elem;
				}
				
			} 

			$elem.parent()
				.on('touchstart' + ( navigator.msMaxTouchPoints ? ' pointerover' : '' ), function() { // IE + touchscreen and Safari + IOS fix #9045
					var $groups = $elem.parents('.Group'),
						$groups = $groups.length ? $groups : $elem.parents('.menuGroup'),
						$currentGroup = $groups.eq(0),
						toggler = !$currentGroup.hasClass('touchHover');
						
					$groups.addClass('touchHover');
					$currentGroup.toggleClass('touchHover', toggler);
				})			
				.prepend( raquo );
			
			$rightMostElem.css( margin, "1em" );
		});
	},

	/**
	* Set raquo to subitems that have submenus
	*/
	setRaquoToSubItems: function() {
		var raquo = '<b class="raquo">&raquo;</b>',
			margin = Runner.isDirRTL() ? "margin-left" : "margin-right";;
		
		$('ul li:has(ul:has(li))', this.menuContainer).find('a:first').each( function(index, elem) {
			var $elem = $(elem);
			
			if ( $elem.siblings('b').length ) {
				return;
			}
			
			$elem.css( margin, Runner.isIE ? "1em" : "0.2em" )
			$elem.parent()
				.on('touchstart' + ( navigator.msMaxTouchPoints ? ' pointerover' : '' ), function() { // IE + touchscreen and Safari + IOS fix #9045
					var $groups = $elem.parents('.Group'),
						$groups = $groups.length ? $groups : $elem.parents('.menuGroup'),
						$currentGroup = $groups.eq(0),
						toggler = !$currentGroup.hasClass('touchHover');
						
					$groups.addClass('touchHover');
					$currentGroup.toggleClass('touchHover', toggler);
				})
				.prepend( raquo );
		});
	}
});

/**
 * @class Runner.menu.HorizontalNew
 * Class that provides horizontal menu functionality. 
 */
Runner.menu.HorizontalNew = Runner.extend( Runner.menu.Manager, {
	/**
	* The jQuery container object representing 
	* the element containing a menu (div)
	* @type {object}
	*/
	menuContainer: {},

	/**
	* @param {object} jQmenuContainer 
	*/	
	init: function( jQmenuContainer ) {
		this.setMenuObject( jQmenuContainer );
		
		this.bindHoverOnItems();
		this.bindClickOnItems();
		this.setRaquoToTopItems();
		this.setRaquoToSubItems();
	},

	/**
	* Assign the menu container object with 
	* the corresponding jQuery element
	* @param {object} jQmenuElem
	*/
	setMenuObject: function( jQmenuContainer ) {
		this.menuContainer = jQmenuContainer;
	},
	
	/**
	* Bind hover event with menu items 
	* to provide expanded class functionality
	*/
	bindHoverOnItems: function() {
		$('.current', this.menuContainer).attr('data-current', 1);
		
		$('.rnr-b-hmenu, .rnr-b-hmenu li', this.menuContainer).hover(
			function() {
				// add expanded class to all li parents up to .runner-b-vmenu
				$(this).parentsUntil(".rnr-ch", ".rnr-b-hmenu li, .rnr-b-hmenu").addClass("expanded").removeClass("current");
			},
			function() {
				var $items = $(this).parent().closest('.rnr-b-hmenu li, .rnr-b-hmenu')
					.removeClass("expanded");
					
				$items.filter("[data-current=1]")
					.addClass("current");
			}
		);
	},
	
	/**
	* Bind the click event's handler with the menu items
	*/
	bindClickOnItems: function() {
		$('.rnr-b-hmenu li, .rnr-b-hmenu > div:has(a[id^="itemlink"])', this.menuContainer)
			.on('click', this.itemClickHandler)
			.on('touchend', function() {
				$(this).trigger('click');
			});
	},

	/**
	* Set raquo for top items that have submenus
	*/
	setRaquoToTopItems: Runner.menu.SimpleVmenuNew.prototype.setRaquoToTopItems,

	/**
	* Set raquo to subitems that have submenus
	*/
	setRaquoToSubItems: Runner.menu.SimpleVmenuNew.prototype.setRaquoToSubItems
});

/**
 * @class Runner.menu.TreeLikeVmenuNew
 * Class that provides vertical tree-like menu functionality. 
 */
Runner.menu.TreeLikeVmenuNew = Runner.extend( Runner.menu.Manager, {
	/**
	* The jQuery container object representing 
	* the element containing a menu (ul) 
	* @type {object}
	*/
	menuContainer: {},
	
	/**
	* The menu name
	* @type {string}
	*/
	menuName: "",
	
	/**
	* Initialization flag
	* @type {bool}
	*/
	initialized: false,
	
	/**
	* Flags whether all groups are expanded
	* @type {bool}
	*/
	allExpanded: false,

	/**
	* @param {object } jQmenuElem 
	*/
	init: function( jQmenuElem ) {
		this.setMenuObject( jQmenuElem );
		
		this.bindClickOnItems();
		this.initSubItems();
		this.bindShowHideGroupClick();
		this.bindExpandAllClick();
		//open menu groups saved in cookies
		this.openMenuOnLoad();		
		this.toggleExpandCollapse();
		this.initialized = true;
	},

	/**
	* Assign the menu container object with the corresponding jQuery element
	* and set the menu name
	* @param {object} jQmenuElem
	*/
	setMenuObject: function( jQmenuElem ) {
		this.menuContainer = jQmenuElem;
		this.menuName = jQmenuElem.data('menuname');
	},

	/**
	* Bind the click event's handler with the menu items
	*/
	bindClickOnItems: function() {
		$('.menuLeaf', this.menuContainer).on('click', this.itemClickHandler);
	},	
	
	/**
	* Hide all sub-menus and add the click hanlers for all sub-items
	*/
	initSubItems: function() { 
		var subItems = this.menuContainer.children('.subitem');
		subItems.addClass('rnr-hiddenelem').on('click', this.itemClickHandler);			
	},
	
	/**
	* Get menu item level
	* There are up to 5 levels in tree like menu
	* Top items have level 1
	* @param {object} jquery item object
	* @return {number} number of levels
	*/
	getItemLevel: function( item ) {
		return parseInt( $(item).attr("level"), 10 );
	},
	
	/**
	* Gets a jQuery object representing
	* the current (selected) menu element
	* @return {object} 
	*/
	getCurrentElements: function() {
		return this.menuContainer.children('.current');
	},
	
	/**
	* Hides group of elements with all subgroups
	* @param {DOM elem} item
	*/
	hideGroup: function( item ) {	
		var childItems = this.getChildItems(item),
			menuObj = this;

		if ( !childItems.length ) {
			return;
		}
		
		if (this.initialized) {
			childItems.filter(":not([level=1])").slideUp(100, function() {menuObj.toggleExpandCollapse();});
		} else {
			childItems.filter(":not([level=1])").hide();
		}		
		
		childItems.each( function() {
			menuObj.hideGroup(this);
		});
		
		this.removeFromCookie( $(item).attr('id') );
		$(".groupImg", item).attr('src', Runner.pages.constants.PLUS_GIF);
	},

	/**
	* Shows group of elements
	* @param {DOM elem} item
	*/
	showGroup: function( item ) {	
		var childItems = this.getChildItems(item),
			menuObj = this;
		
		if ( childItems.length ) {
			
			if (this.initialized) {
				childItems.slideDown(100, function() {menuObj.toggleExpandCollapse();});
			} else {
				childItems.show();
			}
			this.addToCookie( $(item).attr('id') );
			$(".groupImg", item).attr('src', Runner.pages.constants.MINUS_GIF);
		}
	},
	
	/**
	* Set current style for top group
	* which has current item in children
	*/
	setCurrentItemStyle: function() { 
		var $items = this.getCurrentElements();
		
		$( '.current', this.menuContainer ).removeClass( 'current' );
		
		while ( $items.length ) {
			$items.each( function( itemId, item ) {			
				var $grCtrl = $( '.groupImg', item );
				
				if ( !$grCtrl.length || $grCtrl.attr( 'src' ) !== Runner.pages.constants.MINUS_GIF ) {
					// not collapsed
					$( item ).addClass('current');
				}
			});
			
			if ( $items.is(':visible') ) {
				break;
			}
			
			$items = this.getParentItem( $items );
		}
	},
	
	/**
	* Bind click event with the "+"/"-" images to toggle the menu groups
	*/
	bindShowHideGroupClick: function() {
		var menuObj = this;
		
		// click in any place of the Group Item except the correct link should toggle the group
		$('.groupImg', this.menuContainer).closest('li').click( function(e) {
			var target = $(e.target),
				liElement, show;
				
			if ( target.is('a') && target.href && target.href !== "#" ) {
				return;
			}
			
			liElement = $(this);
			show = $('.groupImg', this).attr('src') === Runner.pages.constants.PLUS_GIF;

			show ? menuObj.showGroup( liElement ) : menuObj.hideGroup( liElement ); 			
			menuObj.setCurrentItemStyle();
			return false;
		});
	},

	/**
	* Get a jQuery object representing the item's parent element
	* @param {DOM elem} item
	* @return {object}	
	*/
	getParentItem: function(item) {
		var level = this.getItemLevel(item);
		
		return $(item).prevUntil("[level=" + (level - 1) + "]").add( item ).first().prev();
	},

	/**
	* Get a jQuery object representing the item's children elements
	* @param {DOM elem} item
	* @return {object}	 
	*/
	getChildItems: function( item ) {
		var level = this.getItemLevel(item);
		
		if ( isNaN(level) ) {
			return this.menuContainer.children("[level=1]");
		}
		return $(item).nextUntil("[level=" + level + "]", "[level=" + (level + 1) + "]");
	},

	/**
	* Expand or collapse the menu groups with the expand/collapse button
	*/
	bindExpandAllClick: function() {
		var menuObj = this;
		$(".manage", this.menuContainer).click( function() {
			if (menuObj.allExpanded) {
				menuObj.hideGroup();
				// on collapse all, remove all ids from cookies
				delete_cookie('openMenuGroupIds_' + menuObj.menuName, menuObj.cookieRoot, '');	
			} else {
				menuObj.menuContainer.children('[level]').each( function() {
					menuObj.showGroup(this);
				});
			}
			return false; 
		});
	},
	
	/**
	* Add opened menu group id to cookie
	* @param {string} menuGroupId
	*/
	addToCookie: function( menuGroupId ) {
		var key = 'openMenuGroupIds_' + this.menuName,
			openMenuGroupIds = get_cookie(key);
		
		if ( openMenuGroupIds && openMenuGroupIds.indexOf(menuGroupId) === -1 ) {
			openMenuGroupIds += ";" + menuGroupId;
		}
		
		set_cookie( key, openMenuGroupIds || menuGroupId, '', this.cookieRoot );
	},
	
	/**
	* Remove opened menu group id from cookie
	* @param {string} menuGroupId
	*/ 
	removeFromCookie: function( menuGroupId ) {
		var key = 'openMenuGroupIds_' + this.menuName,
			openMenuGroupIds = get_cookie(key);
		
		if (!openMenuGroupIds) {
			return;
		}
		
		openMenuGroupIds = openMenuGroupIds.replace( ";" + menuGroupId, "");
		openMenuGroupIds = openMenuGroupIds.replace(menuGroupId, "");
	
		if (openMenuGroupIds.indexOf(';') === 0) {
			openMenuGroupIds = openMenuGroupIds.substr(1);
		}
		
		set_cookie( key, openMenuGroupIds, '', this.cookieRoot );
	},
	
	/**
	* The Expand/Collapse button's toggler
	* If all menu groups are opened then change img to minus
	* If all menu groups are closed then change img to plus
	*/
	toggleExpandCollapse: function() {
		var menuContainer = this.menuContainer,
			manageBlock = menuContainer.children('.manage'),
			hiddenSubItems = $(".subitem:hidden", menuContainer),
			src;

		this.allExpanded = !hiddenSubItems.length;
		src = this.allExpanded ? Runner.pages.constants.MINUS_GIF : Runner.pages.constants.PLUS_GIF;
		
		$('.expand', manageBlock).toggle( !this.allExpanded );
		$('.hide', manageBlock).toggle( this.allExpanded );
		$('img', manageBlock).attr('src', src); 
		
		this.setCurrentItemStyle();
	},
	
	/**
	* Open the menu's group/groups after the menu is loaded
	*/
	openMenuOnLoad: function() {
		var openMenuGroupIds, groupForOpenArr, i;
		
		this.cookieRoot = Runner.getCookieRoot();
		openMenuGroupIds = get_cookie('openMenuGroupIds_' + this.menuName);
		
		if (!openMenuGroupIds) {
			return;
		}
		groupForOpenArr = openMenuGroupIds.split(";");
		
		for (i = 0; i < groupForOpenArr.length; i++) {
			if ( groupForOpenArr[i].indexOf('item') !== -1 ) {
				$('#' + groupForOpenArr[i] + ' .groupImg', this.menuContainer).click();
			}
		};	
	}
});

/**
 * @class Runner.controls.constants
 */
Runner.controls.constants = {
	/**
	 * View format constants
	 * @type String
	 */
	FORMAT_NONE: '',	
	FORMAT_DATE_SHORT: "Short Date",	
	FORMAT_DATE_LONG: "Long Date",
	FORMAT_DATE_TIME: "Datetime",
	FORMAT_TIME: "Time",
	FORMAT_CURRENCY: "Currency",
	FORMAT_PERCENT: "Percent",
	FORMAT_HYPERLINK: "Hyperlink",
	FORMAT_EMAILHYPERLINK: "Email Hyperlink",
	FORMAT_FILE_IMAGE: "File-based Image",
	FORMAT_DATABASE_IMAGE: "Database Image",
	FORMAT_DATABASE_FILE: "Database File",
	FORMAT_FILE: "Document Download",
	FORMAT_LOOKUP_WIZARD: "Lookup wizard",
	FORMAT_PHONE_NUMBER: "Phone Number",
	FORMAT_NUMBER: "Number",
	FORMAT_HTML: "HTML",
	FORMAT_CHECKBOX: "Checkbox",
	FORMAT_MAP: "Map",
	FORMAT_CUSTOM: "Custom",
	/**
	 * edit format constants
	 * @type String
	 */
	EDIT_FORMAT_NONE: "",
	EDIT_FORMAT_TEXT_FIELD: "Text field",
	EDIT_FORMAT_TEXT_AREA: "Text area",
	
	EDIT_FORMAT_RTE: "RTE",
	EDIT_FORMAT_RTEINNOVA: "RTEINNOVA",
	EDIT_FORMAT_RTECK: "RTECK",
	
	EDIT_FORMAT_PASSWORD: "Password",
	EDIT_FORMAT_DATE: "Date",
	//Date control types
	EDIT_DATE_SIMPLE: 0,
	EDIT_DATE_SIMPLE_INLINE: 2,
	EDIT_DATE_SIMPLE_DP: 11,
	EDIT_DATE_DD: 12,
	EDIT_DATE_DD_INLINE: 5,
	EDIT_DATE_DD_DP: 13,
	//eo Date control types
	EDIT_FORMAT_TIME: "Time",
	EDIT_FORMAT_RADIO: "Radio button",
	EDIT_FORMAT_CHECKBOX: "Checkbox",
	EDIT_FORMAT_DATABASE_IMAGE: "Database image",
	EDIT_FORMAT_DATABASE_FILE: "Database file",
	EDIT_FORMAT_FILE: "Document upload",
	EDIT_FORMAT_LOOKUP_WIZARD: "Lookup wizard",
	EDIT_FORMAT_HIDDEN: "Hidden field",
	EDIT_FORMAT_READONLY: "Readonly",
	
	/**
	 * Lookup wizard constants
	 */
	
	LCT_DROPDOWN: 0,
	LCT_AJAX: 1,
	LCT_LIST: 2,
	LCT_CBLIST: 3,
	LCT_RADIO: 4,
	
	LT_LISTOFVALUES: 0,
	LT_LOOKUPTABLE: 1,
	LT_CUSTOM: 2,
	
	
	MODE_ADD: 0,
	MODE_EDIT: 1,
	MODE_SEARCH: 2,
	MODE_LIST: 3,
	MODE_PRINT: 4,
	MODE_VIEW: 5,
	MODE_INLINE_ADD: 6,
	MODE_INLINE_EDIT: 7,
	MODE_EXPORT: 8,
	
	/**
	* Filter format constants
	*/
	FILTER_FORMAT_VALUES_LIST: "Values list",
	FILTER_FORMAT_BOOLEAN: "Options list",
	FILTER_FORMAT_INTERVAL_LIST: "Interval list",
	FILTER_FORMAT_INTERVAL_SLIDER: "Interval slider",
	
	FILTER_MULTISELECT_NONE: 0,
	FILTER_MULTISELECT_ON_DEMAND: 1,
	FILTER_MULTISELECT_ALWAYS: 2,
	
	FILTER_KNOBS_BOTH: 0,
	FILTER_KNOBS_MIN_ONLY: 1,
	FILTER_KNOBS_MAX_ONLY: 2,
	
	FILTER_STEP_SEC: 0,
	FILTER_STEP_MIN: 1,
	FILTER_STEP_HOUR: 2,
	FILTER_STEP_DAY: 3,
	FILTER_STEP_MONTH: 4,
	FILTER_STEP_YEAR: 5
};
/**
 * @class Runner.Event
 * Abstract base class that provides event functionality. 
 * Example of usage:
	Employee = function(name) {
		this.name = name;
		this.addEvent(["blur", "change"]);
		this.init();
	}
	Runner.extend(Employee, Runner.Event);
===================================================================
Predefined, javascript events:
	abort	  - Loading of an image is interrupted
	blur	  - An element loses focus
	change	  - The user changes the content of a field
	click	  - Mouse clicks an object
	dblclick  - Mouse double-clicks an object
	error	  - An error occurs when loading a document or an image
	focus	  - An element gets focus
	keydown   - A keyboard key is pressed
	keypress  - A keyboard key is pressed or held down
	keyup	  - A keyboard key is released
	load	  - A page or an image is finished loading
	mousedown - A mouse button is pressed
	mousemove - The mouse is moved
	mouseout  - The mouse is moved off an element
	mouseover - The mouse is moved over an element
	mouseup	  - A mouse button is released
	reset	  - The reset button is clicked
	resize	  - A window or frame is resized
	select	  - Text is selected
	submit	  - The submit button is clicked
	unload	  - The user exits the page
*/

Runner.Event = Runner.extend( Runner.emptyFn, {
	/**
	 * Array of predefined events
	 * @type {array}
	 */
	events: null,
	/**
	 * Array of predefined listeners
	 * @type {array}
	 */
	listeners: null,
	/**
	 * Array of elements, on which listeners should be added
	 * @type {array}
	 */
	elemsForEvent: null,
	/**
	 * Array of events that are suspended for this control
	 * @type {array}
	 */
	suspendedEvents: null,
	
	/**
	 * The flag indicating that events are initialized	
	 * @type {Boolean}
	 */
	eventsAreInitialized: false,
	
	/**
	 * @constructor
	 */
	constructor: function() {
		// recreate objects, to prevent memory mix
		this.listeners = [];
		this.elemsForEvent = [];
		this.suspendedEvents = [];
	},
	
	/**
	 * Init method, should be called by class contructor, for event initialization
	 * @method
	 */	
	init: function() {
		if ( !this.events.length ) {
			return;
		}
		
		var i, eventName;
		
		for (i = 0; i < this.events.length; i++) {
			eventName = this.events[i];
			// pass event name and event standard handler
			if ( typeof this[ eventName ] == "function" ) {
				this.on( eventName, this[ eventName ] );
			} else if ( typeof this[ eventName ] == "object" ) {
				this.on( eventName, this[ eventName ].fn, this[ eventName ].options, this[ eventName ].scope );
			}
		}
		
		this.eventsAreInitialized = true;
	},
	
	/**
	 * @param {array} eventArr
	 */
	suspendEvent: function( eventArr ) {
		for (var i = 0; i < eventArr.length; i++) {
			if ( $.inArray( eventArr[i], this.suspendedEvents ) === -1 ) {
				this.suspendedEvents.push( eventArr[i] );
			}
		}
	},
	
	/**
	 * @param {array} eventArr 
	 */
	resumeEvent: function( eventArr ) {
		var eventInd, i;
		
		for (i = 0; i < eventArr.length; i++) {
			eventInd = $.inArray( eventArr[i], this.suspendedEvents );
			
			if ( eventInd !== -1 ) {
				this.suspendedEvents.splice(eventInd, 1);
			}
		}
	},
	
	/**
	 * Create a delayed event handler	
	 * @param {function} handler
	 * @param {number} timeout
	 * @return {function}	 
	 */
	createDelayed: function( handler, timeout ) {
		return function() {
			var obj = this, 
				args = arguments;
				
			setTimeout( function() {
				handler.apply(obj, args);
			}, timeout || 10 );
		};
	},

	/**
	 * Create an event handler that won't be triggered, 
	 * as long as it continues to be invoked 
	 * during a given number of milliseconds (buffer). 	
	 * @param {function} handler
	 * @param {number} buffer
	 * @return {function}	 
	 */	
	createBuffered: function( handler, buffer ) {
		var task = new Runner.util.DelayedTask( handler );
		return function() {
			task.delay( buffer, handler, null, Array.prototype.slice.call( arguments ) );
		};
	},
	
	/**
	 * Create an event handler that will be executed at most once	
	 * @param {function} handler
	 * @param {srting} eventName
	 * @return {function}
	 */		
	createSingle: function( handler, eventName ) {
		var eventObj = this,
			singleHandler = function() {
				handler.apply( eventObj, arguments );
				eventObj.clearEventHandler( eventName, singleHandler );
			};
			
		return singleHandler
	},
	
	/**
	 * Bind an event handler to the events elements using jQuery bind method
	 * @param {string} eventName
	 * @param {function} callHandler
	 */ 	
	bindHn: function( eventName, callHandler ) {
		if ( !callHandler || !eventName ) {
			return;
		}

		// adding listeners for all elems for event
		for (var i = 0; i < this.elemsForEvent.length; i++) {
			$( this.elemsForEvent[i] ).bind(eventName, {hn: callHandler, obj: this}, callHandler);
		}
	},
	
	/**
	 * Unbind DOM events from events elements using jQuery unbind method
	 * @param {string} eventName
	 * @param {function} callHandler
	 */ 
	unbindHn: function( eventName, callHandler ) {
		if ( !callHandler || !eventName ) {
			return;
		}

		// remove listeners for all elems for event	
		for (var i = 0; i < this.elemsForEvent.length; i++) {
			$( this.elemsForEvent[i] ).unbind(eventName, callHandler);
		}
	},
	
	/**
	 * Add events to the object. Events names should be similar to predefined
	 * javascript DOM element event names.
	 * @method
	 * @param {string} eventName
	 * @param {functions} fn
	 * @param {object} options
	 * 		@param {array} options.args Optional. Array of arguments, that should be passed to event handler
	 * 		@param {bool} options.single Optional. Pass true to fire event only once
	 *		@param {int} options.timeout Optional. Pass number of miliseconds to create delayed handler
	 * 		@param {int} options.buffer Optional. Pass number of miliseconds to buffer. Usefull for keypress events and validations. 
	 * @param {link} scope
	 * @return {boolean}
	 */
	on: function( eventName, fn, options, scope ) {
		if ( !this.elemsForEvent.length || !fn ) {
			return false;
		}

		eventName = eventName.toLowerCase();
		this.addEvent( [eventName] );
		
		// prepare event name, for DOM scpecifications
		if ( eventName.indexOf("on") === 0 ) {
			eventName = eventName.slice(2);
		}

		var callHandler,
			scope = scope || this, 
			objScope = this, 
			options = options || {},
			args = options.args || [], 
			single = options.single || false, 
			timeout = options.timeout || 0, 
			buffer = options.buffer || 0;
			
		callHandler = function(e) {
			// prevent call if event suspended 
			if ( $.inArray( eventName, objScope.suspendedEvents ) !== -1 ) {
				return;
			}
			var newArgs = Array.prototype.slice.call( arguments );
			//the order of arguments: 	event object, arguments passed to event handler, arguments passed to fire event
			fn.apply( scope, newArgs.slice(0, 1).concat(args).concat( newArgs.slice(1) ) );
		}
		
		// creating delayed handler, usefull for validations etc.
		if ( timeout ) {
			callHandler = this.createDelayed( callHandler, timeout );
		}
		// function will clear itself after called, usefull when function need to be called once
		if ( single ) {
			callHandler = this.createSingle( callHandler, eventName )
		}
		if ( buffer ) {
			callHandler = this.createBuffered( callHandler, buffer );
		}
		
		this.listeners.push({
			name: eventName,
			handler: fn,
			callHandler: callHandler,
			options: options,
			scope: scope,
			index: this.listeners.length
		});
		
		this.bindHn( eventName, callHandler );
		return true;
	},
	
	/**
	 * Add events to object, make list of predefined events, before call init method
	 * @method
	 * @param {array} eventNameArr
	 */
	addEvent: function( eventNameArr ) {
		this.events = this.events || [];

		this.addEvent = function( eventNameArr ) {
			for (var i = 0; i < eventNameArr.length; i++) {
				// check if this event already added
				if ( $.inArray( eventNameArr[i], this.events ) === -1 ) {
					this.events.push( eventNameArr[i] );
				}
			}
		}
		this.addEvent( eventNameArr );
	},
	
	/**
	 * Kill event handling, sets empty fn as handler
	 * @method
	 * @param {string} eventName
	 */
	killEvent: function( eventName ) {
		var eventInd = $.inArray( eventName, this.events )
		if ( eventInd === -1 ) {
			return;
		}
		
		this.clearEvent( eventName );
		// remove native event handler
		this.unbindHn( eventName, this[ eventName ] );
		// delete event handler from object
		delete this[ eventName ];
		//kill event
		this.events.splice(eventInd, 1);
	},
	
	/**
	 * Clear events' handlers
	 */
	purgeListeners: function() {
		if (!this.events) {
			return;
		}
		//get a shallow copy of the events array
		var copyEvents = this.events.slice(0),
			i;
		
		for (i = 0; i < copyEvents.length; i++) {
			this.killEvent( copyEvents[i] );	
		}
	},
	
	/**
	 * Clear custom event handlers
	 * @param {string} eventName
	 */
	clearEvent: function( eventName ) {		
		for (var i = this.listeners.length; i--; ) {
			if ( this.listeners[i].name == eventName ) {
				this.unbindHn( eventName, this.listeners[i].callHandler );
				this.listeners.splice( i, 1 );
			}
		}	
	},
	
	/**
	 * Remove a particular custom event handler
	 * @param {string} eventName
	 * @param {function} callHandler
	 */
	clearEventHandler: function( eventName, callHandler ) {		
		for (var i = this.listeners.length; i--; ) {
			if ( this.listeners[i].name == eventName && this.listeners[i].callHandler === callHandler ) {
				this.unbindHn( eventName, callHandler );
				this.listeners.splice( i, 1 );
			}
		}	
	},	
	
	stopEvent: function(e) {
		this.stopPropagation(e);
		this.preventDefault(e);
	},
	
	stopPropagation: function(e) {
		e = this.getEvent(e);
		if (e && e.stopPropagation) {
			e.stopPropagation();
		} else if (e) {
			e.cancelBubble = true;
		}
	},
	
	preventDefault: function(e) {
		e = this.getEvent(e);
		if (e && e.preventDefault) {
			e.preventDefault();
		} else if (e) {
			e.returnValue = false;
		}
	},
	
	getEvent: function(e) {
		return e || window.event;
	},
	
	getTarget: function(e) {
		if (e) {
			return e.target || e.srcElement;
		}
	},
	
	/**
	 * Fire handlers for a particular event with parameters passed 
	 * (except of the first one, the event's name).
	 * @param {String} eventName
	 */
	fireEvent: function( eventName ) {
		var listeners = this.getListeners( eventName );
		for (var i = 0; i < listeners.length; i++) {
			// null - instead of event object
			listeners[i].callHandler.apply(this, [ null ].concat( Array.prototype.slice.call(arguments, 1) ));
		}
	},
	
	/**
	 * Get the listeners for a particular event
	 * @param {string} eventName
	 * @return {array}
	 */
	getListeners: function( eventName ) {
		var listeneresArr = [];
		for (var i = 0; i < this.listeners.length; i++) {
			if ( this.listeners[i].name == eventName ) {	
				listeneresArr.push( this.listeners[i] );
			}
		}
		return listeneresArr;
	}
});

/**
 * Global validtion object checking controls' values
 * @type {object}
 */
Runner.validation = {	
	/**
	 * The object containing validators' statuses 
	 */
	validatorConsts: {
		predefined: 1,
		user: 2,
		notFound: 3
	},
	
	/**
	 * Array of names of user validation functions
	 */
	userValidators: [],
	
	/**
	 * The predefined validators' names 
	 */
	predefinedValidatorsArr: [
		'isrequired', 
		'isnumeric', 
		'ispassword', 
		'isemail', 
		'ismoney', 
		'iszipcode', 
		'isphonenumber', 
		'isstate', 
		'isssn', 
		'iscc', 
		'istime', 
		'regexp', 
		'denyduplicated', 
		'checkstrongpassword'
	],
	
	/**
	 * Array of names of states for validate
	 */
	arrStates: ['AL','AK','AS','AZ','AR','CA','CO','CT','DE','DC','FM','FL','GA','GU','HI','ID','IL','IN','IA','KS','KY','LA','ME','MH','MD','MA','MI','MN','MS','MO','MT','NE','NV',
				'NH','NJ','NM','NY','NC','ND','MP','OH','OK','OR','PW','PA','PR','RI','SC','SD','TN','TX','UT', 'VT','VI','VA','WA','WV','WI','WY'],
	
	/**
	 * The object contained the current control object beeing used for the validation
	 */
	control: {},
	
	/**
	 * Main function that provides object validation
	 * @param {array} validArr
	 * @param {object} control
	 * @return {object}
	 */
	validate: function( validArr, control ) {
		var validationRes, validatorName, validatorStatus, i,
			result = this.getTrueValidationResult( validArr );
		
		this.control = control;
		
		//traverse all the field's validators
		for (i = 0; i < validArr.length; i++)  {	
			// to prevent check for undefined values, that mistically appears in IE!
			if ( !validArr[i] ) {
				continue;
			}
			validatorName = validArr[i];
			// get status of validator
			validatorStatus = this.getValidatorStatus( validatorName ); 
			
			switch ( validatorStatus ) {
				case this.validatorConsts.predefined:
					// validation method is one of the predefined validators
					validationRes = this[ validatorName ]( control.getStringValue() );
				break;
				
				case this.validatorConsts.user:
					// validation method is set by user
					validatorName = control.validationArr[i];
					validationRes = window[ validatorName ]( control.getStringValue() );
				break;
				
				default:
					// the validator is not found
					validationRes = true;
			};
			// update validations result object
			this.updateResultObject(validationRes, validatorName, result);
		}

		return result;
	},
	
	/**
	 * Get the initial result validation object structure
	 * that is similar to a validation result object for 
	 * an object that passed validation
	 * @param {array} validArr
	 * @return {object}
	 */
	getTrueValidationResult: function( validArr ) {
		return {	
			result: true, 
			messagesData: {},
			delayedValidators: this.getDelayedValidators( validArr )
		};
	},
	
	/**
	 * Construct the delayed validators list for the control
	 * @param {Array} validArr
	 * @return {Array}
	 */
	getDelayedValidators: function( validArr ) {
		if ( $.inArray( "DenyDuplicated", validArr ) === -1 ) {
			return [];
		}
		return [ "DenyDuplicated" ];
	},
	
	/**
	 * Check validator function status.
	 * @param {string} validatorName
	 * @return {string} property from validatorConsts object
	 */
	getValidatorStatus: function( validatorName ) {
		var userValidatorType;
		
		if ( $.inArray( validatorName.toString().toLowerCase(), this.predefinedValidatorsArr ) !== -1 ) {
			return this.validatorConsts.predefined;
		}
		
		userValidatorType = typeof window[ validatorName ];
		if ( userValidatorType === 'function' || userValidatorType === 'object' && Runner.isIE ) {
			return this.validatorConsts.user;
		}
		
		return this.validatorConsts.notFound;
	},
	
	/**
	 * Extract the validator's error message form the messageData prop 
	 * of the validation result object
	 * @param {string} validatorName
	 * @param {object} messagesData
	 * @return {string}
	 */
	extractValidationMessage: function( validatorName, messagesData ) {
		if ( !messagesData[ validatorName ] ) {
			return ""
		}
		return messagesData[ validatorName ].join("</br>");
	},
	
	/**
	 * Get an updated result object
	 * @param {mixed} res result from any validation function true, or error text
	 * @param {object} validatorName
	 * @param {object} resultObj final result object
	 */
	updateResultObject: function( res, validatorName, resultObj ) {
		if (res === true) {
			return;
		}
		var messages = [];

		resultObj.result = false;
		// if res is array of messages, add each message to array
		if ( Runner.isArray( res ) ) {
			for (var i = 0; i < res.length; i++) {
				messages.push( res[i] );
			}
		} else {
			messages.push( res );
		}
		
		resultObj.messagesData[ validatorName ] = messages;
	},
	
	/**
	 * The handler loading custom validation functions from files.
	 * @param {object} ctrl
	 */
	registerCustomValidation: function( ctrl ) {
		var validatorStatus, i;
		
		// loop for all validations
		for (i = 0; i < ctrl.validationArr.length; i++) {
			// to prevent check undefined vals
			if ( !ctrl.validationArr[i] ) {
				continue;
			}
			
			// get validator status
			validatorStatus = this.getValidatorStatus( ctrl.validationArr[i] );
			if ( validatorStatus === this.validatorConsts.predefined ) {
				//current validator is predefined
				continue;
			}

			// add if not
			if ( $.inArray( ctrl.validationArr[i], this.userValidators ) === -1 ) {
				// load js from file
				Runner.util.ScriptLoader.addJS( [ settings.global["webRootPath"] + 'include/validate/' + ctrl.validationArr[i] + '.js'] );
				Runner.util.ScriptLoader.load();
				
				this.userValidators.push( ctrl.validationArr[i] );
			}
		}
	},
	
	"IsRequired": function() {
		if ( this.control.isEmpty() ) {
			return Runner.lang.constants.TEXT_INLINE_FIELD_REQUIRED;
		} 	
		return true;
	},
	
	"IsNumeric": function(sVal)	{
		sVal = sVal.replace(/,/g,"");
		if ( isNaN(sVal) ) {
			return Runner.lang.constants.TEXT_INLINE_FIELD_NUMBER; 
		}
		return true;
	},
	
	"IsPassword": function(sVal) {
		var regexp1 = /^password$/,
			regexp2 = /.{4,}/;
			
		if ( sVal.match(regexp1) ) {
			return Runner.lang.constants.TEXT_INLINE_FIELD_PASSWORD1;
		}
		if ( !sVal.match(regexp2) ) { 
			return Runner.lang.constants.TEXT_INLINE_FIELD_PASSWORD2;		
		}
		return true;
	},
	
	"IsEmail": function(sVal) {
		var regexp = /^[A-z0-9_-]+([.][A-z0-9_-]+)*[@][A-z0-9_-]+([.][A-z0-9_-]+)*[.][A-z]{2,4}$/;
		if ( sVal.match(/.+/) && !sVal.match(regexp) ) { 
			return Runner.lang.constants.TEXT_INLINE_FIELD_EMAIL;
		}
		return true;
	}, 
	
	"IsMoney": function(sVal) {
		var regexp = /^(\d*)[.,]?(\d*)$/;
		if ( sVal.match(/.+/) && !sVal.match(regexp) ) { 
			return Runner.lang.constants.TEXT_INLINE_FIELD_CURRENCY;
		}
		return true;
	},  
	
	"IsZipCode": function(sVal) {
		var regexp = /^\d{5}([\-]\d{4})?$/;
		if ( sVal.match(/.+/) && !sVal.match(regexp) ) {
			return Runner.lang.constants.TEXT_INLINE_FIELD_ZIPCODE;
		}
		return true;
	},
	
	"IsPhoneNumber": function(sVal)	{
		var regexp = /^\(\d{3}\)\s?\d{3}\-\d{4}$/,
			stripped = sVal.replace(/[\(\)\.\-\ ]/g, '');
		
		if ( sVal.match(/.+/) && ( isNaN( parseInt(stripped) ) || stripped.length != 10 ) ) { 
			return Runner.lang.constants.TEXT_INLINE_FIELD_PHONE;
		}
		return true;
	},
	
	"IsState": function(sVal) {
		if ( sVal.match(/.+/) && $.inArray( sVal, this.arrStates ) === -1 ) { 
			return Runner.lang.constants.TEXT_INLINE_FIELD_STATE;
		}
		return true;
	}, 
	
	"IsSSN": function(sVal)	{
		// 123-45-6789 or 123 45 6789
		var regexp = /^\d{3}(-|\s)\d{2}(-|\s)\d{4}$/;
		if ( sVal.match(/.+/) && !sVal.match(regexp) ) { 
			return Runner.lang.constants.TEXT_INLINE_FIELD_SSN;
		}
		return true;
	},
	
	"IsCC": function(sVal) {
		//Visa, Master Card, American Express
		var regexp = /^((4\d{3})|(5[1-5]\d{2}))(-?|\040?)(\d{4}(-?|\040?)){3}|^(3[4,7]\d{2})(-?|\040?)\d{6}(-?|\040?)\d{5}/;
		if ( sVal.match(/.+/) && !sVal.match(regexp) ) {
			return Runner.lang.constants.TEXT_INLINE_FIELD_CC;
		}
		return true;
	},
	
	"IsTime": function(sVal) {
		if ( sVal === "" ) {
			return true;
		}
		var common24Rgxp = /^(?:[0-1]?[0-9]|2[0-3])(?::[0-5][0-9](?::[0-5][0-9])?)?$/,
			common12Rgxp = /^(?:1[0-2]|0?[1-9])(?::[0-5][0-9](?::[0-5][0-9])?)?[\s]{0,2}(?:am|pm)?$/i,
			localTimeRgxp;
			
		sVal = sVal.trim();
		
		//check if the contol's value matches the 24 hours or 12 hours common format
		if ( common24Rgxp.test(sVal) || common12Rgxp.test(sVal) ) {
			return true;
		}
		
		localTimeRgxp = new RegExp( this.control.regExp, "i" );
		//check if the contol's value matches the local time format
		if ( localTimeRgxp.test(sVal) ) {
			return true;
		}
		
		return Runner.lang.constants.TEXT_INLINE_FIELD_TIME;
	},
	
	"GetCustomLabel": function(name) {
		return Runner.lang.customlabels[Runner.lang.customlabels.prefix + name];
	},
	
	"RegExp": function(sVal) {
		if (sVal === "") {
			return true;
		}

		var re = new RegExp( this.control.regExp ),
			regExpMessageData = this.control.customValidationFailedMessages[ "RegExp" ];
			
		// test against regExp
		if ( !re.test(sVal) || re.exec(sVal)[0] != sVal ) {
			// return error text	
			if ( regExpMessageData.messageType === 'Text' ) {
				return regExpMessageData.message;
			}
			return this.GetCustomLabel( regExpMessageData.message );
		}
		
		return true;
	},	
	
	"DenyDuplicated": function( sVal ) {
		var pageObj = this,
			control = this.control,
			defaultValue = control.getDefaultControlValue(),
			strValue, messageData, ajaxParams;
		
		if ( control.pageType === Runner.pages.constants.PAGE_EDIT && sVal === defaultValue ) {
			return true;
		}
		
		// get the control's string value
		strValue = control.getStringValue();
		// get the custom validation error message's data
		messageData = control.customValidationFailedMessages[ "DenyDuplicated" ];
		//It helps the validation process be invoked by submit to run this validator
		control.isInvalid = false;
		
		ajaxParams = {
			tableName: control.shortTableName,
			pageType: control.pageType,
			fieldName: control.fieldName,
			fieldControlType: control.ctrlType,
			value: sVal
		};
		
		Runner.runnerAJAX(Runner.getPageUrl("checkduplicates"), ajaxParams, function( respObj ) {	
			var message;
			
			if ( !respObj.success ) {
				return;
			}
			
			if ( !respObj.hasDuplicates ) {
				if ( !control.isInvalid ) {
					control.clearInvalid();	
				}
				return;
			}		
					
			message = messageData.messageType === 'Text' ? messageData.message : pageObj.GetCustomLabel( messageData.message );
			message = message.replace( '%value%', strValue.slice(0, 100) );
			
			control.markInvalidWidthCusttomMessages( "DenyDuplicated", [ message ] );
			
			if ( control.isFocusAllowed() && !control.isSetFocus && Runner.pages.RunnerPage.prototype.isFirstInvalidControl( control ) ) {
				control.setFocus();
			}
		});	
	
		return true;
	},
	
	"CheckStrongPassword": function(sVal) {
		this.control.clearInvalid();
		
		if ( !sVal.length ) {
			return true;
		}
		
		var messages = [],
			pwdLen = Runner.pages.PageSettings.getGlobalData("pwdLen"),
			pwdUnique = Runner.pages.PageSettings.getGlobalData("pwdUnique"),
			pwdDigits = Runner.pages.PageSettings.getGlobalData("pwdDigits"),
			pwdUpperLower = Runner.pages.PageSettings.getGlobalData("pwdUpperLower");
		
		if ( pwdLen && sVal.length < pwdLen ) {
			messages.push( Runner.lang.constants.SEC_PWD_LEN.replace('%%', pwdLen) );
		}
		
		if ( pwdUnique ) {
			var cUnique = {},
				countUnique = 0;
				
			for (var i = 0; i < sVal.length; i++) {
				cUnique[sVal[i]] = 1;
			}	
			for (var c in cUnique) {
				countUnique++;
			}
			if (countUnique < pwdUnique) {
				messages.push( Runner.lang.constants.SEC_PWD_UNIQUE.replace('%%', pwdUnique) );
			}
		}
		
		if ( pwdDigits ) {
			var regExpDigit =  /(\d)|([^A-Za-z0-9])/g,
				result = sVal.match(regExpDigit);
			
			if (!result || result.length < pwdDigits) {
				messages.push( Runner.lang.constants.SEC_PWD_DIGIT.replace('%%', pwdDigits) );
			}
		}
		
		if ( pwdUpperLower ) {
			var regExpLower = /([a-z])/g,
				regExpUpper = /([A-Z])/g;
			
			if (( !sVal.match(regExpLower) || !sVal.match(regExpUpper) ) && pwdUpperLower) {
				messages.push( Runner.lang.constants.SEC_PWD_CASE );
			}
		}
		
		if ( messages.length ) {
			return messages;
		}	
		return true;
	}
}
/**
 * Row control manager. Alows to add, delete and manage controls
 * Collection of control for the specific row
 * @class Runner.controls.RowManager
 */
Runner.controls.RowManager = Runner.extend(Runner.emptyFn, {
	/**
	 * Fields control collection 
	 * @param {object} fields
	 */
	fields: {},
	/**
	 * Id of row
	 * @type {int}
	 */
	rowId: -1,	
	/**
	 * Count of registred fields
	 * @param {int} fieldsCount
	 */
	fieldsCount: 0,
	/**
	 * Array of names of registered fields controls
	 * @type {array} control
	 */
	fieldNames: [],
	/**
	 * @constructor
	 * @param {int} rowId
	 */
	constructor: function(rowId) {
		Runner.controls.RowManager.superclass.constructor.call(this, rowId);	
		this.fields = {};
		this.fieldNames = [];
		this.rowId = rowId;
	},
	
	/**
	 * Control to register
	 * @param {link} control
	 */
	register: function(control) {	
		var controlName = control.fieldName;
		// if need to create new field
		if (!this.fields[controlName]) {			
			this.fields[controlName] = [];			
			this.fieldNames.push(controlName);
			this.fieldsCount++;			
		}
		// add control
		this.fields[controlName][control.ctrlInd] = control;
		return true;		
	},
	/**
	 * Return control by following param
	 * @param {string} fName Pass false to get all controls of the row
	 * @param {int} controlIndex Pass false or null to get first control of the field
	 */
	getAt: function(fName, controlIndex) {		
		// need to get all controls
		if (!fName) {
			// array of row controls
			var rowControlsArr = [],
				i, j, fControl;
			// collect all controls from rowManager
			for (i = 0; i < this.fieldNames.length; i++) {	
				// get all controls from field. Field may contain more then one
				for (j = 0; j < this.fields[ this.fieldNames[i] ].length; j++) {
					// field control
					fControl = this.getAt(this.fieldNames[i], j);
					// add to array
					rowControlsArr.push(fControl);
				}					
			}
			return rowControlsArr;
		}
		// if we need specific control
		if (!this.fields[fName]) {
			return false;
		}		
		return this.fields[fName][controlIndex];
	},
	/**
	 * Control which need to unregister
	 * @param {string} fName
	 */
	unregister: function(fName, controlIndex) {
		var i; 
			
		// unreg all rows
		if (fName == null) {
			for (i = 0; i < this.fieldsCount; i++) {
				this.unregister(this.fieldNames[i], null);
				i--;
			}
			return true;
		} 
		// no such row
		if ( !this.fields[fName] ) {
			return false;
		} 
		// unreg whole field
		if (controlIndex == null) {
			for (i = 0; i < this.fields[fName].length; i++) {
				this.unregister(fName, i);
			};			
			// delete fieldName from names arr
			for (i = 0; i < this.fieldsCount; i++) {
				if (this.fieldNames[i] == fName) {
					this.fieldNames.splice(i, 1);						
					this.fieldsCount--;
				}
			}			
			delete this.fields[fName];
			return true;
		
		} 
		// unreg by params
		// call object destructor
		if (typeof this.fields[fName][controlIndex].destructor === "function") {
			this.fields[fName][controlIndex].destructor();
		} 
		// remove from arr
		//use delete intead of splice to prevent controlIndex left shifting
		delete this.fields[fName][controlIndex];

		if ( !this.hasControls(fName) ) {
			this.fields[fName] = [];
		}
		
		return true;
	},
	
	/**
	* Check if there are any still registered controls for the field
	* @param {String} fName
	* @return {Boolean}
	*/
	hasControls: function(fName) {
		for (var i = 0; i < this.fields[fName].length; i++) {
			if ( this.fields[fName][i] !== undefined ) {
				return true;
			}
		}
		return false;	
	},
	
	getMaxFieldIndex: function(fName) {
		// if no field with such name
		if (!this.fields[fName]) {
			return false;
		}
		
		return this.fields[fName].length;
	}
});
/** 
 * Table controls manager. Alows to add, delete and manage controls
 * Collection of control for the specific table.
 * @class Runner.controls.TableManager
 */
Runner.controls.TableManager = Runner.extend(Runner.emptyFn, {
	/**
	 * Row managers collection
	 * @param {object} rows
	 */
	rows: {},
	/**
	 * Name of table
	 * @type {String}
	 */
	tName: "",
	/**
	 * Count of registred rows
	 * @param {int} rowsCount
	 */
	rowsCount: 0,
	/**
	 * Ids of registered rows
	 * @type {array} control
	 */
	rowIds: [],
	/**
	 * Contructor
	 * @param {string} tName
	 */
	constructor: function(tName) {
		this.tName = tName;
		this.rows = {};
		this.rowIds = [];
	},
	
	/**
	 * Control to register
	 * @param {#link} control
	 */
	register: function(control) {		
		var controlId = control.id;
		// if need to create new row
		if (!this.rows[controlId]) {
			this.rows[controlId] = new Runner.controls.RowManager(controlId);
			this.rowIds.push(controlId);
			this.rowsCount++;
		}
		// return register result
		return this.rows[controlId].register(control);
	},
	/**
	 * Return control by following params
	 * @param {string} rowId Pass false or null to get all controls of the table
	 * @param {string} fName Pass false or null to get all controls of the row
	 * @param {int} controlIndex Pass false or null to get first control of the field
	 */
	getAt: function(rowId, fName, controlIndex) {		
		// if no rowId, then get all controls from table
		if (rowId == null) {
			// array of controls for return
			var tableControlsArr = [],
				i, j, rowControls;
			// collect all controls from rows managers
			for (i = 0; i < this.rowIds.length; i++) {
				//get all controls of the row
				rowControls = this.rows[ this.rowIds[i] ].getAt();
				// collect controls from row controls arr 
				for (j = 0; j < rowControls.length; j++) {
					tableControlsArr.push( rowControls[j] );
				}	
			}
			return tableControlsArr;
		}
		// if row id defined, but no rows with such id
		if (!this.rows[rowId]) {
			return false;
		}
		// return result
		return this.rows[rowId].getAt(fName, controlIndex);	
	},
	/**
	 * Control which need to unregister
	 * @param {string} rowId
	 * @param {string} fName Pass false or null to clear all controls of the row
	 * @param {int} controlIndex Pass false or null to clear all control of the field
	 * @return {bool} true if success, otherwise false
	 */
	unregister: function(rowId, fName, controlIndex) {		
		var i, rowUnregStat;
		
		// unreg all rows
		if (rowId == null) {
			for (i = 0; i < this.rowsCount; i++) { 
				this.rows[this.rowIds[i]].unregister(null, null);
			}
			return true;
		}
		// no such row
		if (!this.rows[rowId]) {
			return false;
		}
		// unreg by params
		rowUnregStat = this.rows[rowId].unregister(fName, controlIndex);
		if (rowUnregStat && fName==null) {
			// delete row id from ids arr
			for (i = 0; i < this.rowsCount; i++) {
				if (this.rowIds[i]==rowId) {
					this.rowIds.splice(i,1);						
					this.rowsCount--;
				}
			}
			// delete table object
			delete this.rows[rowId];
			return true;
		}
		
		return rowUnregStat;
	},
	
	getMaxFieldIndex: function(rowId, fName) {
		// if no row with such id
		if (!this.rows[rowId]) {
			return false;
		}
		
		return this.rows[rowId].getMaxFieldIndex(fName);
	}
});
/** 
 * Global control manager. Alows to add, delete and manage controls
 * Collection of controls for the specific table.
 * Should not be created directly, only one instance per page. 
 * Use its instance to get access to any control
 * @singleton
 * @class Runner.controls.ControlManager
 */
Runner.controls.ControlManager = function() {
	/**
	 * Table managers collection
	 * @type {object} private
	 */
	var tables = {};	
	/**
	 * Count of registred tables
	 * @type {int} private
	 */
	var tablesCount = 0;
	/**
	 * Names of registred tables
	 * @type {array} private
	 */
	var tableNames = [];
	
	
	return {
		/**
		 * Control to register
		 * @param {#link} control
		 */
		register: function(control) {
			// return false if not control
			if (!control) {
				return false;
			}
			// get table name
			var controlTable = control.table;		
			// if table not exists, create new one
			if (!tables[controlTable]) {
				tables[controlTable] = new Runner.controls.TableManager(controlTable);	
				tableNames.push(controlTable);
				tablesCount++;		
			}
			// return register result
			return tables[controlTable].register(control);	
			
		},
		/**
		 * Returns control or array of controls by following params
		 * @param {string} tName
		 * @param {string} rowId Pass false or null to get all controls of the table
		 * @param {string} fName Pass false or null to get all controls of the row
		 * @param {int} controlIndex Pass false or null to get first control of the field
		 * @return {object} return control, array of controls or false
		 * @intellisense
		 */
		getAt: function(tName, rowId, fName, controlIndex) {
			
			// if no index passed we return control with 0 index
			controlIndex = controlIndex ? controlIndex : 0;
			
			if (tName === false) {
				for (var i = 0; i < tableNames.length; i++) {
					var ctrl = tables[tableNames[i]].getAt(rowId, fName, controlIndex);
					if (ctrl !== false) {
						return ctrl;
					}
				}
				return false;
			}
			
			// if table not exists
			if (!tables[tName]) {
				return false;
			}	
			
			// else return by params
			return tables[tName].getAt(rowId, fName, controlIndex);
		},
		
		/**
		 * Returns control or array of controls wich relevant to visible fields
		 * @param {string} tName
		 * @param {string} rowId Pass false or null to get all controls of the table
		 * @param {string} fName Pass false or null to get all controls of the row
		 * @param {int} controlIndex Pass false or null to get first control of the field
		 * @return {object} return control, array of controls or false
		 * @intellisense
		 */
		getVisibleAt: function(tName, rowId, fieldName, controlIndex) {
			var ctrls = this.getAt(tName, rowId, fieldName, controlIndex),
				visibleCtrls = [], i;
				
			for (i = 0; i < ctrls.length; i++) {
				if (ctrls[i] && !ctrls[i].hiddenByField)
					visibleCtrls[visibleCtrls.length] = ctrls[i];
			}
			return visibleCtrls;
		},
		
		/**
		 * Unregister control, row or table
		 * @param {string} tName
		 * @param {string} rowId Pass false or null to clear all controls of the table
		 * @param {string} fName Pass false or null to clear all controls of the row
		 * @param {int} controlIndex Pass false or null to clear first control of the field
		 * @return {bool} true if success, otherwise false
		 */
		unregister: function(tName, rowId, fName, controlIndex) {	
			// if no table name passed, return false
			if (!tables[tName]) {
				return false;
			}			
			//controlIndex = controlIndex ? controlIndex : 0;			
			// recursively call unregister through table rows
			var tUnregStat = tables[tName].unregister(rowId, fName, controlIndex);
			// if delete whole table and recursive unreg call success
			if (tUnregStat && rowId==null) {
				// delete table name from name arr
				for (var i = 0; i < tablesCount; i++) {
					if (tableNames[i]==tName) {
						tableNames.splice(i,1);						
						tablesCount--;
					}
				}
				// delete table object
				delete tables[tName];
				return true;
			}
			return tUnregStat;
		},
		
		getMaxFieldIndex: function(tName, rowId, fName) {
			// if no table with such name
			if (!tables[tName]) {
				return false;
			}
			
			return tables[tName].getMaxFieldIndex(rowId, fName);
		},
		
		/**
		 * Resets all controls for specified table
		 * @method
		 * @param {string} tName
		 * @param {string} pageType
		 */
		resetControlsForTable: function(tName, pageType) {
			var cntrls = this.getAt(tName),
				updContext, i;
			
			if ( !cntrls || !cntrls.length ) {
				return;
			}
			
			updContext = {
				enableNextButtons: false,
				resetHappend: true,
				values: {}
			};
			
			pageType = pageType || Runner.pages.constants.PAGE_EDIT;
			
			for (i = 0; i < cntrls.length; i++) {
				if ( cntrls[i].mode === pageType && cntrls[i].editFormat != "Readonly" ) {
					updContext.values[ cntrls[i].fieldName ] = cntrls[i].defaultValue;
				}
			}
			
			for (i = 0; i < cntrls.length; i++) {
				if ( cntrls[i].mode === pageType && cntrls[i].editFormat != "Readonly" ) {
					cntrls[i].reset( updContext );
				}
			}
		},
		
		/**
		 * Resets all controls for specified table
		 * @method
		 * @param {string} tName
		 */
		clearControlsForTable: function(tName) {
			var cntrls = this.getAt(tName),
				i;
				
			if (!cntrls) {
				return;
			}
			
			for (i = 0; i < cntrls.length; i++) {
				cntrls[i].clear();
			}
		}
	};
}();

// register new namespace
Runner.namespace('Runner.form');
/**
 * @class Runner.form.Button
 * @intellisense
 */
Runner.form.Button = Runner.extend( Runner.Event, {
	/**
	 * Control id
	 * @type {string}
	 */
	id: "",
	
	/**
	 * The button's name
	 * @type {string}
	 */
	btnName: "",
	
	/**
	 * The button's message container
	 * @type {jQuery object}
	 */
	messageCont: null,
	
	/**
	 * jQuery object of button element
	 * @type {jQuery object}
	 */
	elem: null,
	
	
	constructor: function( cfg ) {
		// copy properties from cfg to obj
		Runner.apply(this, cfg);
		Runner.form.Button.superclass.constructor.call(this, cfg);	

		// get button
		this.elem = $('#' + this.id);
		// create empty button, for correct script work, if button tag not exists 
		this.elem = this.elem.length ? this.elem : $('<input type="button">'); 

		this.elemsForEvent = [ this.elem.get(0) ];
	},
	
	/**
	 * Initialize the button click functionality
	 * @param {object} args		The object containing click handler's extra arguments. 
	 * It has the following structure: { args: [%extra params list%] }
	 */
	init: function( args ) {
		this.on("click", this.clickHandler, args);
	},
	
	/**
	 * Set the button disabled
	 * @intellisense
	 */
	setDisabled: function() {
		if ( this.elem.is("input") ) {
			this.elem.prop("disabled", true);
			return;
		}
		this.suspendEvent( ['click'] );
	},
	
	/**
	 * Set the button enabled
	 * @intellisense
	 */
	setEnabled: function() {
		if ( this.elem.is("input") ) {
			this.elem.prop("disabled", false);
			return;
		}
		this.resumeEvent( ['click'] );	
	},
	
	/**
	 * Set the message to the button's message container
	 * @param {string} txt
	 * @intellisense
	 */
	setMessage: function( txt ) {
		this.initMessCont();

		this.setMessage = function(txt) {
			this.messageCont.html( txt );
		}
		this.setMessage( txt );
	},
	
	/**
	 * Clear the button's message container
	 * @intellisense
	 */
	removeMessage: function() {
		this.initMessCont();

		this.removeMessage = function() {
			this.messageCont.empty();
		}
		this.removeMessage();
	},
	
	/**
	 * Initialize the button's message container
	 * @intellisense
	 */
	initMessCont: function() {
		if ( this.messageCont ) {
			return;
		}
		
		var messContId = this.id + "_messCont";
		this.messageCont = $('<div id="' + messContId + '"></div>').insertAfter( this.elem );
	},
	
	/**
	 * @param {object} pageObj
	 * @param {boolean} isInlineAdd
	 * @return {object}
	 */
	getRowData: function( pageObj, isInlineAdd ) {
		var i, addedRow,
			$button = this.elem,
			$row = $button.closest('tr[id^="gridRow"]'),
			$cell = $button.closest('td[data-record-id]'),			
			rowData = {
				id: -1, 
				keys: [], 
				fields: {}
			};

		if ( $cell.length ) {
			//	direct method first
			rowData.id = $cell.data('record-id');
		} else {
			//	indirect method, inspect parents and neighbors
			if ( !$row.length ) {
				return rowData;
			}
			
			rowData.id = parseInt( $row.attr('id').substr(7), 10 );
			$row.children().each( function() {
				if (this.recordId) {
					rowData.id = this.recordId;
				}
				if ( $button.closest(this).length ) {
					return false;
				}
			});
		}
		
		if ( rowData.id ) {
			if ( typeof pageObj.controlsMap.gridRows !== 'undefined' && !isInlineAdd ) {
				for (i = 0; i < pageObj.controlsMap.gridRows.length; i++) {
					if (pageObj.controlsMap.gridRows[i].id == rowData.id) {
						rowData.keys = pageObj.controlsMap.gridRows[i].keys;
						break;
					}
				}
			}
			if (isInlineAdd) {
				addedRow = pageObj.inlineAdd.getRowById(rowData.id);
				rowData.keys = addedRow.keys;
			}
			if ( typeof pageObj.listFields !== 'undefined' ) {
				for (i = 0; i < pageObj.listFields.length; i++) {
					rowData.fields[pageObj.listFields[i]] = Runner.getFieldSpan(pageObj.listFields[i], rowData.id);
				}
			}
		}
		
		return rowData;
	},
	
	/**
	 * The button's 'click' handler
	 * @param {Event object} e
	 * @param {object} pageObj
	 * @param {object} proxy
	 * @param {string} pageid
	 * @param {boolean} isInlineAdd
	 */
	clickHandler: function( e, pageObj, proxy, pageid, isInlineAdd ) {
		if ( Runner.isDisabledButton( this.elem ) ) {
			e.preventDefault();
			return;
		}
		
		var ctrl = this,
			rowData = this.getRowData(pageObj, isInlineAdd),
			// create ajax params, before executing user code
			params = {
				buttId: this.btnName,
				rndVal: new Date().getTime()
			}, 
			isManyKeys = 0,
			keyObject = {}, 
			location, res, $checkboxes, i, j, reqParams;

		// set button disabled before executing code
		this.setDisabled();
		// execute code before
		res = pageObj.buttonEventBefore[ this.btnName ]( params, ctrl, pageObj, proxy, pageid, rowData );
		
		if ( res == false ) {
			// if in EventBefore code returned false, we need to set the button enabled
			this.setEnabled();
			e.preventDefault();
			return;
		}
		
		// add key values for edit and view page
		if ( pageObj.keys ) {
			keyObject = pageObj.keys;
			location = pageObj.pageType;
		}
		// add selected recs values code for list page button handlers
		// !!!!!!!!!!!! for edit, view page with details, work not correct !!!!!!!!!!!!! 
		else if ( $('input[type=checkbox][name^=selection]', pageObj.pageCont).length ) {
			$checkboxes = $('input[type="checkbox"][id^="check"][name^="selection"]:checked', pageObj.pageCont);
		
			if ( $checkboxes.length ) {
				location = pageObj.pageType;
				isManyKeys = 1; 
				j = 0;
				
				if ( rowData.keys.length ) {
					keyObject[ j++ ] = rowData.keys.join('&');
					location = 'grid';
				} 
				
				$checkboxes.each( function( idx, checkbox) {
					keyObject[ j++ ] = checkbox.value;
				})
			}
		}
		// add keys for current grid row
		if ( !isManyKeys && rowData.keys.length ) {
			keyObject = rowData.keys;
			location = 'grid';
		}
		
		// send request and handle it
		reqParams = {
			params: JSON.stringify( params ), 
			keys: JSON.stringify( keyObject ), 
			isManyKeys: isManyKeys,
			location: location || ""
		};
		
		$.post( Runner.getPageUrl("buttonhandler"), reqParams, function( result ) {		
			// execute EventAfter code
			pageObj.buttonEventAfter[ ctrl.btnName ]( JSON.parse( result ), ctrl, pageObj, proxy, pageid, rowData );
			ctrl.setEnabled();
		});
		
		e.preventDefault();
	}
});	
/**
 * @param {object} baseCfg
 * @param {string} pageType
 * @param {boolean} isInline
 */
Runner.controls.ControlFabric = function( baseCfg, pageType, isInline ) {
	// adjust pageType value for search controls
	pageType = baseCfg.mode == Runner.controls.constants.MODE_SEARCH ? Runner.pages.constants.PAGE_SEARCH : pageType;
	
	var tName = baseCfg.table, 
		fName = baseCfg.fieldName,
		cfg = {
			isInline: isInline,
			pageType: pageType, 
			goodFieldName: Runner.goodFieldName( baseCfg.fieldName ),
			shortTableName: Runner.pages.PageSettings.getShortTName( tName ),
			editFormat: Runner.pages.PageSettings.getEditFormat(tName, fName, pageType),
			validation: Runner.pages.PageSettings.getValidations( tName, fName, pageType )
		};
		
	// add baseCfg's properties to cfg replacing props with the same name
	cfg = Runner.apply( cfg, baseCfg );	
	
	switch ( cfg.editFormat ) {
		case Runner.controls.constants.EDIT_FORMAT_NONE:
		case Runner.controls.constants.EDIT_FORMAT_PASSWORD:
		case Runner.controls.constants.EDIT_FORMAT_TEXT_FIELD:
			cfg.mask = Runner.pages.PageSettings.getFieldData( tName, fName, "mask", pageType );
			return new Runner.controls.TextField( cfg );
			
		case Runner.controls.constants.EDIT_FORMAT_TEXT_AREA:
			if ( cfg.RTEType === undefined ) {
				cfg.RTEType = Runner.pages.PageSettings.getFieldData( tName, fName, "RTEType", pageType );
			}			
			switch (cfg.RTEType) {
				case Runner.controls.constants.EDIT_FORMAT_RTE:
					return new Runner.controls.RTEInnova( cfg );

				case Runner.controls.constants.EDIT_FORMAT_RTEINNOVA:
					cfg.useRTE = "INNOVA";
					return new Runner.controls.RTEInnova( cfg );

				case Runner.controls.constants.EDIT_FORMAT_RTECK:
					return new Runner.controls.RTECK( cfg );

				default:
					return new Runner.controls.TextArea( cfg );
			}

		// different date controls
		case Runner.controls.constants.EDIT_FORMAT_DATE:
			if ( cfg.dateEditType === undefined ) {
				cfg.dateEditType = Runner.pages.PageSettings.getFieldData( tName, fName, "dateEditType", pageType );
			}			
			cfg.ctrlType = "date" + cfg.dateEditType;
			switch ( cfg.dateEditType ) {
				case Runner.controls.constants.EDIT_DATE_SIMPLE_INLINE:
					cfg.useDatePicker = true;
					cfg.usejQueryDatePicker = true;
					return new Runner.controls.DateTextField( cfg );

				case Runner.controls.constants.EDIT_DATE_SIMPLE_DP:
					cfg.useDatePicker = true;
					cfg.useYuiDatePicker = true;
					return new Runner.controls.DateTextField( cfg );

				case Runner.controls.constants.EDIT_DATE_DD:
					return new Runner.controls.DateDropDown( cfg );

				case Runner.controls.constants.EDIT_DATE_DD_INLINE:
					cfg.useDatePicker = true;
					cfg.usejQueryDatePicker = true;
					return new Runner.controls.DateDropDown( cfg );

				case Runner.controls.constants.EDIT_DATE_DD_DP:
					cfg.useDatePicker = true;
					cfg.useYuiDatePicker = true;
					return new Runner.controls.DateDropDown( cfg );

				case Runner.controls.constants.EDIT_DATE_SIMPLE:
				default:
					return new Runner.controls.DateTextField( cfg );
			}
			
		case Runner.controls.constants.EDIT_FORMAT_TIME:
			return new Runner.controls.TimeField( cfg );

		case Runner.controls.constants.EDIT_FORMAT_CHECKBOX:
			if ( cfg.mode == Runner.controls.constants.MODE_SEARCH ) {
				cfg.ctrlType = "checkbox";
				return new Runner.controls.DropDownLookup( cfg );
			}
			return new Runner.controls.CheckBoxLookup( cfg );
			
		case Runner.controls.constants.EDIT_FORMAT_DATABASE_IMAGE:
			return new Runner.controls.ImageField( cfg );

		case Runner.controls.constants.EDIT_FORMAT_DATABASE_FILE:
			return new Runner.controls.FileField( cfg );

		case Runner.controls.constants.EDIT_FORMAT_FILE:
			if ( Runner.pages.PageSettings.getFieldData( tName, fName, "compatibilityMode", pageType ) ) {
				return new Runner.controls.FileField( cfg );
			}
			cfg.autoUpload = Runner.pages.PageSettings.getFieldData( tName, fName, "autoUpload", pageType );
			cfg.acceptFileTypes = Runner.pages.PageSettings.getFieldData( tName, fName, "acceptFileTypes", pageType );
			cfg.maxFileSize = Runner.pages.PageSettings.getFieldData( tName, fName, "maxFileSize", pageType );
			cfg.maxTotalFilesSize = Runner.pages.PageSettings.getFieldData( tName, fName, "maxTotalFilesSize", pageType );
			cfg.maxNumberOfFiles = Runner.pages.PageSettings.getFieldData( tName, fName, "maxNumberOfFiles", pageType );
			return new Runner.controls.MultiUploadField( cfg );		
		
		case Runner.controls.constants.EDIT_FORMAT_LOOKUP_WIZARD:
			cfg.lcType = Runner.pages.PageSettings.getLCT( tName, fName, pageType );
			cfg.lookupTable = Runner.pages.PageSettings.getLookupTable( tName, fName, pageType );
			cfg.parentFieldName = Runner.pages.PageSettings.getCategoryField( tName, fName, pageType );
			
			cfg.linkField = Runner.pages.PageSettings.getFieldData( tName, fName, "linkField", pageType );
			cfg.dispField = Runner.pages.PageSettings.getFieldData( tName, fName, "dispField", pageType );
			
			cfg.multiSelectionAllowed = Runner.pages.PageSettings.getFieldData( tName, fName, "Multiselect", pageType );
			cfg.isHorizontalLookup = Runner.pages.PageSettings.getFieldData( tName, fName, "HorizontalLookup", pageType );	
			cfg.autoCompleteFields = Runner.pages.PageSettings.getFieldData( tName, fName, "autoCompleteFields", pageType );
			
			// parse additional lookup controls params
			switch ( cfg.lcType ) {
				case Runner.controls.constants.LCT_DROPDOWN:
					cfg.selectSize = Runner.pages.PageSettings.getLookupSize( tName, fName, pageType );
					return new Runner.controls.DropDownLookup( cfg );

				case Runner.controls.constants.LCT_AJAX:
					cfg.freeInput = Runner.pages.PageSettings.getFieldData( tName, fName, "freeInput", pageType );
					return new Runner.controls.EditBoxLookup( cfg );

				case Runner.controls.constants.LCT_LIST:
					return new Runner.controls.ListPageLookup( cfg );

				case Runner.controls.constants.LCT_CBLIST:
					cfg.lcSize = 2;
					return new Runner.controls.CheckBoxLookup( cfg );

				case Runner.controls.constants.LCT_RADIO:
					cfg.lcSize = 2;
					return new Runner.controls.RadioControl( cfg );

				default:
					throw ('Invalid lookup wizard type = ' + cfg.lcType + '. Cannot create lookup!');
					return;
			};
			
		case Runner.controls.constants.EDIT_FORMAT_READONLY:
			return new Runner.controls.ReadOnly( cfg );

		default:
			if ( typeof Runner.controls.constants[ "Edit" + cfg.editFormat ] !== "undefined" ) {
				return new Runner.controls[ "Edit" + cfg.editFormat ]( cfg );
			} 
			throw ('Invalid control edit format = ' + cfg.editFormat + '. Cannot create control!');
			return;
	};
};


/**
 * Base abstract class for all controls, should not be created directly
 * @requires runner, ControlManager, validate, Event
 * @class Runner.controls.Control
 */
Runner.controls.Control = Runner.extend( Runner.Event, {
	/**
	 * Name of control
	 * @type string
	 * @intellisense
	 */
	fieldName: "",
	/**
	 * Name used for HTML tags, attrs
	 * @type String
	 * @intellisense
	 */
	goodFieldName: "",
	/**
	 * table name for urls request
	 * @type String
	 * @intellisense
	 */
	shortTableName: "",
	/**
	 * Control id
	 * @type string
	 * @intellisense
	 */
	id: "",
	
	/**
	 * A flag indicating if the search panel control is cached.
	 * It's always equal to false for not a search panel control
	 * @type {boolean}
	 */
	cached: false,
	
	/**
	 * A Type of the page containing the control
	 * @type String
	 */
	pageType: "",	
	
	/**
	 * custom CSS classes
	 * @type string
	 * @intellisense
	 */
	css: "",
	/**
	 * Custom css styles
	 * @type String
	 * @intellisense
	 */
	style: "",
	/**
	 * Value DOM element id
	 * @type string
	 * @intellisense
	 */
	valContId: "",
	/**
	 * Object, value DOM element
	 * @type {object}
	 * @intellisense
	 */
	valueElem: null,
	/**
	 * Span container element id
	 * @type {string}
	 * @intellisense
	 */
	spanContId: "",
	/**
	 * Span jQuery object
	 * @type {object}
	 * @intellisense
	 */
	spanContElem: null,
	/**
	 * Error container id
	 * @type {string}
	 * @intellisense
	 */
	errContId: "",
	/**
	 * Error container, div
	 * @type {object}
	 * @intellisense
	 */	
	errContainer: null,
	/**
	 * Array of validation types
	 * @type array of string
	 * @intellisense
	 */
	validationArr: null,

	/**
	 * Value after initialization
	 * @intellisense
	 */
	defaultValue: null,
	/**
	 * Is reset form happend or not
	 * @intellisense
	 */
	isClearHappend: false,
	/**
	 * Source table
	 * @intellisense
	 */
	table: "",
	/**
	 * Defined the control's validation regExp
	 * @type {object}
	 * @intellisense
	 */
	regExp: null,

	/**
	 * Edit type of control, that used to process data on server
	 * Was created for search submit
	 * @type String
	 * @intellisense
	 */
	ctrlType: "",
	/**
	 * Is editable elems shown
	 * @type {boolean}
	 * @intellisense
	 */
	showStatus: true,
	/**
	 * Number of control for the field. In advanced search page only 2 controls may appear for the field.
	 * But ControlManager can add any ammount of controls to the field 
	 * @type number
	 * @intellisense
	 */
	ctrlInd: -1,
	/**
	 * Indicator, is focused element or not
	 * @type Boolean
	 * @intellisense
	 */
	isSetFocus: false,
	/**
	 * Hidden property
	 * @type Boolean
	 * @intellisense
	 */
	hidden: false,
	/**
	 * Indicator, is field wich control belong hided
	 * @type Boolean
	 * @intellisense
	 */
	hiddenByField: false,
	/**
	 * Mode of using control add|adit|search
	 * @type String
	 * @intellisense
	 */
	mode: '',
	
	/**
	 * Indicator, true if control was marked as invalid.
	 * Usefull for password matching and validation etc.
	 * @type Boolean
	 * @intellisense
	 */
	isInvalid: false,
	
	/**
	 * An object to add and store pairs of a validator's name and 
	 * a data object (containing 'message', 'messageType' props) of the message 
	 * that will be shown if the control fails this validator's check.
	 * @type {object}
	 */
	customValidationFailedMessages: {},

	
	/**
	 * Class constructor
	 * @constructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		// copy properties from cfg to controller obj
		Runner.apply( this, cfg );
		
		Runner.controls.Control.superclass.constructor.call(this, cfg);	
		
		this.initValidationParams( cfg.validation );
		
		this.assignBasicElementsIdValues();		
		this.assignValueElem();
		this.assignSpanContainerElem();

		if ( cfg.hidden ) {
			this.hide();
		}

		this.setDefaultValue();
		
		this.addStyle( this.style );
		this.addClass( this.css );
	
		// register the new control
		Runner.controls.ControlManager.register( this );	
		
		this.initCustomEvents();	
	},

	/**
	 * Init the control's validators and
	 * custom validation messages
	 * @param {object} validationParams
	 */
	initValidationParams: function( validationParams ) {
		this.validationArr = validationParams.validationArr || [];
		this.customValidationFailedMessages = validationParams.customMessages || {}
		this.regExp = validationParams.regExp;
		
		// register user's custom validation functions
		Runner.validation.registerCustomValidation( this );	
	},
	
	/**
	 * Set the basic control's elements id values
	 */
	assignBasicElementsIdValues: function() {
		// value element id
		this.valContId = "value" + ( this.ctrlInd || "" ) + "_" + this.goodFieldName + "_" + this.id;
		// error DOM element id
		this.errContId = "errorCont" + this.ctrlInd + "_" + this.valContId;		
	},
	
	/**
	 * Set the value element and associated properties
	 */
	assignValueElem: function() {		
		this.valueElem = this.valueElem || $("#" + this.valContId);		
	},
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */
	assignsElemsForEvent: function() {
		if ( this.appearOnPage() && !this.elemsForEvent.length ) {
			//set the DOM elements array, to add custom listeners then 
			this.elemsForEvent = [ this.valueElem.get(0) ];
		}		
	},

	/**
	 * Set the control's events list
	 */
	assignListOfEvents: function() {
		this.addEvent( ["click", "blur", "change", "keyup", "edited", "editing", "input"] );		 
	},
	
	/**
	 * Add and init custom events fot the control
	 */
	initCustomEvents: function() {
		this.assignsElemsForEvent();		
		this.assignListOfEvents();
		//the event's initialization allows the control's props/methods
		//with event names to be invoked when the event is triggered
		//the init method is called from superclass to protect its 
		//invocation from any child sclasses' overrided 'init' methods 
		Runner.controls.Control.superclass.init.call(this);
		
		this.addEditEditingListeners();
	},
	
	/**
	 * Set the control's span container element and its id 
	 */
	assignSpanContainerElem: function() {
		this.spanContId = "edit" + this.id + "_" + this.goodFieldName + "_" + this.ctrlInd;
		this.spanContElem = $("#" + this.spanContId);		
	},
	
	/**
	 * Set the events that will fire "edited", "editing" events
	 */
	addEditEditingListeners: function() {
		this.on("change", function( e, updateContext ) {
			updateContext = updateContext && typeof updateContext === "object" ? updateContext : {};
			this.fireEvent("edited", updateContext);
			this.fireEvent("editing", updateContext);
		});
	},
	
	/**
	 * The method is invoked when the "edited" event is fired 
	 * @param {object} nullEvent		 Equals to null if function is invoked 
	 * 								with the fireEvent method
	 * @param {object} updateContext
	 */
	"edited": function( nullEvent, updateContext ) {
		var valArr = this.getPreparedValidationArray();
		
		if ( valArr.length ) {
			this.validate( valArr );
		}		
	},

	/**
	 * Get the validation array copy. Remove from the result array 
	 * the "IsRequired" element if the control is not marked as invalid
	 * @retur {array}
	 */
	getPreparedValidationArray: function() {
		var valArr = this.validationArr.slice(0), i;
		
		if ( !this.invalid() ) {
			for (i = 0; i < valArr.length; i++) {
				if ( valArr[i] == "IsRequired" ) {
					valArr.splice(i, 1);
					break;
				}
			}			
		}
		return valArr;
	},
	
	destructor: function() {
		this.purgeListeners();
	},
	
	unregister: function() {
		Runner.controls.ControlManager.unregister( this.table, this.id, this.fieldName );
	},
	
	/**
	 * Initialize the control's tooltip 
	 * @param {string} text
	 * @param {object} pageObj		The page's object reference	
	 */
	initToolTip: function( text, pageObj ) {		
		if ( this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}
		
		var $toolTipElem = $( this.valueElem );		
	
		$toolTipElem = $toolTipElem.is(":visible") ? $toolTipElem : this.spanContElem;
	
		$toolTipElem.addClass('titleHintBox')
			.inputHintBox({
				div: $('#shiny_box'), 
				div_sub: '.shiny_box_body', 
				html: text, 
				isFly: Runner.isFlyPage( pageObj ),
				el: this.getToolTipPositionElem()
			});
				
		this.initToolTip = Runner.emptyFn;
	},
	
	/**
	 * Get the tooltip position element distinct from the basic tooltip element
	 * @return {Mixed}	 
	 */
	getToolTipPositionElem: function() {
		return null;
	},	
	
	/**
	 * Add styles to the value element
	 * @param {string} styleToAdd
	 * @intellisense
	 */
	addStyle: function( styleToAdd ) {	
		if ( !styleToAdd || !(this.valueElem instanceof jQuery) ) {
			return;
		}
		
		var stylesArr = styleToAdd.split(';'), 
			i, style, propertyName, value;
		
		for (i = 0; i < stylesArr.length; i++) {
			style = stylesArr[ i ].split(":");
			propertyName = style[0].toString().trim();
			
			if  ( propertyName ) {
				value = style[1].toString().trim();
				this.valueElem.css( propertyName, value );
			}
		}
	},
	
	/**
	 * Validate the control with validators set in the array-param passed 
	 * or in the control's 'validationArr' array 
	 * @method validate
	 * @params {array} valArr - array of validation for event blur only
	 * @return {object}
	 * @intellisense
	 */
	validate: function( valArr ) {
		if ( !this.appearOnPage() || this.hiddenByField ) {
			return Runner.validation.getTrueValidationResult();
		}
		
		var validators = valArr || this.validationArr,	
			vRes = Runner.validation.validate( validators, this );
			
		// change invalid status only if any validation were made, to prevent init error container
		if ( validators.length ) {
			if ( !vRes.result ) {
				this.markInvalid( validators, vRes.messagesData );
			} else {
				this.clearInvalid( vRes.delayedValidators );
			}
		}

		return vRes;
	},
	
	/**
	 * removes validation from control. 
	 * @param {string} vType
	 * @return {boolean} If success true, false otherwise
	 * @intellisense
	 */
	removeValidation: function( vType ) {
		if ( typeof vType !== "string" ) {
			this.regExp = null;
			vType = "RegExp";
		}
		
		for (var i = 0; i < this.validationArr.length; i++) {
			if ( this.validationArr[i] == vType ) {
				this.validationArr.splice(i, 1);
				return true;
			}
		}
		return false;
	},
	
	/**
	 * Adds validation to control
	 * @param {string} vType
	 * @intellisense
	 */
	addValidation: function( vType ) {
		if ( this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}
		
		if ( typeof vType != "string" ) {
			this.regExp = vType;
			vType = "RegExp";
		}
		if ( !this.isSetValidation( vType ) ) {
			this.validationArr.push( vType );
		}
	},
	
	/**
	 * Checks if validation added
	 * @param {string} vType
	 * @return {boolean} If success true, false otherwise
	 * @intellisense
	 */
	isSetValidation: function( vType ) {
		if ( !Runner.validation[ vType ] ) {
			return false;
		}

		for (var i = 0; i < this.validationArr.length; i++) {
			if ( this.validationArr[i] == vType ) {
				return true;
			}
		}

		return false;
	},
	
	/**
	 * Validates control value against vType validation
	 * @param {string} vType
	 * @return {mixed}
	 * @intellisense
	 */
	validateAs: function( vType ) {
		if ( !this.appearOnPage() ) {
			return Runner.validation.getTrueValidationResult();
		}
		
		Runner.validation.control = ctrl;
		return Runner.validation[ vType ]( this.getValue() );
	},
	
	/**
	 * Helper func for lazy init error container
	 * @private
	 * @intellisense
	 */
	initErrorCont: function() {
		// create error container
		this.errContainer = $('<div></div>')
			.attr('id', this.errContId)
			.addClass('rnr-error-text')
			.css('display', 'none')
			.appendTo( this.spanContElem );
			
		this.initErrorCont = Runner.emptyFn;
	},
	
	/**
	 * Sets error messages after validation
	 * @param {array} validators
	 * @param {object} messagesData
	 * @intellisense
	 */
	markInvalid: function( validators, messagesData ) {
		this.initErrorCont();
		
		this.markInvalid = function( validators, messagesData ) {
			var pageObj = Runner.pages.PageManager.getAt( this.table, this.id ),
				that = this;
							
			pageObj.validateTimer = setTimeout( function() {
				that.errContainer.show();
			}, 1000);
			
			this.addValidationMessagesToErrorCont( validators, messagesData );			
			// set invalid indicator
			this.isInvalid = true;
		}
		
		this.markInvalid( validators, messagesData );
	},
	
	/**
	 * Show custom error message
	 * @param {string} validatorName
	 * @param {array} messages
	 */
	markInvalidWidthCusttomMessages: function( validatorName, messages ) {
		var messagesData = {};
		messagesData[ validatorName ] = messages;
		this.markInvalid( [validatorName], messagesData );
	},
	
	/**
	 * Add the failed validation messages to the control's error container
	 * Each validator has its own container to dispaly errors
	 * @param {array} validators
	 * @param {object} messagesData
	 */
	addValidationMessagesToErrorCont: function( validators, messagesData ) {
		var i, message,
			suffix = this.goodFieldName + "_" + this.id;
		
		for (i = 0; i < validators.length; i++) {	
			message = Runner.validation.extractValidationMessage( validators[i], messagesData ) 
		
			if ( message !== "" ) {
				this.setValidationMessage( validators[i] + suffix, message );
			}
		}
	},
	
	/**
	 * Get the validator error container
	 * and fill it with validation error message
	 * @param {string} contId
	 * @param {string} message
	 */	 
	setValidationMessage: function( contId, message ) {
		var validatorContainer = this.getValidationMessageContainer( contId );
		
		validatorContainer.html( message ).show();
	},
	
	/**
	 * Get existing or create the validator error container
	 * @param {string} contId
	 * @return {jQuery object}
	 */
	getValidationMessageContainer: function( contId ) {
		var validatorContainer = $("#" + contId, this.errContainer);
		
		if ( !validatorContainer.length ) {
			validatorContainer = $('<div id="' + contId + '"></div>')
				.appendTo( this.errContainer );
		}
		
		return validatorContainer;
	},
	
	/**
	 * Get the existing validators error messages containers from the
	 * control's error containter
	 * @return {jQuery collection object}
	 */
	getValidationMessagesContainers: function() {
		return this.errContainer.children('div');
	},
	
	/**
	 * Clears invalid state
	 * @param {Array} delayedValidators	(optional)
	 * @method
	 * @intellisense
	 */
	clearInvalid: function( delayedValidators ) {
		this.initErrorCont();
		
		this.clearInvalid = function( delayedValidators ) {				
			// set invalid indicator
			this.isInvalid = false;
			
			this.hideNotDelayeValidationMessages( delayedValidators || [], this.goodFieldName + "_" + this.id );			
			this.updateErrorsContainerVisibility();
		}
		
		this.clearInvalid();
	},	
	
	/**
	 * Update the control's error container visibility
	 */
	updateErrorsContainerVisibility: function() {
		if ( !this.errContainer.children("div:visible").length ) {
			this.errContainer.hide();
		}
	},
	
	/**
	 * Hide the validation error messages nod connected with delayed validators
	 * The tempotary class 'delayedValidation' is used to mark delayed messages	 
	 * @param {Array} delayedValidators	
	 */
	hideNotDelayeValidationMessages: function( delayedValidators, suffix ) {
		var messageConts = this.getValidationMessagesContainers(), i
		
		for (i = 0; i < delayedValidators.length; i++) {
			this.getValidationMessageContainer( delayedValidators[i] + suffix )
				.addClass( "delayedValidation" );
		}
		
		messageConts.not(".delayedValidation").hide().empty();
		messageConts.filter(".delayedValidation").removeClass( "delayedValidation" );
	},
	
	/**
	 * Return invalid state of control
	 * @return {boolean}
	 * @intellisense
	 */
	invalid: function() {
		return this.isInvalid;
	},

	/**
	 * Scrolls the element's offset parent so I shows the element
	 * @param {jQuery object} elem
	 */
	scrollToElem: function( elem ) {
		var offsetParent = elem.offsetParent(),
			elemPosition = elem.position(),
			elemWidth = elem.width(),
			scrollTo = offsetParent.scrollTop() + elemPosition.top, 
			scrollLeft = offsetParent.scrollLeft() + elemPosition.left + elemWidth - offsetParent.width(),
			inlineMode = this.mode === Runner.pages.constants.PAGE_INLINE_EDIT || this.mode === Runner.pages.constants.PAGE_INLINE_ADD;
		
		if ( offsetParent.css("position") === "static" ) {
			//the page isn't in popup mode
			offsetParent = $("html");
			scrollTo = elemPosition.top;
			offsetLeft = offsetParent.scrollLeft() + elemPosition.left + elemWidth - $(window).width();
		}
		
		if ( this.pageType === Runner.pages.constants.PAGE_LIST && inlineMode ) {
			//the list page's inline modes 
			offsetParent.scrollLeft( scrollLeft + 5 );
			return;	
		}	
		
		offsetParent.scrollTop( scrollTo - 5 );
	},
	
	/**
	 * Set the default value to the control
	 * @param {object} updContext
	 * @method
	 * @intellisense
	 */
	reset: function( updContext ) {
		this.setValue( this.defaultValue, true, updContext );
		this.clearInvalid();
	},
	
	/**
	 * Sets empty value to control
	 * return true if success. otherwise false
	 * @method
	 * @intellisense
	 */
	clear: function() {
		this.isClearHappend = true;
		this.setValue('');
		this.clearInvalid();
		this.isClearHappend = false;
	},
	
	/**
	 * Hide control - set display attr none
	 * Should be overriden for sophisticated controls
	 * @method
	 * @intellisense
	 */
	hide: function() {
		this.spanContElem.css("display", "none");
		this.showStatus = false;
	},
	
	/**
	 * Show control - set display attr block
	 * Should be overriden for sophisticated controls
	 * @method
	 * @intellisense
	 */
	show: function() {
		this.spanContElem.css("display", "");
		this.showStatus = true;
	},
	
	/**
	* Toggle a control basing on 'visibility' param
	* @param {Boolean} visibility
	*/
	toggle: function( visibility ) {
		if ( visibility ) {
			this.show();
		} else {
			this.hide();
		}
	},
	
	/**
	 * Toggle show/hide status
	 * @intellisense
	 */
	toggleHide: function() {
		this.toggle( !this.showStatus );
	},
	
	/**
	 * Get value from value element. 
	 * Should be overriden for sophisticated controls
	 * @method
	 * @intellisense
	 */
	getValue: function() {
		if ( this.valueElem instanceof jQuery && this.valueElem.length) {
			return this.valueElem.val();
		}
		return false;
	},
	
	/**
	 * Set the control's default value
	 * @return {string}
	 */
	setDefaultValue: function() {
		this.defaultValue = this.getValue();
	},
	
	/**
	 * Return value as string
	 * @return {string}
	 * @intellisense
	 */
	getStringValue: function() {
		return this.getValue();
	},
	
	/**
	 * Sets value to value DOM elem
	 * Should be overriden for sophisticated controls
	 * @method
	 * @param {mixed} val
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 * @intellisense
	 */
	setValue: function( val, triggerEvent, updContext ) {
		if ( this.valueElem instanceof jQuery ) {
			this.valueElem.val( val );
			
			if ( triggerEvent === true ) {
				this.fireEvent("change", updContext);
			}	
			return true;
		}
		
		return false;
	},
	
	/**
	 * Sets disable attr true
	 * Should be overriden for sophisticated controls
	 * @method
	 * @intellisense
	 */
	setDisabled: function() {
		if ( this.valueElem.length ) {
			this.valueElem.prop("disabled", true);
			return true;
		}
		return false;
	},
	
	/**
	 * Sets disaqble attr false
	 * Should be overriden for sophisticated controls
	 * @method
	 * @intellisense
	 */
	setEnabled: function() {
		if ( this.valueElem.length ) {
			this.valueElem.prop("disabled", false);
			return true;
		}
		return false;
	},
		
	/**
	 * Check if it's possible to set focus on the control
	 * @return {boolean}
	 */
	isFocusAllowed: function() {
		return !this.hiddenByField;
	},
	
	/**
	 * Sets focus to the control's element.
	 * @param {boolean} triggerEvent
	 * @method
	 * @intellisense
	 */
	setFocus: function( triggerEvent ) {	
		var ctrlElem;
		
		this.isSetFocus = false;
				
		// can't set focus on disabled element. This may cause IE error
		if ( !this.appearOnPage() || this.valueElem.prop('disabled') || !this.showStatus || !this.valueElem.is(":visible") ) {
			return;
		}
		
		ctrlElem = this.valueElem.get(0);
		
		try {
			if ( ctrlElem !== document.activeElement && ctrlElem.focus ) {		
				ctrlElem.focus();
				this.isSetFocus = true;
				if ( triggerEvent === true ) {
					this.fireEvent("focus");
				}			
				return false;
			}
		} catch ( e ) {
				// Support: IE<9
		}
	},
	
	/**
	 * Checks if control value is empty. Used for isRequired validation
	 * @method
	 * @return {boolean}
	 * @intellisense
	 */
	isEmpty: function() {
		return this.getValue().toString() === "";
	},
	
	/**
	 * Custom function for onblur event
	 * @param {Object} e
	 * @intellisense
	 */
	"blur": function(e) {
		this.stopEvent(e);
		this.isSetFocus = false;
	},
	
	/**
	 * Sets focus indicator true when click on elem
	 * @param {event} e
	 * @intellisense
	 */
	"click": function(e) {
		this.isSetFocus = true;
	},
	
	/**
	 * Removes css class to value element
	 */
	removeCSS: function( className ) {
		this.valueElem.removeClass( className );
	},
	
	/**
	 * Removes css class to value element
	 * @param {string} className
	 * @intellisense
	 */
	removeClass: function( className ) {
		if ( this.valueElem instanceof jQuery ) {
			this.valueElem.removeClass( className );
		}
	},
	
	/**
	 * Adds css class to value element
	 */
	addCSS: function( className ) {
		if ( this.valueElem instanceof jQuery && className ) {
			this.valueElem.addClass( className );
		}
	},
	
	/**
	 * Adds css class to value element
	 * @param {string} className
	 * @intellisense
	 */
	addClass: function( className ) {
		if ( this.valueElem instanceof jQuery && className ) {
			this.valueElem.addClass( className );
		}
	},
	
	/**
	 * Returns specified attribute from value element
	 * @param {string} attrName
	 * @intellisense
	 */
	getAttr: function( attrName ) {
		return this.valueElem.attr( attrName );
	},
	
	/**
	 * Return element that used as display.
	 * Usefull for suggest div positioning
	 * @return {object}
	 * @intellisense
	 */
	getDispElem: function() {
		return this.valueElem;
	},
	
	/**
	 * Clone html for iframe submit
	 * @return {array}
	 * @intellisense
	 */
	getForSubmit: function() {
		return this.appearOnPage() ? [ this.valueElem.clone().val( this.valueElem.val() ) ] : [];
	},
	
	/**
	 * Make readonly control
	 * Get control's clone, make it readonly
	 * And make contol hidden
	 *
	 * @return {boolean}
	 * @intellisense
	 */
	makeReadonly: function() {
		if ( !this.appearOnPage() || this.isReadonly() ) {
			return false;
		}
		
		this.readonlyElem = this.valueElem.clone();
		this.readonlyElem.prop({
			'id': 'readonly_' + this.valContId,
			'name': 'readonly_' + this.valContId,
			'disabled': true,
			'readonly': true
		});	
		this.readonlyElem.prependTo( this.spanContElem );
		
		this.valueElem.hide();
		return true;
	},
	
	/**
	 * Change readonly control to readwrite
	 * Remove control's clone and make contol visible
	 *
	 * @return {boolean}
	 * @intellisense
	 */ 
	makeReadWrite: function() {
		if ( !this.appearOnPage() || !this.isReadonly() ) {
			return false;
		}
		
		this.readonlyElem.remove();	
		this.readonlyElem = undefined;
		this.valueElem.css('display', '');
		return true;
	},
	
	/**
	 * Check is control readonly or not
	 * @return {boolean}
	 * @intellisense
	 */
	isReadonly: function() {
		return !!$('#readonly_' + this.valContId).length;
	},
	
	/**
	 * Check is control exist or not
	 * @return {boolean}
	 * @intellisense
	 */	
	appearOnPage: function() {
		return !!this.valueElem.length;
	},
	
	/**
	 * @param {string}
	 * @return {mixed}
	 */ 
	getFieldSetting: function( key ) {
		return Runner.pages.PageSettings.getFieldData( this.table, this.fieldName, key, this.pageType );
	},

	/**
	 * Get the displayed field's value
	 * Overrided for lookup wizard controls
	 * @intellisense
	 */
	getDisplayValue: function() {
		return this.getValue();
	},
	
	/**
	 * Get the default control's value
	 * @return {String | Number}
	 */
	getDefaultControlValue: function() {
		return this.defaultValue;
	},

	/**
	 * Validate the control with the 'DenyDuplicated' validator
	 * if the 'DenyDuplicated' validation is set for the field
	 */
	checkDuplicates: function() {
		if ( !this.isSetValidation('DenyDuplicated') ) {
			return;
		}
		this.validate( ['DenyDuplicated'] );
	},
	
	/**
	 * The stub for the not to-states search controls
	 * @param {string} searchOption
	 */
	updateAppearance: function( searchOption ) {},
	
	/**
	 * Check if search suggests need initializing for the control #8538
	 * @return {boolean}
	 */
	useSearchSuggests: function() {
		return this.editFormat === Runner.controls.constants.EDIT_FORMAT_TEXT_FIELD;
	},
	
	/**
	 * Check if suggests should be displayed for the control
	 * @return {boolean}
	 */
	implySuggests: function() {
		return this.editFormat === Runner.controls.constants.EDIT_FORMAT_TEXT_FIELD;
	}
});

/**
 * Create a view control
 */
Runner.viewControls.ViewControlFabric = function( baseCfg, pageType, pageContext, pageObject ) {
	// make an object copy, not reference
	var cfg = {
			pageType: pageType, 
			goodFieldName: Runner.goodFieldName( baseCfg.fieldName ),
			pageContext: pageContext,
			pageObject: pageObject
		};
		
	Runner.apply( cfg, baseCfg );
		
	if ( typeof Runner.viewControls[ cfg.viewFormat ] !== "undefined" ) {
		return new Runner.viewControls[ cfg.viewFormat ]( cfg );
	} 
	
	throw ('Invalid control view format = ' + cfg.viewFormat + '. Cannot create control!');
};


/**
 * Base abstract class for all view controls, should not be created directly
 * @requires runner
 * @class Runner.controls.ViewControl
 */
Runner.viewControls.ViewControl = Runner.extend( Runner.emptyFn, {
	/**
	 * Name of control
	 * @type string
	 * @intellisense
	 */
	fieldName: "",
	/**
	 * Name used for HTML tags, attrs
	 * @type String
	 * @intellisense
	 */
	goodFieldName: "",
	/**
	 * table name for urls request
	 * @type String
	 * @intellisense
	 */
	shortTableName: "",
	/**
	 * Source table
	 * @type String
	 * @intellisense
	 */
	table: "",
	/**
	 * DOM context of control's page 
	 * @type String
	 * @intellisense
	 */
	pageContext: null,
	/**
	 * Page type
	 * @type String
	 * @intellisense
	 */
	pageType: "", 
	/**
	 * @constructor
	 */
	constructor: function( cfg ) {
		// copy properties from cfg to controller obj
		Runner.apply( this, cfg );
	}	
});
Runner.viewControls.ViewVideoField = Runner.extend( Runner.viewControls.ViewControl, {

	/**
	 * Override constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {		
		// call parent
		Runner.viewControls.ViewVideoField.superclass.constructor.call(this, cfg);
	},


	init: function() {
		setTimeout(function() {
			$("video", this.pageContext).each( function() {
				var obj = $(this);
				projekktor(obj, {
					controls: true,
					volume: 0.5,
					width: obj.attr("width"),
					height: obj.attr("height"),
					playerFlashMP4: Runner.getFullResourcePath('jarisplayer.swf'),
					playerFlashMP3: Runner.getFullResourcePath('jarisplayer.swf')
				});
			});
		}, 10);
	}
});

Runner.viewControls["Video file"] = Runner.viewControls.ViewVideoField;
Runner.viewControls["Database video"] = Runner.viewControls.ViewVideoField;
Runner.viewControls.ViewImageField = Runner.extend( Runner.viewControls.ViewControl, {
	/**
	 * The host page's object
	 * @type {object}
	 */
	pageObject: null,

	/**
	 * Override constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {		
		Runner.viewControls.ViewImageField.superclass.constructor.call(this, cfg);
	},

	/**
	 * Initalize sliders 
	 */
	init: function() {
		var ctrl = this,
			pageObj = this.pageObject,
			pageContent = this.pageContext,
			recalculateGridSize = typeof this.pageObject.recalculationGridSize === "function";
			
		setTimeout( function() {
			var hasSliders = false, 
				isRTL = Runner.isDirRTL(),
				$zoomboxes = $('.zoombox', pageContent),
				$heightHolderDiv = $('<div></div>').css({
						display: "inline",
						width: "1px;"
					});;
						
			if ( $zoomboxes.length ) {
				$zoomboxes.zoombox({
					theme: 'zoombox', 
					opacity: 0.8,
					duration: 400, 
					animation: false,
					gallery: false, 
					autoplay: false
				});;
			}

			$(".presudoslider", pageContent).each( function() {
				var $presudoslider = $(this),
					$bigThumbnailsContainer = $('.big-thumbnails', $presudoslider),
					$smallThumbnails, $bigThumbnails;
				
				if (isRTL) { 
					$presudoslider.closest('td')
						.attr('dir', 'LTR')
						.attr("style", "text-align: left !important;");  //?
				}
				
				if ( !$bigThumbnailsContainer.length ) {
					$presudoslider
						.removeClass('presudoslider')
						.addClass('sudoslider')
						.sudoSlider();
					
					hasSliders = true;
					return;
				}
								
				$bigThumbnails = $bigThumbnailsContainer.find('a');
				ctrl.initToolTips( $bigThumbnails, $bigThumbnailsContainer );
							
				$smallThumbnails = $presudoslider.find('ul:first li a')
					.click( function() {
						var bigThumbnailLink = $(this).attr('href'),
							activeBigPictureLinkElem = $bigThumbnails.filter('.active'),
							activeBigPicture = $('img', activeBigPictureLinkElem); 
						
						$heightHolderDiv
							.height( activeBigPicture.height() )
							.insertAfter( activeBigPictureLinkElem );
						
						activeBigPictureLinkElem.removeClass('active').fadeOut( 100, function() {
							$bigThumbnails.filter('[href="' + bigThumbnailLink + '"]')
								.css('display', 'inline')
								.addClass('active')
								.fadeIn( 200, function() {
									if ( recalculateGridSize ) {
										pageObj.recalculationGridSize();
									}
								});
						}).css("display", "inline");
						
						return false;
					});

				$smallThumbnails.parent()
					.addClass( "rnr-small-thumbnails" )
					.show();

				if ( !$bigThumbnails.hasClass('zoombox') ) {
					// prevent image from being opened in a full size
					$bigThumbnails.on("click", function() { return false; });
				}
					
				$bigThumbnails.filter(':first')
					.addClass('active')
					.show();
			
				$presudoslider
					.removeClass('presudoslider')
					.addClass('presudoslider-disable');
			});

			if ( pageObj.pageType == 'view' && pageObj.tabsPresented || pageObj.checkIfSectionPresented() ) {
				setTimeout( function() {
					ctrl.resizeSliders( ctrl.pageContext );
				}, 100);
			}
			
			if ( recalculateGridSize ) {
				pageObj.recalculationGridSize();
			}
		}, 100);
	},
	
	/**
	 * Resize sliders
	 * @param {DOM Element | jQuery object} container
	 */
	resizeSliders: function( container ) {
		$(".sudoslider", container).each( function() {
			var $sudoDiv = $(this),
				$image;
				
			if ($sudoDiv.width() !== 0) {
				return;
			}
			
			$image = $('li img', sudoDiv).eq(0);
			if ( !$image.length ) {
				return;
			}
			
			$sudoDiv.width( $image.width() );
			$sudoDiv.height( $image.height() );
			$('.prevBtn', $sudoDiv.parent()).hide();
		});
	},
	
	/**
	 * @param {jQuery object} $bigThumbnails
	 * @param {jQuery object} $bigThumbnailsContainer
	 */
	initToolTips: function( $bigThumbnails, $bigThumbnailsContainer ) {
		if ( !$bigThumbnails.hasClass('zoombox') ) {
			return;
		}
		
		var $bigThumbnailTooltip = $('<span />').text('(+)');
			
		if ( $bigThumbnailsContainer.height() >= 28 && $bigThumbnailsContainer.width() >= 175 ) {
			$bigThumbnailTooltip.text('Click here to view full size (+)');
		}
		
		$bigThumbnails.children('img')
			.after( $bigThumbnailTooltip );
	}
});

Runner.viewControls["File-based Image"] = Runner.viewControls.ViewImageField;
Runner.viewControls.ViewFileField = Runner.extend( Runner.viewControls.ViewControl, {

	pageObject: null,
	/**
	 * Override constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {		
		// call parent
		Runner.viewControls.ViewFileField.superclass.constructor.call(this, cfg);
	},


	init: function() {
		var self = this;
		setTimeout(function() {
			var zoomboxes = $('.zoombox', self.pageContext);
			if (zoomboxes.length) {
				zoomboxes.zoombox({
					theme: 'zoombox', opacity: 0.8,
					duration: 400, animation: false,
					gallery: false, autoplay : false
				});
			}
		}, 100);
	}
});

Runner.viewControls["Document Download"] = Runner.viewControls.ViewFileField;
Runner.viewControls.ViewDatabaseImageField = Runner.extend( Runner.viewControls.ViewControl, {

	/**
	 * Override constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {		
		// call parent
		Runner.viewControls.ViewDatabaseImageField.superclass.constructor.call(this, cfg);
	},


	init: function() {
		var self = this;
		setTimeout(function() {
			var zoomboxes = $('.zoombox', self.pageContext);
			if (zoomboxes.length) {
				zoomboxes.zoombox({
					theme: 'zoombox', opacity: 0.8,
					duration: 400, animation: false,
					gallery: false, autoplay : false
				});
			}
		}, 100);
	}
});

Runner.viewControls["Database Image"] = Runner.viewControls.ViewDatabaseImageField;
Runner.viewControls["Old file-based Image"] = Runner.viewControls.ViewDatabaseImageField;
/**
 * Class for read only control
 */
Runner.controls.ReadOnly = Runner.extend( Runner.controls.Control, {
	/**
	 * @type {jQuery object}
	 */ 
	readonlyElem: null,
	
	
	constructor: function( cfg ) {
		Runner.controls.ReadOnly.superclass.constructor.call(this, cfg);
		
		// process the special case when lookupwizard field is transformed to readonly with a master key value
		if ( this.pageType === Runner.pages.constants.PAGE_ADD && !this.isEmpty() ) {
			this.linkField = Runner.pages.PageSettings.getFieldData( this.table, this.fieldName, "linkField", this.pageType );
			this.autoCompleteFields = Runner.pages.PageSettings.getFieldData( this.table, this.fieldName, "autoCompleteFields", this.pageType );			
			
			this.doAutoCompleteFields();
		}			
	},

	/**
	 * Set the value element and associated properties
	 */
	assignValueElem: function() {		
		Runner.controls.ReadOnly.superclass.assignValueElem.call( this );
		this.readonlyElem = $('#readonly_' + this.valContId);
		
		// process the special case when lookupwizard field is transformed to readonly with a master key value
		if ( this.pageType === Runner.pages.constants.PAGE_ADD && this.value !== '' ) {
			this.linkField = Runner.pages.PageSettings.getFieldData( this.table, this.fieldName, "linkField", this.pageType );
			this.autoCompleteFields = Runner.pages.PageSettings.getFieldData( this.table, this.fieldName, "autoCompleteFields", this.pageType );			
			
			this.doAutoCompleteFields();
		}			
	},
	
	/**
	 * The stub preventing the base control's 'initCustomEvents' 
	 * method from beeing invoked for the control
	 */	
	initCustomEvents: Runner.emptyFn,
	
	/**
	 * Validate the control
	 * @return {object}
	 */
	validate: function() {
		return {
			result: true
		};
	},
	
	/**
	 * Check if it's possible to set focus on the control
	 * @return {boolean}
	 */	
	isFocusAllowed: function() {
		return false;
	},
	
	/**
	 * The stub preventing the control 
	 * from setting focus on it
	 */
	setFocus: Runner.emptyFn,
	
	
	setValue: function( val, triggerEvent, updContext ) {
		Runner.controls.ReadOnly.superclass.setValue.call( this, val, triggerEvent, updContext );
		this.readonlyElem.empty().html( val );
	},
	
	/**
	 * A wrapper for a Runner.controls.LookupWizard.doAutoCompleteFields method
	 */
	doAutoCompleteFields: function() {
		Runner.controls.LookupWizard.prototype.doAutoCompleteFields.call( this );
	}	
});
/**
 * TextArea control class
 */
Runner.controls.TextArea = Runner.extend( Runner.controls.Control,{
	/**
	 * Override constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {		
		Runner.controls.TextArea.superclass.constructor.call(this, cfg);
	},

	/**
	 * Set the events that will fire "edited", "editing" events
	 */	
	addEditEditingListeners: function() {
		this.on("change", function(e, updateContext) {
			updateContext = updateContext && typeof updateContext === "object" ? updateContext : {};
			this.fireEvent("edited", updateContext);
		});
		 
		this.on("keyup", function(e) {
			if ( !e || !Runner.isAcceptableKeyCode(e) ) {
				return false;
			}
			this.fireEvent("editing");
		}, {buffer: 300});
	},
	
	/**
	 * The method is invoked when the "editing" event is fired 
	 */
	"editing": function() {
		this.checkDuplicates();
	},		
			
	/**
	 * Clone html for iframe submit
	 * @return {array}
	 */
	getForSubmit: function() {
		if (!this.appearOnPage()) {
			return [];
		}
		return [this.valueElem.clone().val(this.getValue())]
	}
});
/**
 * Class for text fields control
 */
Runner.controls.TextField = Runner.extend( Runner.controls.Control, {
	/**
	 * Text field input mask
	 * @type string
	 * @intellisense
	 */
	mask: "",

	
	constructor: function( cfg ) {
		Runner.controls.TextField.superclass.constructor.call( this, cfg );
		
		if ( this.isSetValidation('DenyDuplicated') ) {
			this.valueElem.attr('autocomplete', 'off');
		}
		
		if ( this.mask !== "" && this.mask !== false ) {
            this.valueElem.mask( this.mask );
		}	
	},
	
	/**
	 * Set the events that will fire "edited", "editing" events
	 */
	addEditEditingListeners: function() {
		this.on("change", function(e, updateContext) {
			updateContext = updateContext && typeof updateContext === "object" ? updateContext : {};
			this.fireEvent("edited", updateContext);
		});
		 
		this.on("keyup", function(e) {
			if ( !e || !Runner.isAcceptableKeyCode(e) ) {
				return false;
			}
			this.fireEvent("editing");
		}, { buffer: 300 });
	},
	
	/**
	 * The method is invoked when the "editing" event is fired 
	 */
	"editing": function() {
		this.checkDuplicates();
	}	
});

/**
 * Class for time fields with textField value editor, and timepicker optional
 */
Runner.controls.TimeField = Runner.extend( Runner.controls.Control, {
	/**
	 * Id of type elem. Need for submit, which used on serverside
	 * @type {string}
	 */
	typeHiddId: "",
	
	/**
	 * jQuery object of type elem format hidden element, which used on serverside
	 * @type {Object} 
	 */
	typeHiddElem: null,	
	
	/**
	 * Range seconds for timepickr
	 * @type {array}
	 */
	rangeSec: [],
	
	/**
	 * @type {string}
	 */
	pageType: "",
	
	/**
	 * Overrides parent constructor
	 * @param {Object} cfg
	 * @param {bool} cfg.useDatePicker
	 */
	constructor: function(cfg) {
		Runner.controls.TimeField.superclass.constructor.call(this, cfg);	
		
		// add hidden field for date format on serverside
		this.typeHiddId = "type_" + this.goodFieldName + "_" + this.id;
		this.typeHiddElem = $("#" + this.typeHiddId);
		
		if ( this.isSetValidation('DenyDuplicated') ) {
			this.valueElem.attr('autocomplete', 'off');
		}
		
		this.imgTime = $("#trigger-test-" + this.valContId)
			.css('visibility','visible');
					
		this.assignRangeSeconds();
		this.initTimePicker();
	},

	/**
	 * Set the timepicker's seconds range
	 */		
	assignRangeSeconds: function() {
		for (var i = 0; i < 60; i++) {
			this.rangeSec[i]= i < 10 ? "0" + i : " " + i ;
		}
	},
	
	/**
	 * Set the events that will fire "edited", "editing" events
	 */	
	addEditEditingListeners: function() {		
		this.on("change", function( e, updateContext, triggered ) {
			updateContext = updateContext && typeof updateContext === "object" ? updateContext : {};
			if ( !this.imgTime.length || e === null || triggered ) {
				//the event is triggered #7845
				this.fireEvent("edited", updateContext);
			}
		});
		 
		this.on("keyup", function(e) {
			if ( !e || !Runner.isAcceptableKeyCode(e) ) {
				return false;
			}
			this.fireEvent("editing");
		});
	},
	
	/**
	 * Add to the time-image icon click handler
	 * that initializes the time picker plugin
	 *
	 * The the timepickr instance and the value picked 
	 * could be extracted form the 'valueElem' data 
	 * after the timepickr initialization:
	 * @example 
	 *	var pickerInstance = this.valueElem.data('timepickr'),
	 *		pickedValue = this.valueElem..data('timepickr.initialValue');
	 */
	initTimePicker: function() {
		var ctrl = this,
			valueElem = this.valueElem,
			initializer = function(e) {	
				var settings = Runner.pages.PageSettings.getFieldData(ctrl.table, ctrl.fieldName, 'timePick', ctrl.pageType),
					params = {
						handle: "#" + ctrl.imgTime.attr("id"),
						updateLive: false,
						trigger: 'click',
						convention: settings['convention'],
						seconds: settings['showSec'],			
						rangeMin: settings['rangeMin'],
						rangeSec: ctrl.rangeSec
					},
					picker;
					
				ctrl.imgTime.unbind("click", initializer);				
				valueElem.timepickr( params );
				picker = valueElem.data('timepickr')
				
				valueElem
					.on('keyup', function(e) {
						if ( !Runner.isAcceptableKeyCode(e) ) {
							return;
						}
						//reset the current timepickr value
						var val = valueElem.data('timepickr.initialValue');
						val.h = val.m = val.s = "";
						valueElem.data('timepickr.initialValue', val);
						
						picker.hide();
					})	
					.on('click', function() {
						var elementOffset = valueElem.offset();
        
						picker._dom.menu.css({
							'left': elementOffset.left + "px",
							'top': (elementOffset.top + valueElem.outerHeight()) + "px"
						})
					})		
				.click();
					
				//sets "dir" to the timepikr.menu div element
				picker._dom.menu.css('direction', 'ltr');
			}
			
		this.imgTime.bind("click", initializer);
	},

	destructor: function() {
		Runner.controls.TimeField.superclass.destructor.call( this );
		if ( typeof this.valueElem.timepickr === "function" ) { 
			$(".ui-timepickr").remove();
			this.valueElem.timepickr('destroy');	
		}
	},

	/**
	 * Get the tooltip position element distinct from the basic tooltip element
	 * @return {Mixed}
	 */
	getToolTipPositionElem: function() {
		return this.imgTime;
	},	
	
	/**
	 * Override addValidation
	 * @param {string} type
	 */	
	addValidation: function( type ) {
		// date field can be validated only as isRequired or DenyDuplicated
		if ( type != "IsRequired" || type != "DenyDuplicated" || this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}
		Runner.controls.TimeField.superclass.addValidation.call(this, type);
	},
	
	/**
	 * Clone html for iframe submit
	 * @method
	 * @return {array}
	 */
	getForSubmit: function() {
		return [ this.valueElem.clone(), this.typeHiddElem.clone() ];
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr true
	 * Sets hidden css style true for image "time"
	 * @method
	 */
	setDisabled: function() {
		if ( this.valueElem.length && this.imgTime ) {
			this.valueElem.get(0).disabled = true;
			this.imgTime.css('visibility','hidden');
			return true;
		}
		return false;
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr false
	 * Sets visible css style true for image "time"
	 * @method
	 */
	setEnabled: function() {
		if ( this.valueElem.length ) {
			this.valueElem.get(0).disabled = false;
			if ( !Runner.isIE ) {
				this.imgTime.css('visibility','visible');
			}
			return true;
		}
		return false;
	},
	
	makeReadonly: function() {
		Runner.controls.TimeField.superclass.makeReadonly.call( this );
		this.imgTime.hide();
		return true;
	},
	
	makeReadWrite: function() {
		Runner.controls.TimeField.superclass.makeReadWrite.call( this );
		this.imgTime.show();
		return true;
	}
});
/**
 * Common base class for rte fields
 */
Runner.controls.RTEField = Runner.extend( Runner.controls.Control, {
	/**
	 * The jQuery object representing the DOM element that will be hidden 
	 * if the control is disabled
	 * @type {object}
	 */
	controlElementToDisable: {}, 
	
	/**
	 * The jQuery object representing the DOM element that will be shown instead
	 * if the control is disabled
	 * @type {object}
 	 */
	disabledContorlElement: {},
	
	/**
	 * The storage for control's custom events listeners
	 * @type {array}
	 */
	delayedEventsHandlers: [],
	
	iframeElemId: "",
	
	iframeElem: null,

	/**
	 * Indicates used datepicker with control or not
	 * @type {bool} cfg
	 */
	useRTE: false,
	
	constructor: function( cfg ) {
		Runner.controls.RTEField.superclass.constructor.call( this, cfg );

		this.delayedEventsHandlers = [];
		this.disabledContorlElement = {};
		this.disabledControlElementId = "disabledRTE" + this.fieldName + '_' + this.id;		

		//redefine the initCustomEvents method
		this.initCustomEvents = Runner.controls.RTEField.superclass.initCustomEvents;	
	},
	
	/**
	 * The temporary stub preventing the base control's 'initCustomEvents' 
	 * method from beeing invoked from the base contructor
	 */
	initCustomEvents: Runner.emptyFn,
	
	/**
	 * Set the value element and init the iframe element
	 */
	assignValueElem: function() {
		Runner.controls.RTEField.superclass.assignValueElem.call(this);
		this.initIframeElem();	
	},
	
	initIframeElem: function() {
		if ( !this.iframeElemId ) {
			this.iframeElemId = this.valContId;
		}
		if ( !this.iframeElem ) {
			this.iframeElem = $('#' + this.iframeElemId);
		}
	},
	
	/**
	 * Override addValidation
	 * @param {string} type
	 */
	addValidation: function( type ) {
		// date field can be validated only as isRequired or DenyDuplicated
		if ( type != "IsRequired" || type != "DenyDuplicated" || this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}

		Runner.controls.RTEField.superclass.addValidation.call( this, type );
	},
	
	/**
	 * Get the control's value to submit
	 * @return {array}
	 */ 
	getForSubmit: function() {
		if ( !this.appearOnPage() ) {
			return [];
		}
		
		var clElem = $('<input type="hidden" name="' + this.iframeElemId + '">')//.clone()
				.val( this.getValue() );
				
		return [ clElem ];
	},
	
	setDisabled: function() {
		if ( !this.controlElementToDisable ) {
			return false;
		}
		
		if ( !this.disabledContorlElement.length ) {
			//create the element that will shown instead of the initial control' elements
			this.disabledContorlElement = $('<div id="' + this.disabledControlElementId + '"></div>')
				.prependTo( this.spanContElem );	
		}

		this.controlElementToDisable.hide();
		this.disabledContorlElement.html( this.getValue() ).show();
		
		return true;
	},
	
	setEnabled: function() {
		if ( !this.controlElementToDisable ) {
			return false;
		}
		
		this.controlElementToDisable.show();	
		this.disabledContorlElement.hide();
		
		return true;
	},
	
	makeReadonly: function() {
		var ctrl = this;

		if ( this.isIframeElemLoaded() ) {
			this.setDisabled();
			return;
		}
		
		this.iframeElem.bind('load', function(e) {
			ctrl.setDisabled();
		});		
	},
	
	makeReadWrite: function() {
		var ctrl = this;
		
		if ( this.isIframeElemLoaded() ) {
			this.setEnabled();
			return;
		}
		
		this.iframeElem.bind('load', function(e) {
			ctrl.setEnabled();
		});
	},
	
	/**
	 * Check if the editor's iframe is lodaded or not
	 * @return {Boolean}
	 */
	isIframeElemLoaded: function() {		
		if ( this.loadIframe ) {
			return true;
		}
		
		if ( this.isIframeLoaded( this.iframeElem ) ) {
			this.loadIframe = true;
			return true;
		}
		
		return false;
	},

	/**
	 * Check if an iframe represented by the jQuery object reference is loaded
	 * @param {jQuery element}
	 * @return {Boolean}
	 */
	isIframeLoaded: function( $iframe ) {
		if ( !$iframe.length || !$iframe.is("iframe") ) {
			return false;
		}
		
		var iframeDoc = $iframe[0].contentDocument || $iframe[0].contentWindow.document;
		return iframeDoc.readyState === 'complete';
	},
	
	/**
	 * Show if the control is disabled or not
	 * @return {Boolean}
	 */
	isDisabled: function() {
		return this.disabledContorlElement.length && this.disabledContorlElement.is(':visible');
	},
	
	/**
	 * Add the handler that is fired wheh the custom control events have been already initialized
	 * @param {string} eventName
	 * @param {function} handler
	 * @param {object} options
	 * @param {object} scope
	 */
	addDelayedCustomEvent: function( eventName, handler, options, scope ) {
		this.delayedEventsHandlers.push( {eventName: eventName, handler: handler, options: options, scope: scope} );
	},
	
	/**
	 * The method should be invoked when custom control events are initialized.
	 * It adds to the control custom events handlers
	 */	 
	addDelayedEventsListeners: function() {
		var i, data;
		
		for (i = 0; i < this.delayedEventsHandlers.length; i++) {
			data = this.delayedEventsHandlers[i]; 
			this.on( data.eventName, data.handler, data.options, data.scope );
		}
		
		this.delayedEventsHandlers = [];
	},

	/**
	 * Add events to the control's object
	 * @param {string} eventName
	 * @param {function} handler
	 * @param {object} options
	 * @param {object} scope
	 */
	on: function( eventName, fn, options, scope ) {
		if ( this.eventsAreInitialized ) {
			this.on = Runner.controls.Control.superclass.on;
			this.on( eventName, fn, options, scope );
			return;
		}
		this.addDelayedCustomEvent( eventName, fn, options, scope );
	}
});


Runner.controls.RTEInnova = Runner.extend( Runner.controls.RTEField, {
	/**
	 * The id attribute's value of the DOM element that will be shown
	 * If the control is disabled
	 * @type {String}
	 */
	disabledControlElementId: '',
	
	/**
	 * The inner iframe id
	 */
	innerIframeId: null,
	
	/**
	 * The indicator showing Id the editor's frame is loaded
	 * @type {Bolean}
	 */
	loadIframe: false,
	
	constructor: function( cfg ) {	
		Runner.controls.RTEInnova.superclass.constructor.call( this, cfg );
		
		this.useRTE = cfg.useRTE || false;
		this.controlElementToDisable = this.iframeElem;
		
		this.initControlEvents();	
	},
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */
	assignsElemsForEvent: function() {
		var bodyElem = this.getEditorBodyElem();
		this.elemsForEvent = [ bodyElem.get(0) ];
	},
	
	/**
	 * Set the control's events list
	 */	
	assignListOfEvents: function() {
		this.addEvent( ["keyup", "editing", "edited"] );
	},
	
		
	/**
	 * Set the events that will fire "edited", "editing" events
	 */
	addEditEditingListeners: function() {
		this.on("keyup", function(e) {
			if ( !e || !Runner.isAcceptableKeyCode(e) ) {
				return;
			}
			this.fireEvent("edited");
			this.fireEvent("editing");
		});
		this.addDelayedEventsListeners();
	},
	
	/**
	 * Init the contol's custom events 
	 * basing on the editor's state
	 */
	initControlEvents: function() {
		var pageObj,
			ctrl = this;
			
		if ( !this.isIframeElemLoaded() ) {
			this.iframeElem.bind('load', function(e) {
				ctrl.initCustomEvents();
				ctrl.loadIframe = true;
			});
			return;	
		}

		if ( !ctrl.getEditorBodyElem().length ) {
			//the editor's inner iframe is not loaded
			//when it's loaded the 'load' event will bubble to iframeElem
			this.iframeElem.bind('load', function(e) {
				ctrl.initCustomEvents();
			});
			return;
		}
		
		//the editor's iframe has already loaded
		pageObj = Runner.pages.PageManager.getAt(this.table, this.id);
		if ( pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			pageObj.on("windowSizeCorrected", function() {
				ctrl.initCustomEvents();
			});
			return;
		}
		
		ctrl.initCustomEvents();		
	},
	
	/**
	 * Get the body element's jQuery object from the editor's iframes hierarchy
	 * @return {object}
	 */
	getEditorBodyElem: function() {
		if ( this.useRTE !== 'INNOVA' ) {
			return this.iframeElem.contents().find( '#' + this.iframeElemId ).contents().find('body');
		}
		
		//innova editor
		if ( !this.innerIframeId ) {
			this.innerIframeId = 'idContentoEdit' + this.goodFieldName + '_' + this.id;
		}
		return this.iframeElem.contents().find( '#' + this.innerIframeId ).contents().find('body');
	},
	
	/**
	 * Get the default value if the editor's iframe is loaded
	 * or set the control's defaultValue property directly 
	 */
	setDefaultValue: function() {
		var bodyElem  = this.getEditorBodyElem(),
			editor = this;
		
		if ( this.isIframeElemLoaded() &&  bodyElem.length ) {
			//the editor's iframe has already loaded
			this.defaultValue = bodyElem.html();
		}
		
		//the RTE iframe or the inner RTE iframe is not loaded	
		this.iframeElem.bind('load', function(e) {
			var bodyElem = editor.getEditorBodyElem();
			editor.defaultValue = bodyElem.html();	
			
			editor.loadIframe = true;
		});
		
		this.defaultValue = '';
	},
	
	/**
	 * Get the control's value
	 * @return {String | Boolean}
	 */
	getValue: function() {	
		var val, jQvalDiv, bodyElem;

		if ( !this.iframeElem ) {	
			return false;
		}
		
		bodyElem = this.getEditorBodyElem();
		if ( !bodyElem.length ) {
			return false;
		}	
		
		val = this.isViewSourceModeSet() ? bodyElem.text() : bodyElem.html();
		val = val.replace(/\n/gm, "");
		
		//wrapping val with "div" helps then to get all the Dom text nodes with the jQuery text() method 	
		jQvalDiv = $('<div>' + val + '</div>');		
		if ( !jQvalDiv.find(":not(br)").length && !jQvalDiv.text().trim() ) {
			// the field value contains only "br" tags and space marks
			val = '';
		}
		
		return val;
	},
	
	/**
	 * Set the control's value 
	 * @param {String} val
	 */	
	setValue: function( val ) {
		var bodyElem,
			ctrl = this;
		
		if ( this.isIframeElemLoaded() ) {
			bodyElem = this.getEditorBodyElem();
			bodyElem.html( val );
			if ( this.isViewSourceModeSet() ) {		
				bodyElem.text( val );
			}			
			return;
		}
		
		this.iframeElem.bind('load', function(e) {
			bodyElem = ctrl.getEditorBodyElem();
			bodyElem.html( val );
			if ( this.isViewSourceModeSet() ) {		
				bodyElem.text( val );
			}	
		})
	},
	
	/**
	 * Check if the RTE in the 'View Source' mode
	 * @return {Boolean}
	 */
	isViewSourceModeSet: function() {
		return this.useRTE !== 'INNOVA' && this.iframeElem.contents().find( '#chkSrc' + this.iframeElemId ).is(':checked')
	},
	
	/**
	 * Sets focus to the element.
	 * Since focus cannot be set properly on valueElem 
	 * It scrolls the containing block so the contol's value element 
	 * can be visible within it's containing block
	 * @param {Boolean} triggerEvent
	 * @method
	 * @intellisense
	 */
	setFocus: function( triggerEvent ) {
		if ( !this.appearOnPage() || !this.showStatus || this.isDisabled() ) {
			return;
		}
		
		var ctrl = this;
		this.scrollToElem( this.valueElem );

		
		if ( this.useRTE !== 'INNOVA' ) {
			// IE10-fix #8489		
			$( this.iframeElem ).bind( 'load', function() {
				var fontOptions = ctrl.iframeElem.contents().find("#fontname_" + ctrl.iframeElemId + " option");
				//IE10-fix: font switching updates the rte state through the inline "onchage" handler invocation
				fontOptions.each( function( index, opt ) {
					var $opt = $(opt);
					if ( !$opt.prop('selected') ) {
						$opt.prop('selected', true);
						return false;
					}
				});	
			});
		}
		
		if ( triggerEvent === true ) {
			this.fireEvent("focus");
		}
	}
});

Runner.controls.RTECK = Runner.extend( Runner.controls.RTEField, {
	constructor: function( cfg ) {	
		Runner.controls.RTECK.superclass.constructor.call( this, cfg );

		this.controlElementToDisable = $("#disabledCKE_" + this.valContId);		
		this.setWidthHeight();
		
		this.initCustomEvents();
	},

	setWidthHeight: function() {
		var nWidth, nHeight;
		
		nWidth = Runner.pages.PageSettings.getFieldData( this.table, this.fieldName,'nWidth', this.pageType );
		nHeight = Runner.pages.PageSettings.getFieldData( this.table, this.fieldName,'nHeight', this.pageType );
		
		if ( this.appearOnPage() ) {
			CKEDITOR.replace( this.valContId, {"width": nWidth, "height": nHeight} );			
		}
	},

	/**
	 * Set the control's events list
	 */		
	assignListOfEvents: function() {
		this.addEvent( ["edited", "editing"] );
	},
	
	/**
	 * Set the events that will fire "edited", "editing" events
	 */
	addEditEditingListeners: function() {
		var ctrl = this,
			editor = this.getEditor();	
			
		if ( !editor ) {
			return;	
		}	
			
		editor.on('instanceReady', function() { 
			editor.document.on("keyup", function(e) {
				if ( !e || !Runner.isAcceptableKeyCode(e) ) {
					return;
				}			
				ctrl.fireEvent("editing");
			});
		});	

		editor.on("blur", function(e) {	
			ctrl.fireEvent("edited");
		});
		
		this.addDelayedEventsListeners();
	},	
	
	getEditor: function() {
		if ( !window.CKEDITOR ) {
			return false;			
		}
		if ( typeof window.CKEDITOR.instances[ this.valContId ] === 'undefined' ) {
			return false;	
		}
		return window.CKEDITOR.instances[ this.valContId ];
	},
	
	destructor: function() {
		var editor = this.getEditor();
		if ( editor !== false ) {
			CKEDITOR.remove( editor );
		}		
	},
	
	getValue: function() {
		var editor = this.getEditor();
		
		if ( !editor ) {
			return false;	
		}
		return editor.getData();
	},
	
	setValue: function( val ) {
		var editor = this.getEditor();
		
		if ( !editor ) {
			return false;	
		}
		editor.setData( val );
		return true;	
	},
	
	/**
	 * Initialize the control's tooltip
	 * @param {string} text
	 * @param {object} pageObj		The page's object reference	
	 */	
	initToolTip: function( text, pageObj ) {		
		if ( this.mode === Runner.controls.constants.MODE_SEARCH || !this.spanContElem.length ) {
			return;
		}
		
		this.spanContElem.addClass('titleHintBox').inputHintBox({
			div: $('#shiny_box'), 
			div_sub: '.shiny_box_body', 
			html: text, 
			isFly: pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP
		});
		
		this.initToolTip = Runner.emptyFn;	
	},
	
	makeReadonly: function() {
		this.setDisabled();
	},
	
	makeReadWrite: function() {
		this.setEnabled();
	},
	
	/**
	 * Set focus on the editor's element
	 */
	setFocusOnEditor: function() {
		var ctrl = this,
			editor = this.getEditor();
			
		if ( !editor ) {
			return false;
		}
		
		if ( !editor.container ) {
			editor.on('instanceReady', function() { 
				editor.focus();
				ctrl.scrollToElem( $(editor.container.$) );
			});
			return;	
		}
		
		editor.focus();
		this.scrollToElem( $(editor.container.$) );
	},
	
	/**
	 * Sets focus to the element.
	 * @method
	 * @return {boolean}
	 * @intellisense
	 */
	setFocus: function( triggerEvent ) {
		var pageObj,
			ctrl = this;
		
		if ( !this.appearOnPage() || !this.showStatus || this.isDisabled() ) {
			return false;
		}
			
		pageObj = Runner.pages.PageManager.getAt( this.table, this.id );
		if ( pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			pageObj.on("windowSizeCorrected", function() {
				ctrl.setFocusOnEditor();
			});
		}
	
		this.setFocusOnEditor();
		
		if ( triggerEvent === true ) {
			this.fireEvent("focus");
		}
		
		return true;
	}	
});
/**
 * Base abstract class for all file controls. Should not be created directly.
 * @requires Runner.controls.Control
 * @class Runner.controls.FileControl
 */
Runner.controls.FileControl = Runner.extend( Runner.controls.Control, {
	/**
	 * Radio DOM elem id
	 * @type {string} 
	 */
	radioElemsName: "",
	/**
	 * Radio jQuery obj
	 * @type {Object} 
	 */
	radioElems: null,
	/**
	 * Is control empty or not
	 * @type {Object} 
	 */
	notEmptyCntrl: 0,
	
	/**
	 * Override parent contructor
	 * @constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {
		this.radioElems = {};

		Runner.controls.FileControl.superclass.constructor.call(this, cfg);	
		
		var notEmpty = $("#notempty_"+this.goodFieldName+"_"+this.id);
		this.notEmptyCntrl = parseInt( $(notEmpty).val() );
	},

	/**
	* Set the value element
	*/	
	assignValueElem: function() {
		Runner.controls.FileControl.superclass.assignValueElem.call(this);
		
		this.radioElemsName = "type_" + this.goodFieldName + "_" + this.id;
		// for ASP version in inline add mode, there are no radios, but one input type hidden
		if ( $('#' + this.radioElemsName).length ) {
			this.getChekedRadio = function() {
				return false;
			}
		}
		// add radio DOM elem ID,
		this.getRadioControls();
	},

	/**
	* Set the DOM elements for the custom listeners usage
	*/	
	assignListOfEvents: function() {
		this.addEvent(["change", "click", "edited", "editing"]);
	},
	
	/**
	 * Add change event base handler
	 * @param {Object} e
	 */
	"change": function(e) {
		// stop event
		this.stopEvent(e);
		// set radio button to update
		this.changeRadio("updateRadio");
	},
	
	/**
	 * Radio buttons switcher. Call when need change radio
	 * @param {string} radioToCheck Name of radio button.
	 */
	changeRadio: function(radioToCheck) {
		for (var radio in this.radioElems) {
			// if exists radio button
			if (radio == radioToCheck && this.radioElems[radio]!=false) {
				this.radioElems[radio].elem.get(0).checked = true;
				this.radioElems[radio].cheked = true;
			// if not exists return false
			} else if (radio == radioToCheck && this.radioElems[radio]==false) {
				return false;
			// switch other radios	
			} else if (this.radioElems[radio]!=false) {
				this.radioElems[radio].elem.get(0).checked = false;
				this.radioElems[radio].cheked = false;
			}
		}
		// in success
		return true;
	},
	
	/**
	 * Get object which contains radio elems
	 * @method
	 */
	getRadioControls: function() {
		var keepRadio = $('#'+this.radioElemsName+'_keep'),
			deleteRadio = $('#'+this.radioElemsName+'_delete'),
			updateRadio = $('#'+this.radioElemsName+'_update'),		
			ctrl = this;
		
		keepRadio.bind('click', function(e) {
			ctrl.changeRadio('keepRadio');
		});
		deleteRadio.bind('click', function(e) {
			ctrl.changeRadio('deleteRadio');
		});
		updateRadio.bind('click', function(e) {
			ctrl.changeRadio('updateRadio');
		});
		// create radioElems obj
		this.radioElems["keepRadio"] = keepRadio.length ? {elem: keepRadio, cheked: true} : false;		
		this.radioElems["deleteRadio"] = deleteRadio.length ? {elem: deleteRadio, cheked: false} : false;
		this.radioElems["updateRadio"] = updateRadio.length ? {elem: updateRadio, cheked: false} : false;
	},
	
	/**
	 * Return name of cheked radio
	 * @return {string}
	 */
	getChekedRadio: function() {
		for (var radio in this.radioElems) {
			if (this.radioElems[radio]!=false && this.radioElems[radio].cheked === true) {
				return radio;
			}
		}
		return false;
	},
	
	validate: function(valArr) {		
		if ( this.notEmptyCntrl && (this.mode == Runner.pages.constants.PAGE_EDIT || this.mode == Runner.pages.constants.PAGE_INLINE_EDIT) ) {
			return Runner.validation.getTrueValidationResult();
		}
		
		return Runner.controls.FileControl.superclass.validate.call(this, valArr);
	},

	/**
	 * Returns array of jQuery object for inline submit
	 * @return {array}
	 */
	getForSubmit: function() {
		// array of fileValue, and cheked radio
		var radio = this.getChekedRadio();
		var cloneArr = [];
		// make real clone of radio, to prevent troubles in IE
		if (radio) {
			var radioClone = document.createElement('input');
			$(radioClone).attr('type', 'hidden');
			$(radioClone).attr('id', this.radioElems[radio].elem.attr('id'));
			$(radioClone).attr('name', this.radioElems[radio].elem.attr('name'));
			$(radioClone).val(this.radioElems[radio].elem.val());
			cloneArr.push($(radioClone));
		// for ASP version in inline add mode, there are no radios, but one input type hidden
		} else if ($('#'+this.radioElemsName).length) {
			cloneArr.push($('#'+this.radioElemsName));
		}
		// add real file elem
		var realFile = this.valueElem;
		var clone = this.valueElem.clone(true);
		clone.insertAfter(realFile); 
		cloneArr.push(realFile);
		this.valueElem = clone;
		return cloneArr;
	},
	
	makeReadonly: function() {
		this.valueElem.attr('disabled',true);
		if (this.radioElems.keepRadio) {
			this.radioElems.keepRadio.elem.attr('disabled',true);
		}	
		if (this.radioElems.updateRadio) {
			this.radioElems.updateRadio.elem.attr('disabled',true);
		}	
		if (this.radioElems.deleteRadio) {
			this.radioElems.deleteRadio.elem.attr('disabled',true);
		}	
		return true;
	},
	
	makeReadWrite: function() {
		this.valueElem.attr('disabled', false);
		if (this.radioElems.keepRadio) {
			this.radioElems.keepRadio.elem.attr('disabled',false);
		}	
		if (this.radioElems.updateRadio) {
			this.radioElems.updateRadio.elem.attr('disabled',false);
		}	
		if (this.radioElems.deleteRadio) {
			this.radioElems.deleteRadio.elem.attr('disabled',false);
		}	
		return true;
	},	
	
	/**
	 * Checks if control value is empty. Used for isRequired validation
	 * For files has specific criterias
	 * @override
	 * @method
	 * @return {bool}
	 */
	isEmpty: function() {
		if (this.mode == Runner.pages.constants.PAGE_EDIT || this.mode == Runner.pages.constants.PAGE_INLINE_EDIT) {
			if (this.notEmptyCntrl) {
				return false;
			} else {
				if (typeof(this.fileNameElem) != 'undefined' && this.fileNameElem) {
					if (this.fileNameElem.get(0).value == '') {
						this.fileNameElem.get(0).value = this.fileNameElem.get(0).defaultValue;
					}
				}
				return (this.radioElems["keepRadio"].cheked === true || this.getValue().toString() == "" || this.radioElems["updateRadio"].cheked === false)
			}
		} else {
			if (typeof(this.fileNameElem) != 'undefined' && this.fileNameElem) {
				if (!(this.getValue().toString() == "") && (this.fileNameElem.get(0).value == ''))
					this.fileNameElem.get(0).value = this.fileNameElem.get(0).defaultValue;
			}
			return (this.getValue().toString() == "")
		}
	},
	
	/**
	 * Set to radio buttons default value 
	 */
	resetRadio: function() {
		for (var radio in this.radioElems) {
			// if exists radio button
			if (this.radioElems[radio]!=false) {
				this.radioElems[radio].elem.get(0).checked = this.radioElems[radio].elem.get(0).defaultChecked;
				this.radioElems[radio].cheked = this.radioElems[radio].elem.get(0).defaultChecked;
			}
		}
	}
});

/**
 * Class for image field controls.
 * @requires Runner.controls.FileControl
 * @class Runner.controls.ImageField
 */
Runner.controls.ImageField = Runner.extend( Runner.controls.FileControl, {
	
	imgElem: null,
	
	/**
	 * Override parent contructor
	 * @constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {
		Runner.controls.ImageField.superclass.constructor.call(this, cfg);		
	},
	
	/**
	* Set the value element
	*/	
	assignValueElem: function() {
		Runner.controls.ImageField.superclass.assignValueElem.call(this);
		
		this.imgElemId = "image_" + this.goodFieldName + "_" + this.id;	
		this.imgElem = $("#" + this.imgElemId);
	},
	
	setValue: function(val, triggerEvent, updContext) {
		var src = $(val).attr('src');
		if (src) {
			this.imgElem.attr('src', (src + "&rndVal=" + Math.random()) );
			return;	
		}
		
		Runner.controls.ImageField.superclass.setValue.call(this, val, triggerEvent, updContext);
		if (updContext && updContext.resetHappend) {
			this.resetRadio();
		}
	}
});

/**
 * Class for file field controls. For images use Runner.controls.ImageField
 * @requires Runner.controls.FileControl
 * @class Runner.controls.FileField
 */
Runner.controls.FileField = Runner.extend( Runner.controls.FileControl, {
	/**
	 * Indicates if need to add timeStamp to fileName
	 * @type {bool} 
	 */
	addTimeStamp: false,
	/**
	 * ID of filename elem
	 * @type {string}
	 */
	fileNameElemId: "",
	/**
	 * Filename textfield jQuery object
	 * @param {Object} 
	 */
	fileNameElem: null,
	/**
	 * ID of hidden fileName DOM elem
	 * @type String
	 */
	fileHiddElemId: "",
	/**
	 * jQuery object of hidden fileName DOM elem
	 * @type {object} 
	 */
	fileHiddElem: null,	
	/**
	 * Override parent contructor
	 * @constructor
	 * @param {Object} cfg
	 * @param {bool} cfg.addTimeStamp
	 */
	constructor: function(cfg) {
		Runner.controls.FileField.superclass.constructor.call(this, cfg);

		// add fileName hidden DOM elem
		this.fileHiddElemId = "filenameHidden_"+this.goodFieldName+"_"+this.id;	
		this.fileHiddElem = $("#"+this.fileHiddElemId).length ? $("#"+this.fileHiddElemId) : null;

		// add radio buttons style switchers
		for (var radio in this.radioElems) {
			// if exists radio	
			if (this.radioElems[radio]) {
				// create closure event handler
				var objScope = this;
				// add handler
				this.radioElems[radio].elem.bind('click', function(e) {
					// get name of radio object
					var radioTypeStartFrom = this.id.lastIndexOf('_');
					var radioTypeName = this.id.substring(radioTypeStartFrom+1)+'Radio';
					// change styles
					objScope.changeControlsStyles(radioTypeName);
				});
			}
		}
		
		setTimeout(function() {
			var zoomboxes = $('.zoombox');
			if (zoomboxes.length)
				zoomboxes.zoombox({
					theme: 'zoombox', opacity: 0.8,
					duration: 400, animation: false,
					gallery: false, autoplay : false
				});
		}, 10);
	},
		
	/**
	* Set the value element
	*/
	assignValueElem: function() {
		Runner.controls.FileField.superclass.assignValueElem.call(this);
		// add fileName DOM elem	
		this.fileNameElemId = "filename_"+this.goodFieldName + "_" + this.id;	
		this.fileNameElem = $("#" + this.fileNameElemId).length ? $("#" + this.fileNameElemId) : null; 
		//timeStamp to fileName indicator
		this.addTimeStamp = this.addTimeStamp || Runner.pages.PageSettings.getFieldData(this.table, this.fieldName, 'isUseTimeStamp', this.pageType);
	},
	
	/**
	 * Override addValidation
	 * @method
	 * @param {string} type
	 */
	addValidation: function(type) {
		// date field can be validated only as isRequired or DenyDuplicated
		if ( type != "IsRequired" || type != "DenyDuplicated" || this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}
		// call parent
		Runner.controls.FileField.superclass.addValidation.call(this, type);
	},
	/**
	 * Cuts name of file from path
	 * @param {string} path
	 * @return {string}
	 */
	getFileNameFromPath: function(path) {
		var wpos=path.lastIndexOf('\\'); 
		var upos=path.lastIndexOf('/'); 
		var pos=wpos; 
		if (upos>wpos)
			pos=upos; 
		return path.substr(pos+1);
	},
	/**
	 * Override setValue function, for files need to change radio control status
	 * @method
	 * @param {file} val
	 */
	setValue: function(val, triggerEvent, updContext) {
		var valWithStamp = "", 
			fileName = "";
		// if need to get filename without path
		if (this.fileNameElem != null || this.addTimeStamp) {
			fileName = this.getFileNameFromPath(this.valueElem.val());
		}
		// add timestamp if needed
		if (this.addTimeStamp) {
			var valWithStamp = this.addTimestamp(fileName);
		}
		// if name element exists, set new value
		if (this.fileNameElem != null) {
			this.fileNameElem.val(valWithStamp || fileName);
			this.fileNameElem.get(0).defaultValue = (valWithStamp || fileName);
		}
		//check if 
		if (updContext && updContext.resetHappend) {
			this.valueElem.val(updContext.values[this.fieldName]);
			if (this.fileNameElem != null) {
				this.fileNameElem.val(this.fileNameElem.get(0).defaultValue);
			}
			this.resetRadio();
		}
		
		if (triggerEvent===true) {
			this.fireEvent("change", updContext);
		}
	},
	
	/**
	 * Add timestap to file name
	 * @param {string} file name
	 * @return {string}
	 */
	addTimestamp: function(filename) {
		var wpos = filename.lastIndexOf('.');
		if (wpos<0) {
			return filename+'-'+this.getTimestamp();
		}	
		return filename.substring(0,wpos)+'-'+this.getTimestamp()+filename.substring(wpos);
	},
	
	/**
	 * Get timestap
	 * @return {string}
	 */
	getTimestamp: function() {
		var ts = "", now = new Date();
		ts += now.getFullYear();
		ts += this.padDateValue(now.getMonth()+1, false);
		ts += this.padDateValue(now.getDate(), false)+'-';
		ts += this.padDateValue(now.getHours(), false);
		ts += this.padDateValue(now.getMinutes(), false);
		ts += this.padDateValue(now.getSeconds(), false);
		return ts;
	},
	
	/**
	 * Pad date value
	 * @param {integer} value of date 
	 * @param {boolean} use three-digits or not
	 * @return {string}
	 */
	padDateValue: function(value,threedigits) {
		if (!threedigits) {
			if (value>9) {
				return ''+value;
			}
			return '0'+value;
		}
		if (value>9) {
			if (value>99) {
				return ''+value;
			}	
			return '0'+value;
		}
		return '00'+value;
	},
	
	/**
	 * Change file value event handler. 
	 * Changes radio to update, validates, and change fileName if file pass validation
	 * @method
	 * @param {Object} e
	 */
	"change": function(e) {
		this.stopEvent(e);
		var vRes = null;
		if (!arguments[1] || !arguments[1].resetHappend) {
			this.changeRadio("updateRadio");
			vRes = this.validate();
			if (vRes.result) {
				var vl = this.getValue();
				this.setValue(vl, false);
			}
		}
		else
			vRes = this.validate();
	},
	
	/**
	* The custom event "edited" is fired after the control is edited
	* @param {object} nullEvent		Equals to null if function is invoked 
	* with the fireEvent method
	* @param {object} updateContext
	*/
	"edited":  function(eNull, updateContext) {
	},
	
	/**
	 * Override radio buttons switcher, add call change styles method
	 * @param {string} radioToCheck
	 */
	changeRadio: function(radioToCheck) {
		// change styles
		this.changeControlsStyles(radioToCheck);
		// call parent
		Runner.controls.FileField.superclass.changeRadio.call(this, radioToCheck);
	},
	/**
	 * Change styles and set disabled filename field
	 * @param {Object} radioToCheck
	 */
	changeControlsStyles: function(radioToCheck) {
		// if such radio button defined
		if (!this.radioElems[radioToCheck]) {
			return false;
		}
		// if there is filename that need to be changed
		if (this.fileNameElem == null) {
			return false;
		}
		// if choosed delete
		if (radioToCheck == "deleteRadio") {
			this.fileNameElem.css('backgroundColor','gainsboro');
			this.fileNameElem[0].disabled=true;
			return true;
		// if choosed update or keep
		}
		if (radioToCheck == "updateRadio" || radioToCheck == "keepRadio") {
			this.fileNameElem.css('backgroundColor','white');
			this.fileNameElem[0].disabled=false;
			return true;
		// in other way return false
		}
		return false;
	},
	
	/**

	 * Get fileName from fileName type text elem.
	 * @return {string}
	 */
	getFileName: function() {
		if (this.fileHiddElem) {
			return this.fileHiddElem.val();
		} else {
			return false;
		}
	},
	/**
	 * Set fileName to fileName type text elem.
	 * @param {string} fileName
	 * @return {Boolean}
	 */
	setFileName: function(fileName) {
		if (this.fileHiddElem) {
			this.fileHiddElem.val(fileName);
			return true;
		} else {
			return false;
		}
	},
	/**
	 * Returns array of jQuery object for inline submit
	 * @return {array}
	 */
	getForSubmit: function() {
		var cloneArr = Runner.controls.ImageField.superclass.getForSubmit.call(this);	
		if (this.fileNameElem) {
			cloneArr.push(this.fileNameElem.clone());
		}
		if (this.fileHiddElem) {
			cloneArr.push(this.fileHiddElem.clone());
		}
		return cloneArr;
	}	
});

/**
 * Class for multiple file field controls.
 * @requires Runner.controls.Control
 * @class Runner.controls.MultiUploadField
 */
Runner.controls.MultiUploadField = Runner.extend( Runner.controls.Control, {
	/**
	 * From object for files upload
	 * @type {jQuery object}
	 */
	uploadForm: null,
	
	fileArray: null,
	
	autoUpload: false,
	
	maxFileSize: undefined,
	
	maxTotalFilesSize: undefined,
	
	maxNumberOfFiles: undefined,
	
	acceptFileTypes: undefined,
	
	isInline: false,
	
	/**
	 * Indicator whether an error happend during an upload  
	 */
	errorHappened: false,
	
	/**
	 * Indicator whether an error happend during add file  
	 */
	errorHappenedOnAdd: false, 
	
	/**
	 * Count of files which are waiting for upload
	 */
	filesToUploadCount: 0,
	
	/**
	 * Override parent contructor
	 * @constructor
	 * @param {Object} cfg
	 */
	constructor: function(cfg) {
		Runner.controls.MultiUploadField.superclass.constructor.call(this, cfg);
		this.initTemplates();
	},

	/**
	* Set the control's events list
	*/
	assignListOfEvents: function() {
		this.addEvent(["click", "change", "edited", "editing"]);
	},
	
	initTemplates: function() {
		this.uploadForm = $("#fileupload_" + this.goodFieldName + "_" + this.id);
		
		var $buttonAddFiles = $( ".filesUpload", this.uploadForm[0] ),
			$fileInput = $( "input.fileinput-button-input", this.uploadForm[0] ),
			buttonPos = Runner.util.getHiddenDimensions( $buttonAddFiles );
		
		$buttonAddFiles.css("position", "relative");
		$fileInput.css( {
			"left": 0,
			"top": 0,
			"width": buttonPos.outerWidth + "px",
			"height": buttonPos.outerHeight + "px"
		});
		
		this.fileArray = $("#value_" + this.goodFieldName + "_" + this.id);
		this.uploadForm[0].action += "?table=" + encodeURIComponent(this.table) + "&field=" + encodeURIComponent(this.fieldName) + "&pageType=" + this.pageType
			+ "&formStamp=" + $("#formStamp_" + this.goodFieldName + "_" + this.id, this.uploadForm).val();
		this.uploadForm.fileupload();
		this.uploadForm.fileupload("option", {
			autoUpload: this.autoUpload,
			acceptFileTypes: new RegExp(this.acceptFileTypes, "i"),
			dropZone: this.uploadForm,
			maxFileSize: this.maxFileSize,
			maxTotalFilesSize: this.maxTotalFilesSize,
			maxNumberOfFiles: this.maxNumberOfFiles != 0 ? this.maxNumberOfFiles - $.parseJSON(this.fileArray.val()).length 
					: 0,
			constMaxNumberOfFiles: this.maxNumberOfFiles
		});

    	var control = this, 
			controlId = this.goodFieldName + "_" + this.id;
    	
	    // Load existing files:
    	this.reloadFiles();
    	
    	this.showDropZone();

    	this.uploadForm.bind('fileuploadadded', function(e, data) {
    		if (Runner.isGecko) {
    			$('input[name="focusDummy"]', control.uploadForm[0]).focus();
   			}
			control.hideDropZone();
   			if (data.files) {
	   			if (!data.files[0].error) {
	   				control.filesToUploadCount++;
				} else {
	   				control.errorHappenedOnAdd = true;
				}
   			}
    		control.uploadForm.fileupload('setUploadAndCancelButtonState', control.filesToUploadCount > 0);
    		control.fireEvent('change');
    	});
    	this.uploadForm.bind('fileuploaddone', function(e, data) {
    		if (control.filesToUploadCount > 0) {
    			control.filesToUploadCount--;
			}
    		control.uploadForm.fileupload('setUploadAndCancelButtonState', control.filesToUploadCount > 0);
    		if (data.textStatus != 'success' || !data.result || data.result.length == 0) {
    			control.errorHappened = true;
    			return;
    		}
			if (!data.result[0].error) {
				var fileArray = $.parseJSON(control.fileArray.val()), newFile = data.result[0];
				newFile.isNew = true; 
				fileArray.push(newFile)
				control.uploadForm.fileupload('setDeleteButtonState', fileArray.length > 0);
				control.fileArray.val(JSON.stringify(fileArray));
			} else {
    			control.errorHappened = true;			
			}
			control.clearInvalid();
    	});
    	this.uploadForm.bind('fileuploadfail', function(e, data) {
    		if (control.filesToUploadCount > 0) {
    			control.filesToUploadCount--;
			}
    		control.uploadForm.fileupload('setUploadAndCancelButtonState', control.filesToUploadCount > 0);
    		control.showDropZone();
    	});
    	this.uploadForm.bind('fileuploaddestroyed', function(e, data) {
			var fileArray = $.parseJSON(control.fileArray.val()), newFileArray = [];
			$.each(fileArray, function(index, element) {
				if (element.name != data.name)
					newFileArray.push(element);
			});
			control.uploadForm.fileupload('setDeleteButtonState', newFileArray.length > 0);
			control.fileArray.val(JSON.stringify(newFileArray));
			control.showDropZone();
			control.fireEvent('change');
	    });
    	
    	this.uploadForm.fileupload({
    	    destroy: function(e, data) {
	            var that = $(this).data('fileupload'), button = $(data.context.context),
	            	data = {
	            		context: button.closest('.template-download'),
	                    url: e.data.fileupload.element[0].action,
	                    type: 'POST',
	                    dataType: e.data.fileupload.options.dataType,
	                    name: button.attr('data-name'),
	                    data: {
	            			_action: "DELETE",
	            			fileName: button.attr('data-name')
	            		}
	            };
                $.ajax(data);
                that._adjustMaxNumberOfFiles(1);
	            that._transition(data.context).done(
	                function() {
	                    $(this).remove();
	                    that._trigger('destroyed', e, data);
	                }
	            );
            }
    	});
	},
	
	/**
	 * Check if the browser supports drag-n-drop and File Api 
	 * It's used as a feature detection to test if It's possible 
	 * to upload files using drag-and-drop
	 * @return {Boolean}
	 */
	isFileApiSupported: function() {
		var div = document.createElement('div');
		return !!window.FileReader && ( 'draggable' in div || ('ondragstart' in div && 'ondrop' in div) );
	},
	
	hideDropZone: function() {
		if ( (this.errorHappenedOnAdd || this.filesToUploadCount == 0) && this.isFileApiSupported() && !Runner.isMobile ) {
			var fileProgresDiv = $(".fileupload-progress", this.uploadForm);
			if ( fileProgresDiv.hasClass("rnr-dragndrop-area") ) {
	    		fileProgresDiv.removeClass("rnr-dragndrop-area").children(".rnr-dragtext").remove();
				fileProgresDiv.show();
			} else {
				fileProgresDiv.hide();
			}
		}
	},
	
	showDropZone: function() {
		if ( !this.errorHappenedOnAdd && $.parseJSON( this.fileArray.val() ).length == 0 && this.filesToUploadCount == 0 && this.isFileApiSupported() && !Runner.isMobile ) {
			var progressEl = $(".fileupload-progress", this.uploadForm),
				preventFunction = function(event) {
				if (event) {
					event.originalEvent.dataTransfer.dropEffect='none'; 
					event.stopPropagation(); 
					event.preventDefault();
				}
				return false;
			};
			
			progressEl.show();
			if ( !progressEl.hasClass("rnr-dragndrop-area") ) {
				progressEl.addClass("rnr-dragndrop-area").prepend('<div class="rnr-dragtext">' + Runner.lang.constants.UPLOAD_DRAG + '</div>');
			}
			
			$(document).unbind("drop.multiupload")
				.unbind("dragenter.multiupload")
				.unbind("dragleave.multiupload")
				.unbind("dragstart.multiupload")
				.on("drop.multiupload", function() {
					return false; 
				})
				.on("dragenter.multiupload", preventFunction)
				.on("dragover.multiupload", preventFunction)
				.on("dragstart.multiupload", preventFunction);
		} else {
    		this.hideDropZone();
    	}
	},
	
    // Load existing files:
	reloadFiles: function() {
		var initialFileArray = $.parseJSON(this.fileArray.val());
		this.uploadForm.fileupload("option", {
			maxNumberOfFiles: this.maxNumberOfFiles != 0 ? this.maxNumberOfFiles - initialFileArray.length 
					: 0
		});
    	this.uploadForm.fileupload('option', 'done').call(this.uploadForm, null, {result: initialFileArray});
		this.uploadForm.fileupload('refreshMaxFilesState');
    	this.uploadForm.fileupload('setDeleteButtonState', initialFileArray.length > 0);
    	this.uploadForm.fileupload('setUploadAndCancelButtonState', this.filesToUploadCount > 0);
    	
    	return initialFileArray.length;
	},
	
	/**
	 * Set the default value to the control
	 * @param {object} updContext
	 */
	reset: function( updContext ) {
		this.setValue(this.defaultValue, true, updContext);
		this.clearInvalid();
		this.filesToUploadCount = 0;
		$('table tbody', this.uploadForm).empty();
		this.reloadFiles();
		this.showDropZone();
	},
	
	/**
	 * Add change event base handler
	 * @param {Object} e
	 */
	"change": function(e) {
		// stop event
		this.stopEvent(e);
	},

	/**
	 * Returns array of jQuery object for inline submit
	 * @return {array}
	 */
	getForSubmit: function() {
		var cloneArr = [];
		cloneArr.push(this.valueElem.clone());
		cloneArr.push($("#formStamp_" + this.goodFieldName + "_" + this.id, this.uploadForm).clone());
		return cloneArr;
	},
	
	/**
	 * Sets disable attr true
	 * @return {boolean}
	 */
	setDisabled: function() {
		return this.makeReadonly();
	},
	
	/**
	 * Sets disaqble attr false
	 * @return {boolean}
	 */
	setEnabled: function() {
		return this.makeReadWrite();
	},
	
	makeReadonly: function() {
		this.valueElem.prop('disable', true);
		this.uploadForm.fileupload('setDeleteButtonState', false);
		$(".fileupload-buttonbar", this.uploadForm).hide();
		return true;
	},
	
	makeReadWrite: function() {
		this.valueElem.prop('disable', false);
		this.uploadForm.fileupload('setDeleteButtonState', true);
		$(".fileupload-buttonbar", this.uploadForm).show();
		return true;
	},	
	
	/**
	 * Checks if control value is empty. Used for isRequired validation
	 * For files has specific criterias
	 * @override
	 * @method
	 * @return {bool}
	 */
	isEmpty: function() {
		return this.getValue().toString() == "" || this.getValue().toString() == "[]";
	},
	
	/**
	 * Sets focus to the element.
	 * Since focus cannot be set properly on valueElem 
	 * It sets focus on the "Add files" button so the contol's value element 
	 * can be visible within it's containing block.
	 * @param {Boolean} triggerEvent
	 * @method
	 * @intellisense
	 */
	setFocus: function( triggerEvent ) {
		var addButtonElem = $(".fileinput-button-input", this.uploadForm);
		
		if ( !this.appearOnPage() || !this.showStatus || this.valueElem.is("disabled") || !addButtonElem.length ) {
			return;
		}
	
		addButtonElem.focus();
		
		if (triggerEvent === true) {
			this.fireEvent("focus");
		}
	}, 
	
	/**
	 * Get the tooltip position element distinct from the basic tooltip element
	 * @return {Mixed}	 
	 */	
	getToolTipPositionElem: function() {
		return this.uploadForm;
	}	
});

/**
 * Abstract base class for date fields, should not created directly
 * @class Runner.controls.DateField
 */
Runner.controls.DateField = Runner.extend( Runner.controls.Control, {
	/**
	 * Id of hidden elem, which used by datepicker
	 * @type {string} 
	 */
	datePickerHiddId: "",
	/**
	 * Hidden elem, which used by datepicker
	 * ts element
	 * @type {element} 
	 */
	datePickerHiddElem: null,
	/**
	 * Image and link of datepicker
	 * link element
	 * @type {element} 
	 */
	imgCal: null,
	/**
	 * Indicates used datepicker with control or not
	 * @type {bool} cfg
	 */
	useDatePicker: false,
	/**
	 * Id of date format hidden element, which used on serverside
	 * @type {string}
	 */
	dateFormatHiddId: "",
	/**
	 * Indicates date format with control or not
	 * @type {bool} cfg
	 */
	dateFormat: "",
	/**
	 * Indicates show time with control or not
	 * @type {bool} cfg
	 */
	showTime: false,
	/**
	 * jQuery object of date format hidden element, which used on serverside
	 * @type {Object} 
	 */
	dateFormatHiddElem: null,
	
	dataPicker: null,
	
	timeBox: null,
	
	dateDelimiter: "/",
	
	startWeekDay: 0,
	
	/**
	 * Array of month names
	 * @type {array}
	 */
	monthNames: [
		Runner.lang.constants.TEXT_MONTH_JAN,
		Runner.lang.constants.TEXT_MONTH_FEB,
		Runner.lang.constants.TEXT_MONTH_MAR,
		Runner.lang.constants.TEXT_MONTH_APR,
		Runner.lang.constants.TEXT_MONTH_MAY,
		Runner.lang.constants.TEXT_MONTH_JUN,
		Runner.lang.constants.TEXT_MONTH_JUL,
		Runner.lang.constants.TEXT_MONTH_AUG,
		Runner.lang.constants.TEXT_MONTH_SEP,
		Runner.lang.constants.TEXT_MONTH_OCT,
		Runner.lang.constants.TEXT_MONTH_NOV,
		Runner.lang.constants.TEXT_MONTH_DEC
	],
	
	/**
	 * Array of day names
	 * @type {array}
	 */
	dayNames: [
		Runner.lang.constants.TEXT_DAY_SU,
		Runner.lang.constants.TEXT_DAY_MO,
		Runner.lang.constants.TEXT_DAY_TU,
		Runner.lang.constants.TEXT_DAY_WE,
		Runner.lang.constants.TEXT_DAY_TH,
		Runner.lang.constants.TEXT_DAY_FR,
		Runner.lang.constants.TEXT_DAY_SA
	],
	
	/**
	 * The YUI or JQuery calendar object depending on what
	 * type of the date picker is used
	 */
	calendar: null,
	
	/**
	 * Overrides parent constructor
	 * @param {Object} cfg
	 * @param {bool} cfg.useDatePicker
	 */
	constructor: function( cfg ) {
		Runner.controls.DateField.superclass.constructor.call(this, cfg);
			
		// add hidden field for datepicker usege
		this.useDatePicker = cfg.useDatePicker || false;
		this.useYuiDatePicker = cfg.useYuiDatePicker || false;
		this.usejQueryDatePicker = cfg.usejQueryDatePicker || false;
		

		this.dateDelimiter = Runner.pages.PageSettings.getGlobalData("locale")["dateDelimiter"];
		this.startWeekDay = ( parseInt( Runner.pages.PageSettings.getGlobalData("locale").startWeekDay ) + 1 ) % 7;
		this.showTime = Runner.pages.PageSettings.getFieldData(this.table, this.fieldName, "showTime", this.pageType);
		
		// add hidden field for date format on serverside
		this.dateFormatHiddId = "type" + (cfg.ctrlInd || "") + "_" + this.goodFieldName + "_" + this.id;
		this.dateFormatHiddElem = $("#" + this.dateFormatHiddId);	
		
		this.initjQueryDatePicker();
		this.initYUIDatePicker();
	},
		
	/**
	 * Init jQuery DatePicker + TimePicker
	 */
	initjQueryDatePicker: function() {
		if ( !this.usejQueryDatePicker ) {
			return;
		}
				
		var ctrl = this,
			options = this.getjQueryDatePickerDaseOptions(),
			imageCallId, datePickerId, imgCalClickHandler, documentClickHandler, 
			datePickerInstance,	calendarAreaClick, currentValue;
	
		this.patchjQueryUIDatepickerTodayHandler();
	
		if ( this.dateEditType === Runner.controls.constants.EDIT_DATE_SIMPLE_INLINE ) { 		
			options.onBeforeShowHandler = function(input, inst) {
				// clear the control if the date is incorrect
				!ctrl.getValue() && ctrl.setValue('');	
			};
			options.onSelectHandler = function(dt, inst, isTimepicker) {
				if (!isTimepicker) {
					$( inst.input ).datepicker('hide');
				}
				ctrl.setValue( dt + " " + ctrl.printTime( currentValue ), true );
			};

			this.valueElem.datepicker( options );
			datePickerInstance = this.valueElem.data("datepicker");
			// replace _possibleChars method on instance to allow to input time
			datePickerInstance._possibleChars = function( format ) {
				var chars = $.datepicker._possibleChars( format );
				return chars + " :";
			}
			
			//add the 'rnr-datepicker' class to the datepicker instance div
			datePickerInstance.dpDiv.addClass('rnr-datepicker');
				
			//open the datepicker on the control's click
			this.valueElem
				.unbind("focus", $.datepicker._showDatepicker)
				.on("focus", function(e) {
					if ( !ctrl.invalid() ) {
						$.datepicker._showDatepicker(e);
						currentValue = ctrl.getValue();
					}
				})
				.on("click", function(e) {
					var position = $.datepicker._findPos( this ),
						offset = { left: position[0], top: position[1] };
						
					if ( offset.left > 0 ) {
						offset = $.datepicker._checkOffset( datePickerInstance, offset );	
					}
					//on click opening fixes the bugs with dragged and resized popup windows
					$.datepicker._showDatepicker(e);			
					datePickerInstance.dpDiv.css({
						left: offset.left,
						top: offset.top + this.offsetHeight	
					}).show();
				})
				.on("change", function(e) {
					currentValue = ctrl.getValue();
				});;	
				
			return;
		} 
		
		if ( this.dateEditType === Runner.controls.constants.EDIT_DATE_DD_INLINE ) {
			imageCallId = 'imgCal_' + this.valContId;
			datePickerId = imageCallId + '_datepicker';
		
			this.calendar = $('#' + datePickerId);
			if ( !this.calendar.length ) {
				this.calendar = $('<div />')
					.attr('id', datePickerId)
					.css({
						'display': 'none',
						'position': 'absolute', 
						'z-index': '9999'
					})
					.appendTo( 'body' );
			}
			calendarAreaClick = false;
			this.unbindOnDestroy = [];			
			
			documentClickHandler = function(e) {
				if ( !calendarAreaClick && e.target != ctrl.calendar.get(0) && !ctrl.calendar.has(e.target).length || $(e.target).data('handler') === 'today') {
					// handling the click event outside the datepicker or the Today button clicking 
					ctrl.calendar.hide();
				}
				calendarAreaClick = false;				
			};
			this.unbindOnDestroy.push({
				object: $( document ),
				event: 'click',
				handler: documentClickHandler
			});
			
			imgCalClickHandler = function() {			
				ctrl.calendar.addClass('rnr-datepicker');
				
				imgCalClickHandler = function() {
					var position,
						isVisible = ctrl.calendar.is(':visible');

					$( document )
						.unbind('click', documentClickHandler)
						.bind('click', documentClickHandler);						
					
					if ( isVisible ) {
						ctrl.calendar.hide();
						return false;
					}
					position = ctrl.spanContElem.offset();					
					ctrl.calendar.css({
						left: position.left, 
						top: position.top + 20
					});
					ctrl.calendar.show();
					return false;
				};			
				imgCalClickHandler();
				
				/*redefine the click handler*/
				$( this )
					.unbind('click')
					.bind('click', imgCalClickHandler);
				
				return false;
			};
			this.imgCal = $('#' + imageCallId).bind('click', imgCalClickHandler);		
			

			options.onChangeMonthYear = function(year, month, inst) {
				calendarAreaClick = true;
			};
			options.onSelectHandler = function(dt, inst) {
				$( this ).datepicker('hide');
				var dt = ctrl.parseDateTime(dt, ctrl.dateFormat);
				ctrl.setValue(dt, true);
				// use timer for today button
				setTimeout(function() {
					ctrl.calendar.hide();
				}, 0);
			};

			// init picker
			this.calendar.datepicker( options );
		}
	},

	/**
	 * jQuery UI datepicker patch improving 'Today' button functionality.
	 * To prevent _gotoToday from overpatching the _gotoToday's 'patched'
	 * property is set to true as soon as it is redeclarated
	 */
	patchjQueryUIDatepickerTodayHandler: function() {
		if ( $.datepicker._gotoToday.patched ) {
			return;
		}
		
		var gotoToday = $.datepicker._gotoToday;	
		$.datepicker._gotoToday = function(id) {
			gotoToday.call( $.datepicker, id );
			$.datepicker._selectDate( id );
		};
		
		$.datepicker._gotoToday.patched = true;
	},
	
	/**
	 * Get date format string for jQuery datepicker
	 * @return {String}
	 */ 
	getDateFormatString: function() {
		var dateFormat;
		
		// get date format
		switch ( parseInt(this.dateFormat) ) {
			case  0: dateFormat = 'mm/dd/yy'.replace(/\//g, this.dateDelimiter); break;
			case  1: dateFormat = 'dd/mm/yy'.replace(/\//g, this.dateDelimiter); break;
			case  2: dateFormat = 'yy/mm/dd'.replace(/\//g, this.dateDelimiter); break;
			case -1: default: dateFormat = 'dd-mm-yy';
		}		
		
		return dateFormat;
	},
	
	/**
	 * configure settings for datepicker
	 * @return {Object}
	 */
	getjQueryDatePickerDaseOptions: function() {
		var ctrl = this,
			initialYear = Runner.pages.PageSettings.getFieldData(this.table, this.fieldName, 'initialYear', this.pageType),
			lastYear = Runner.pages.PageSettings.getFieldData(this.table, this.fieldName, 'lastYear', this.pageType);
		
		return {
			currentText: Runner.lang.constants.TEXT_TODAY,
			closeText: Runner.lang.constants.TEXT_HIDE,
			changeMonth: true,
			changeYear: true,
			dayNames: this.dayNames,
			dayNamesShort: this.dayNames,
			dayNamesMin: this.dayNames,
			monthNames: this.monthNames,
			monthNamesShort: this.monthNames,
			firstDay: this.startWeekDay,
			isRTL: Runner.isDirRTL(),
			dateFormat: this.getDateFormatString(),
			prevText: '',
			nextText: '',
			yearRange: '-' + initialYear + ':+' + lastYear,
			showButtonPanel: true,
			beforeShow: function(input, inst) {
				var inst = inst.inst || inst;
				if (inst.settings.onBeforeShowHandler) {
					inst.settings.onBeforeShowHandler(input, inst);
				}
			},
			onSelect: function(dt, inst) {
				var isTimepicker = !!inst.inst,
					inst = inst.inst || inst;
				if (inst.settings.onSelectHandler) {
					inst.settings.onSelectHandler(dt, inst, isTimepicker);
				}
			},
			onClose: function(dt, inst) {
				if (inst.settings.onCloseHandler) {
					inst.settings.onCloseHandler(dt, inst);
				}
			},
			onCloseHandler: function(dt, inst) {
				var dt = ctrl.parseDateTime(dt, ctrl.dateFormat);
				if ( dt && dt.toString() !== ctrl.getValue().toString() ) {
					ctrl.setValue(dt, true);	
				}
			}
		};
	},
	
	/**
	 * Init the date picker hidden elem and click handler
	 * initializing the date picker
	 */
	initYUIDatePicker: function() {
		if ( !this.useYuiDatePicker ) {
			this.initYUIDatePicker = Runner.emptyFn;
			return;
		}
		
		var dateControl = this, 
			//bind the initYUICalendar method to the date control object
			afterCreateHandler = $.proxy( this.initYUICalendar, this ), 
			//bind the destroyYUICalendar method to the date control object
			afterCloseHandler = $.proxy( this.destroyYUICalendar, this );
		
		this.datePickerHiddId = "tsvalue" + (this.ctrlInd || "") + "_"+this.goodFieldName + "_" + this.id;
		this.datePickerHiddElem = $("#" + this.datePickerHiddId);
		
		this.imgCal = $('#imgCal_' + this.valContId).bind("click", function(e) {
			var winArgs = {
					modal: true,
					resize: false, // not yui attr
					centered: true
				};
				
			//create fly win yui panel
			Runner.pages.PageManager.createFlyWin( winArgs, false, afterCreateHandler, afterCloseHandler );
			return false;	
		});
	},	
	
	/**
	 * Defines the popup window afterCloseHandler's fuctionality.
	 * It destroy the YUI calendar and YUI panel objects
	 * @param {calWin} 	The YUI panel object
	 */	
	destroyYUICalendar: function(calWin) {
		this.calendar.destroy();
		setTimeout( function() {
			calWin.destroy(true);
		}, 0);
	},
	
	/**
	 * Defines the popup window afterCreateHandler's fuctionality.
	 * It creates and set the YUI calendar object
	 * @param {calWin} 	The YUI panel object
	 */
	initYUICalendar: function( calWin ) {
		var Y = Runner.Y,
			dateControl = this;
		
		Y.use('calendar', 'datatype-date', function(Y) {
			var date = new Date(),
				currentYear = date.getFullYear(),
				initialYear = Runner.pages.PageSettings.getFieldData(dateControl.table, dateControl.fieldName, "initialYear", dateControl.pageType),
				lastYear = Runner.pages.PageSettings.getFieldData(dateControl.table, dateControl.fieldName, "lastYear", dateControl.pageType),
				startYear = dateControl.startYear = currentYear - initialYear,
				endYear = dateControl.endYear = currentYear + lastYear,
				addCalId = "cal" + ( new Date().getTime() + '' + Math.floor( Math.random() * 100 ) ),
				calendar, timeSpan, selDate,
				node = calWin.get("srcNode").getDOMNode(),
				width, centered;
				
			calWin.set('bodyContent', '<div id="' + addCalId + '"></div>');	

			//set a navigation for right-to-left languages
			if ( Runner.isDirRTL() ) {											
				Y.Plugin.CalendarNavigator.CALENDARNAV_STRINGS.prev_month_class = Y.ClassNameManager.getClassName('calendarnav', 'nextmonth');							
				Y.Plugin.CalendarNavigator.CALENDARNAV_STRINGS.next_month_class = Y.ClassNameManager.getClassName('calendarnav', 'prevmonth');														
			}
			
			calendar = new Y.Calendar({
				contentBox: '#' + addCalId,
				minimumDate: new Date("1/1/" + startYear),
				maximumDate: new Date("12/31/" + endYear),
				showPrevMonth: true,
				showNextMonth: true
			});
			//add the calendar to the date control
			dateControl.calendar = calendar;
			
			if (Runner.isIE) {
				calendar.set('width', '250px');
				calendar.set('height', '204px');
			}
			
			// localize weekdays
			calendar.set("strings.first_weekday", dateControl.startWeekDay);
			calendar.set("strings.weekdays", dateControl.dayNames);
			calendar.set("strings.short_weekdays", dateControl.dayNames);
			calendar.set("strings.very_short_weekdays", dateControl.dayNames);
			
			// replace header 
			calendar.set("headerRenderer", function( curDate ) {
				var curYear = curDate.getFullYear(),
					curMonth = curDate.getMonth(),
					minYear = this.get('minimumDate').getFullYear(),
					maxYear = this.get('maximumDate').getFullYear(),
					monthDD, yearDD, i;
				
				this.yearDDId = this._calendarId + '_year_dd';
				this.monthDDId = this._calendarId + '_month_dd';
				
				monthDD = '<select class="rnr-calMonthDD" id="' + this.monthDDId + '">';
				for (i = 0; i < dateControl.monthNames.length; i++) {
					monthDD += '<option value="' + i + '"';
					if (i == curMonth) {
						monthDD += 'selected="selected"';
					}
					monthDD += '>' + dateControl.monthNames[i] + '</option>';
				}
				monthDD += '</select>';
				
				yearDD = '<select class="rnr-calYearDD" id="' + this.yearDDId + '">';
				for (i = minYear; i <= maxYear; i++) {
					yearDD += '<option value="' + i + '"';
					if (i == curYear) {
						yearDD += 'selected="selected"';
					}
					yearDD += '>' + i + '</option>';
				}
				yearDD += '</select>';
				
				return monthDD + yearDD;
			});
			
			// subscribe on selection change event for calendar
			var selectionHandler = function(e) {
				var selDate, currentDate;

				if ( !calendar.get("selectedDates").length ) {
					return;
				}
				
				selDate = calendar.get("selectedDates")[0];
				currentDate = dateControl.getValue();
				selDate.setHours( currentDate ? currentDate.getHours() : 0 );
				selDate.setMinutes( currentDate ? currentDate.getMinutes() : 0 );
				selDate.setSeconds( currentDate ? currentDate.getSeconds() : 0 );

				dateControl.setValue(selDate, true); 
				dateControl.destroyYUICalendar(calWin);
				e.stopImmediatePropagation();
			};
			calendar.on("dateClick", selectionHandler);
			
			// subscribe on render event for calendar
			calendar.after("render", function() {
				var contentBox = $( calendar.get('contentBox').getDOMNode() );
					
				contentBox.delegate('#' + calendar.yearDDId, 'change', function(e) {
					var val = parseInt(this.value), 
						oldDate;
					
					if (val < endYear + 1 && val > startYear - 1) {
						oldDate = calendar.get("date");
						calendar.set("date", new Date( val, oldDate.getMonth(), 1 ));
					}
				});
				contentBox.delegate('#' + calendar.monthDDId, 'change', function(e) {
					var val = parseInt(this.value),
						oldDate = calendar.get("date");
						
					calendar.set("date", new Date( oldDate.getFullYear(), val, 1 ));
				});
			});
						
			// handler for today button
			function todayHandler() {
				calendar.today = new Date();
				if ( !this.showTime ) {
					calendar.today.setHours(0);
					calendar.today.setMinutes(0);
					calendar.today.setSeconds(0);
				}
				calendar.selectDates(calendar.today);
				this.setValue(calendar.today, true);
				this.destroyYUICalendar(calWin);
			};
			
			// show today button
			calWin.addButton({
				value: Runner.lang.constants.TEXT_TODAY,
				section: Y.WidgetStdMod.BODY,
				classNames: 'rnr-calTodayBut',
				action: function(e) {
					e.preventDefault();
					todayHandler.call(dateControl);
				}
			});
			
			$(".rnr-calTodayBut").parent().css({"display": "block", "text-align": "center"});	
			
			selDate = dateControl.getValue();
			if (selDate) {
				calendar.set('date', selDate);
				calendar.selectDates(selDate);
			}
			
			calendar.render();
			calWin.render();
			calWin.show();
			
			//	fix for IE: stretch the header
			width = Runner.isIE ? 270 : $(node).width();
			$(node).width(width);
			
			if ( Runner.isDirRTL() ) {
				centered = $(window).scrollLeft() + Math.floor( ( $(window).width() - node.offsetWidth ) / 2 );					
				calWin.set("x", centered);
			}							
		});	
	},
	
	/**
	 * Create the Date object from the string representation
	 * basing on the dmy format
	 * @param {string} dmy
	 * @param {string} str 
	 * @return {object}
	 */
	parseDateTime: function( str, dmy ) {
		if ( str == null ) {
			return null;
		}
		var dt, i, 
			arr = str.match( /\d+/g );
		
		if ( arr == null || arr.length < 3 ) {
			return null;
		}
		for (i = arr.length; i < 6; i++) {
			arr[i] = 0;
		}

		if ( dmy == 1 ) {
			dt = new Date( arr[2], arr[1] - 1, arr[0], arr[3], arr[4], arr[5] );
		} else if ( dmy == 0 ) {
			dt = new Date( arr[2], arr[0] - 1, arr[1], arr[3], arr[4], arr[5] );
		} else {
			dt = new Date( arr[0], arr[1] - 1, arr[2], arr[3], arr[4], arr[5] );
		}
		if ( isNaN(dt) ) {
			return null;
		}
	//	check date and month
		if ( dmy == 1 && (dt.getMonth() != arr[1] - 1 || dt.getDate() != arr[0] || dt.getFullYear() != arr[2]) ) {
			return null;
		}
		if ( dmy == 0 && (dt.getMonth() != arr[0] - 1 || dt.getDate() != arr[1] || dt.getFullYear() != arr[2]) ) {
			return null;
		}
		if ( dmy == 2 && (dt.getMonth()!=arr[1] - 1 || dt.getDate() != arr[2] || dt.getFullYear() != arr[0]) ) {
			return null;
		}
		return dt;
	},
	
	/**
	 * Override addValidation 
	 * @param {string} type
	 */	
	addValidation: function( type ) {
		// date field can be validated only as isRequired or DenyDuplicated
		if ( type !== "IsRequired" || type !== "DenyDuplicated" || this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}
		Runner.controls.DateField.superclass.addValidation.call( this, type );
	},
	
	/**
	 * @param {mixed} newDate
	 * @return {mixed} 
	 */	 
	setValue: function( newDate ) {
		if ( typeof newDate === "string" ) {
			return this.parseDateTime(newDate, this.dateFormat);
		}
		return newDate;
	},
	
	/**
	 * format: -1 - native (d-m-y)
				1 - d/m/y
				0 - m/d/y
				2 - y/m/d
	 * @param {Date object} value
	 * @param {string} format
	 * @param {boolean} skipDayMonthZeroes
	 * @return {string}
	 */
	printDateTime: function( value, format, skipDayMonthZeroes ) {
		var date, time, 
			day = value.getDate(),
			month = value.getMonth() + 1,
			year = value.getFullYear();
		
		format = parseInt( format );
		
		if ( !skipDayMonthZeroes ) {
			day = day < 10 ? '0' + day : day;
			month = month < 10 ? '0' + month : month;
		}
		
		switch ( format ) {
			case -1:
				date = day + '-' + month + '-' + year;
				break;
			case 0:
				date = month + this.dateDelimiter + day + this.dateDelimiter + year;
				break;
			case 1:
				date = day + this.dateDelimiter + month + this.dateDelimiter + year;
				break;
			default:
				date = year + this.dateDelimiter + month + this.dateDelimiter + day;		
		}
		
		if ( !this.showTime ) {
			return date;
		}
		time = this.printTime( value );
		
		return date + ' ' + time;
	},

	/**
	 * Get the time string
	 * @param {Date object} value
	 * @return {string} 
	 */
	printTime: function( value ) {
		if ( !this.isDateObject(value) ) {
			return "";
		}
		
		var hours = value.getHours(),
			minutes = value.getMinutes(),
			seconds = value.getSeconds(),
			time;
		
		time = hours < 10 ? '0' + hours : hours;
		time += ':' + (minutes < 10 ? '0' + minutes : minutes);
		time += ':' + (seconds < 10 ? '0' + seconds : seconds);
		
		return time;
	},

	/**
 	 * Check if the argument passed is the Date object
	 * @param {Mixed} value
	 * @return {Boolean}
	 */
	isDateObject: function( value ) {
		return Object.prototype.toString.call( value ) === "[object Date]";
	},
	
	/**
	 * Get the tooltip position element distinct from the basic tooltip element
	 * @return {Mixed}	 
	 */
	getToolTipPositionElem: function() {
		return this.imgCal;
	}
});

/**
 * Class for date fields with textField value editor
 * If there is datePicker, instance of Runner.controls.DateTextField should be passed as target
 * @class Runner.controls.DateTextField
 */
Runner.controls.DateTextField = Runner.extend( Runner.controls.DateField, {
	/**
	 * Overrides parent constructor
	 * @param {Object} cfg
	 */
	constructor: function( cfg ) {
		Runner.controls.DateTextField.superclass.constructor.call(this, cfg);

		if ( this.isSetValidation('DenyDuplicated') ) {
			this.valueElem.attr('autocomplete', 'off');
		}
	},

	/**
	 * Set the value element
	 */	
	assignValueElem: function() {
		Runner.controls.DateField.superclass.assignValueElem.call(this);
		if ( typeof this.dateFormat === "undefined" || this.dateFormat === "" ) {
			this.dateFormat = Runner.pages.PageSettings.getGlobalData("locale").dateFormat;
		}		
	},
	
	/**
	 * Set the control's events list
	 */	
	assignListOfEvents: function() {
		this.addEvent(["click", "blur", "change", "keyup", "edited", "editing"]);
	},

	/**
	 * Set the events that will fire "edited", "editing" events
	 */
	addEditEditingListeners: function() {
		this.on("change", function(e, updateContext) {
			updateContext = updateContext && typeof updateContext === "object" ? updateContext : {};
			this.fireEvent("edited", updateContext);
			this.fireEvent("editing");
		});
		 
		this.on("keyup", function(e) {
			if ( !e || !Runner.isAcceptableKeyCode(e) ) {
				return false;
			}
			this.fireEvent("editing");
		});
	},
	
	getValue: function() {
		var parsedTime = this.parseDateTime( this.valueElem.val(), this.dateFormat );
		if (parsedTime == null) {
			return "";
		}	
		return parsedTime;	
	},
	/**
	 * Set value, also change value in hidden field
	 * @method
	 * @param {Object} val
	 * @return {bool} if passed correct Date object, otherwise false
	 */
	setValue: function(newDate, triggerEvent, updContext) {
		var dt;
		
		newDate = Runner.controls.DateTextField.superclass.setValue.call(this, newDate, triggerEvent);	

		if ( this.isDateObject( newDate ) ) {
			dt = this.printDateTime(newDate, this.dateFormat);
			//set value in edit textfield
			this.valueElem.val( dt );
			// if we need to set new date in hidden fields for datepicker
			if (this.useYuiDatePicker) {
				dt = this.printDateTime(newDate, -1);
				this.datePickerHiddElem.val( dt );
			}

			if (triggerEvent === true) {
				this.fireEvent("change", updContext);
			}
			return true;
		}
		// set empty value = ""
		this.valueElem.val("");
		// if we need to set new date in hidden fields for datepicker
		if (this.useYuiDatePicker) {
			this.datePickerHiddElem.val("");
		}
		
		if (triggerEvent === true) {
			this.fireEvent("change", updContext);
		}
		return false;
	},
	/**
	 * Custom function for onblur event
	 * @param {Object} e
	 */
	"blur": function(e) {
		this.stopEvent(e);
		this.focusState = false;
	},

	/**
	 * The method is invoked if the custom event "edited" is fired 
	 * It's overrided the base "edited" prop.
	 * @param {object} nullEvent		Equals to null if function is invoked 
	 * with the fireEvent method
	 * @param {object} updateContext
	 */	
	"edited": function(nullEvent, updateContext) {
		var valArr = this.getPreparedValidationArray(),
			vRes = this.validate( valArr );
	
		// set values to hidden fields
		if ( vRes.result && this.useDatePicker && this.getValue() ) {
			this.setValue( this.getValue() );
		}
	},
	
	/**
	 * Sets disable attr true
	 * Should be overriden for sophisticated controls
	 * @method
	 */
	setDisabled: function() {
		if ( !this.valueElem.length ) {
			return false;
		}
		
		this.valueElem.prop('disabled', true);
		if ( this.imgCal ) { 
			this.imgCal.css('visibility', 'hidden');
		}
		
		return true;
	},
	
	/**
	 * Sets disaqble attr false
	 * Should be overriden for sophisticated controls
	 * @method
	 */
	setEnabled: function() {
		if ( !this.valueElem.length ) {
			return false;
		}
		
		this.valueElem.prop('disabled', false);
		if ( this.imgCal ) {
			this.imgCal.css('visibility', 'visible');
		}
		
		return true;
	},
	
	/**
	 * Clone html for iframe submit
	 */
	getForSubmit: function() {
		return [ this.valueElem.clone(), this.dateFormatHiddElem.clone() ];
	},
	
	makeReadonly: function() {
		Runner.controls.DateTextField.superclass.makeReadonly.call(this);
		if ( this.imgCal ) {
			this.imgCal.css('display','none');
		}
		return true;
	},
	
	makeReadWrite: function() {
		Runner.controls.DateTextField.superclass.makeReadWrite.call( this );
		if ( this.imgCal ) {
			this.imgCal.css('display','');
		}
		return true;
	},	
	/**
	 * Return date value as string
	 * @return {string}
	 */
	getStringValue: function() {
		return this.valueElem.val();
	},
	
	/**
	 * Get the default control's value
	 * @return {String}	
	 */
	getDefaultControlValue: function() {
		if ( this.defaultValue === "" ) {
			return this.defaultValue;
		}
		return this.printDateTime( this.defaultValue, this.dateFormat );
	},
	
	destructor: function() {
		Runner.controls.DateTextField.superclass.destructor.call( this );
		// checking if jQuery datepPicker plugin is used and if the value element is not detached
		if ( this.usejQueryDatePicker && $.contains( document.documentElement, this.valueElem.get(0) ) ) {
			this.valueElem
				.datepicker('hide')
				.datepicker('destroy');
		}
	}
});

/**
 * Class for date fields with three dropdowns value editor
 * If there is datePicker, instance of Runner.controls.DateDropDown should be passed as target
 * @class Runner.controls.DateDropDown
 */
Runner.controls.DateDropDown = Runner.extend( Runner.controls.DateField, {
	/**
	 * Hidden element for date value
	 * value for server submit
	 * @type {Object} type
	 */
	hiddValueElem: null,
	/**
	 * Hidden element id
	 * @type {string}
	 */
	hiddElemId: "",
	
	/**
	 * The array of objects containing tge jQ object, 
	 * event and handler to unbind
	 * @type {array}
	 */
	unbindOnDestroy: null,
	
	/**
	 * Overrides parent constructor
	 * @param {Mixed} cfg
	 */
	constructor: function( cfg ) {
		Runner.controls.DateDropDown.superclass.constructor.call(this, cfg);
		
		// if allready have constants, than fill combos
		if ( Runner.lang.constants.TEXT_MONTH_JAN ) {
			this.addYearOptions( cfg.yearVal );
			this.addMonthOptions( cfg.monthVal );
			this.addDayOptions( cfg.dayVal );
		}
		
		if ( this.hiddValueElem.length ) {
			this.setValue( this.parseDateTime(this.hiddValueElem.val(), 2) );
		}

		this.defaultValue = this.getValue();
	},

	/**
	 * Set the value element
	 */	
	assignValueElem: function() {
		if ( typeof this.dateFormat === "undefined" || this.dateFormat === "" ) {
			this.dateFormat = Runner.pages.PageSettings.getGlobalData("locale").dateFormat;
		}	
		this.valueElem = {
			"day":	 $("#day" + this.valContId),
			"month": $("#month" + this.valContId),
			"year":	 $("#year" + this.valContId)
		};
		// add hidden elems
		this.hiddElemId = this.valContId;
		this.hiddValueElem = $("#" + this.hiddElemId);
	},
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */	
	assignsElemsForEvent: function() {
		this.elemsForEvent = [
			this.valueElem["day"].get(0), 
			this.valueElem["month"].get(0), 
			this.valueElem["year"].get(0)
		];
	},
	
	/**
	 * Set the control's events list
	 */	
	assignListOfEvents: function() {
		this.addEvent(["click", "change", "edited", "editing"]);
	},
	
	/**
	 * DateDropDown control's destructor
	 */
	destructor: function() {
		Runner.controls.DateDropDown.superclass.destructor.call(this);

		this.valueElem['day'].remove();
		this.valueElem['month'].remove();
		this.valueElem['year'].remove();
		
		if (!this.usejQueryDatePicker) {
			return;
		}	
		this.calendar.hide();		
		this.calendar.datepicker('destroy');
		if ( !this.unbindOnDestroy ) {
			return;
		}
		
		var i, unbindData;
		for (i = 0; i < this.unbindOnDestroy.length; i++) {
			unbindData = this.unbindOnDestroy[i];
			$( unbindData.object ).unbind( unbindData.event, unbindData.handler);
		}	
	},
	
	/**
	 * Initialize the control's tooltip
	 * @param {string} text
	 * @param {object} pageObj		The page's object reference	
	 */	
	initToolTip: function( text, pageObj ) {
		if ( !this.valueElem['day'].length || !this.valueElem['month'].length || !this.valueElem['year'].length ) {
			return;
		}
		
		var options = { 
			div: $('#shiny_box'), 
			div_sub: '.shiny_box_body', 
			html: text, 
			isFly: pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP, 
			el: this.getToolTipPositionElem()		
		};
		
		this.valueElem['day'].addClass('titleHintBox').inputHintBox( options );
		this.valueElem['month'].addClass('titleHintBox').inputHintBox( options );
		this.valueElem['year'].addClass('titleHintBox').inputHintBox( options );
	},
	
	/**
	 * Add year options
	 * @param {integer} year value
	 */
	addYearOptions: function( selectedYear ) {
		var dt = new Date(),
			currentYear = dt.getFullYear(),
			initialYear = Runner.pages.PageSettings.getFieldData(this.table, this.fieldName, "initialYear", this.pageType),
			lastYear = Runner.pages.PageSettings.getFieldData(this.table, this.fieldName, "lastYear", this.pageType),
			startYear = currentYear - initialYear,
			endYear = currentYear + lastYear,
			opt = $('<option>').val('').html(''),
			i;
					
		this.valueElem["year"].html('').append( opt );			
		
		for (i = startYear; i <= endYear; i++) {
			opt = $('<option>')
				.val(i).html(i);
			
			if (i == selectedYear) {
				opt.attr("selected", "selected");
			}
			this.valueElem["year"].append( opt );
		};
		
		this.addYearOptions = Runner.emptyFn;
	},
	
	/**
	 * Add month options
	 * @param {integer} month value
	 */
	addMonthOptions: function( selectedMonth ) {
		var i,
			opt = $('<option>')
				.val('').html('');
				
		this.valueElem["month"].html('').append( opt );
		
		for (i = 0; i < this.monthNames.length; i++) {
			opt = $('<option>')
				.val(i + 1).html( this.monthNames[i] );
				
			if (i + 1 == selectedMonth) {
				opt.attr("selected", "selected");
			}
			this.valueElem["month"].append( opt );
		}
		
		if ( !this.valueElem["month"].css('width') ) {
			this.valueElem["month"].css('width','90px');
		}
		
		this.addMonthOptions = Runner.emptyFn;
	},
	
	/**
	 * Add day options
	 * @param {integer} day value
	 */
	addDayOptions: function( selectedDay ) {
		var i, 
			opt = $('<option>')
				.val('').html('');
		
		this.valueElem["day"].html('').append( opt );
		
		for (i = 1; i <= 31; i++) {
			opt = $('<option>')
				.val(i).html(i);
			
			if (i === selectedDay) {
				opt.attr("selected", "selected");
			}
			this.valueElem["day"].append( opt );
		};
		
		this.addDayOptions = Runner.emptyFn;
	},
	
	/**
	 * Custom function for onchange event
	 * @param {Object} e
	 */
	"change": function(e) {
		this.stopEvent(e);
	},
	
	/**
	 * The method is invoked when the "edited" event is fired 
	 * @param {object} nullEvent		Equals to null if function is invoked 
	 * with the fireEvent method
	 * @param {object} updateContext
	 */
	"edited": function(nullEvent, updateContext) {
		var name, vRes;
		
		// if any dd is empty, than we can't start validation
		for ( name in this.valueElem ) {
			if ( this.valueElem[ name ].val() === '' ) {
				this.setValue();
				return;
			}
		}
	
		vRes = this.validate();
		if (vRes.result) {
			this.setValue( this.getValue() );
		}
	},
	
	/**
	 * Gets values from dropdowns and returns it in YYYY-mm-dd-hh-ss format
	 * @return {Mixed}
	 */
	getValue: function() {
		var dayVal = this.valueElem["day"].val(),
			monthVal = this.valueElem["month"].val(),
			yearVal = this.valueElem["year"].val();
		
		if ( !dayVal || !monthVal || !yearVal ) {
			return false;
		}	
		return new Date(yearVal, monthVal - 1, dayVal, 00, 00, 00);
	},

	/**
	 * Sets value to dropdowns
	 * @param {Date} newDate
	 * @return {bool}Returns true if success, otherwise false
	 */
	setValue: function(newDate, triggerEvent, updContext) {	
		var day, month, year;
		
		newDate = Runner.controls.DateTextField.superclass.setValue.call(this, newDate, triggerEvent);	

		if ( this.isDateObject( newDate ) ) {
			day = newDate.getDate();
			month = newDate.getMonth() + 1;
			year = newDate.getFullYear();
			
			this.hiddValueElem.val( year + '-' + month + '-' + day );		
			
			this.valueElem["day"].get(0).selectedIndex = day;		
			this.valueElem["month"].get(0).selectedIndex = month;
			this.valueElem["year"].val( year ).attr('selected', 'selected');

			if (this.useDatePicker) {
				if (this.useYuiDatePicker) {
					this.datePickerHiddElem.val( day + '-' + month + '-' + year );
				} else if (this.usejQueryDatePicker && this.calendar) {
					this.calendar.datepicker('setDate', newDate);
				}
			}
			if (triggerEvent === true) {
				this.fireEvent("change", updContext);
			}
			
			return true;
		}
		
		this.hiddValueElem.val('');
		if (updContext && updContext.resetHappend || this.isClearHappend) {
			this.valueElem["day"].get(0).selectedIndex = 0;
			this.valueElem["month"].get(0).selectedIndex = 0;
			this.valueElem["year"].get(0).selectedIndex = 0;
		}
		// if we need to set new date in hidden fields for datepicker
		if (this.useYuiDatePicker) {
			this.datePickerHiddElem.val("");
		}	
		if (triggerEvent === true) {
			this.fireEvent("change", updContext);
		}	
		return false;
	},
	
	makeReadonly: function() {
		this.setDisabled();
		return true;
	},
	
	makeReadWrite: function() {
		this.setEnabled();
		return true;
	},
	
	/**
	 * Overrides parent function for three element control
	 */
	setDisabled: function() {
		if (!this.valueElem.day || !this.valueElem.month || !this.valueElem.year) {
			return false;
		}
		
		this.valueElem.day.prop('disabled', true);
		this.valueElem.month.prop('disabled', true);
		this.valueElem.year.prop('disabled', true);
		
		if (this.imgCal) {
			this.imgCal.css('visibility', 'hidden');
		}
		return true;
	},
	
	/**
	 * Overrides parent function for three element control
	 */
	setEnabled: function() {
		this.valueElem.day.prop('disabled', false);
		this.valueElem.month.prop('disabled', false);
		this.valueElem.year.prop('disabled', false);	

		if ( this.imgCal ) {
			this.imgCal.css('visibility','visible');
		}
		return true;
	},
	
	/**
	 * Clone html for iframe submit
	 * @method
	 */
	getForSubmit: function() {
		return [ this.hiddValueElem.clone(), this.dateFormatHiddElem.clone() ];
	},
	
	/**
	 * Set focus to the element, override.
	 * Since focus cannot be set properly on valueElem 
	 * It sets focus on the select element within the control.
	 * @method
	 * @param {Boolean} triggerEvent
	 */
	setFocus: function( triggerEvent ) {
		var ctrl = this;
		
		this.isSetFocus = false;
		
		if ( !this.showStatus ) {
			return;
		}
		
		$.each( this.valueElem, function( ind, elem ) {
			var $elem = $(elem);
			
			if ( $elem.is(':disabled') || !$elem.is(':visible') ) {
				return;
			}
			
			if ( $elem.parent().find('select:first').attr('id') != $elem.attr('id') ) {
				return;
			}
			
			elem.focus();
			ctrl.isSetFocus = true;
			
			if ( triggerEvent === true ) {
				ctrl.fireEvent("focus");
			}				
			return false;
		});
	},
	
	/**
	 * Checks if the date control's value is empty. 
	 * @method
	 * @return {boolean}
	 */
	isEmpty: function() {
		return this.valueElem["day"].val() == "" || this.valueElem["month"].val() == "" || this.valueElem["year"].val() == "";
	},
		
	/**
	 * Return date value as string
	 * @parma {Date object} datePassed (optional)
	 * @return {string}
	 */
	getStringValue: function( datePassed ) {
		var date = datePassed || this.getValue(),
			day, month, year;
			
		if ( this.isDateObject( date ) ) {
			day = date.getDate();
			month = date.getMonth() + 1;
			year = date.getFullYear();
					
			return year + '-' + month + '-' + day;
		}
		return '';	
	},
	
	/**
	 * Check if the control element is set on the page
	 * @return {boolean}
	 */
	appearOnPage: function() {
		return !!this.valueElem[ "day" ].length && !!this.valueElem[ "month" ].length && !!this.valueElem[ "year" ].length;	
	},
	
	/**
	 * Get the initial control's value
	 * @return {string}	
	 */	
	getDefaultControlValue: function() {
		if ( this.defaultValue === false ) {
			return '';
		}
		return this.getStringValue( this.defaultValue );		
	} 
});


/**
 * Abstract base class for LookupWizard fields, should not created directly.
 * Contains common functionality for dependent lookup wizard controls
 * @class 
 * @requires Runner.controls.Control
 */
Runner.controls.LookupWizard = Runner.extend( Runner.controls.Control, {
	/**
	 * Lookup wizard indicator
	 * @type {boolean}
	 */
	isLookupWizard: true,
	
	/**
	 * Array dropDownControls which are dependent to this ctrl
	 * @type {array}
	 */
	dependentCtrls: null,
	
	/**
	 * Parent ctrl object. Used to get values in lookupSuggest
	 * @type {object}
	 */
	parentCtrl: null,
	
	/**
	 * Name of parent field
	 * @type {string}
	 */
	parentFieldName: '',

	/**
	 * A flag indicating if multiple selection is allowed
	 * @type {boolean}
	 */
	multiSelectionAllowed: false,
	
	/**
	 * @type {jQuery object}
	 */
	addNew: null,

	lookupTable: "",
	
	pageId: -1,
	
	dispField: "",
	
	linkField: "",
	
	preloadData: null,
	
	autoCompleteFields: null,
	
	
	/**
	 * Override parent contructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		// recreate objects
		this.dependentCtrls = [];
		this.autoCompleteFields = [];

		Runner.controls.LookupWizard.superclass.constructor.call(this, cfg);
		
		this.initAddNewLink();
		
		if ( this.pageType === Runner.pages.constants.PAGE_ADD && !this.isEmpty() ) {
			this.doAutoCompleteFields();
		}

		if ( this.preloadData ) {
			this.preload( this.preloadData.vals, this.preloadData.fVal );
			this.setDefaultValue();	
		}		
	},
	
	/**
	 * Set the control's events list
	 */	
	assignListOfEvents: function() {
		this.addEvent( ["click", "change", "edited", "editing"] );
		if ( Runner.isGecko ) {
			this.addEvent( ["keyup"] );
		}
	},
	
	/**
	 * Add the click handler to the addNew link 
	 */
	initAddNewLink: function() {
		var control = this;
		
		this.addNew = $("#addnew_" + this.valContId).on("click", function(e) {			
			var params = control.getPageParams();
			control.pageId = Runner.pages.PageManager.openPage( params );
			return false;
		});	
	},

	/**
	 * Get the tooltip position element distinct from the basic tooltip element
	 * @return {Mixed}
	 */
	getToolTipPositionElem: function() {
		return this.addNew.length ? this.addNew : null;
	},
	
	/**
	 * Get the 'add new on the fly' page's params
	 * @return {object}
	 */
	getPageParams: function() {
		return {
			modal: true,
			lookupCtrl: this,
			tName: this.lookupTable, 
			pageType: Runner.pages.constants.PAGE_ADD, 
			baseParams: {
				parId: this.id, 
				field: this.fieldName, 
				pageType: this.pageType,
				editType: Runner.pages.constants.ADD_ONTHEFLY,
				table: Runner.pages.PageSettings.getShortTName(this.table),
				category: this.parentCtrl ? this.parentCtrl.getValue() : ''
			},
			afterSave: {
				fn: function( respObj, formObj, fieldControls, pageObj ) {
					if ( respObj.success ) {
						this.processNewFlyAdded( respObj.vals[ this.dispField ], respObj.vals[ this.linkField ] )
						return;
					} 
					
					if ( respObj.message ) {
						// respObj contains error message
						pageObj.displayHalfPreparedMessage( respObj.message );
					} 
					
					pageObj.adjustPopWindowHeightByContent();
					$( pageObj.win.bodyNode.getDOMNode() ).animate({ scrollTop: 0});
					Runner.delDisabledClass( pageObj.saveButton );
					
					return false;	
				},
				scope: this
			}
		}
	},
	
	/**
	 * Method that called just before ControlManager deleted link on this object
	 */
	destructor: function() {
		// call parent
		Runner.controls.LookupWizard.superclass.destructor.call(this);
		// may be need to clear each array element
		delete this.dependentCtrls;
	},
	
	/**
	 * Add dependent controls to array of controls
	 * @method 
	 * @param {array} ctrlDD array of control objects
	 */
	addDependentCtrls: function( ctrlsArr ) {
		for (var i = 0; i < ctrlsArr.length; i++) {
			this.dependentCtrls.push( ctrlsArr[i] );
		}
	},
	/**
	 * Clear links from children to there's parent ctrl	 
	 * @param {boolean} triggerReload pass true to call reload function on children
	 */
	clearChildrenLinks: function( triggerReload ) {
		// reload all children
		for (var i = 0; i < this.dependentCtrls.length; i++) {
			// if children exists
			if ( this.dependentCtrls[i] ) {
				this.dependentCtrls[i].clearParent( triggerReload );
			}
		}
	},
	/**
	 * Deletes link to parent ctrl, and optionaly reloads this
	 * @param {boolean} triggerReload pass true to call reload method
	 */
	clearParent: function( triggerReload ) {
		this.parentCtrl = null;
		if ( triggerReload === true ) {
			this.reload();
		}
	},
	/**
	 * Set parent ctrl property
	 * @param {object} ctrl
	 */
	setParentCtrl: function( ctrl ) {
		this.parentCtrl = ctrl;
	},
	
	/**
	 * Call reload method of each dependent DD
	 * @method
	 * @param {object} updContext
	 */
	reloadDependeces: function( updContext ) {
		if ( !this.dependentCtrls || !this.dependentCtrls.length ) {
			return;
		}
		// value of parent ctrl
		var masterCtrlVal = this.getValue(),
			dCtrl, i;

		if ( !updContext || typeof updContext !== "object" ) {
			updContext = {};
		}
		
		updContext.changedFields = updContext.changedFields || [];

		// reload all children
		for (i = 0; i < this.dependentCtrls.length; i++) {
			dCtrl = this.dependentCtrls[i];
			// if a dependent ctrl exists and is not a master for a one that has initiated autofill
			if ( dCtrl && $.inArray( dCtrl.fieldName, updContext.changedFields ) === -1 ) {
				updContext.changedFields.push( this.fieldName );
				dCtrl.reload( masterCtrlVal, updContext );
			}
		}
	},
	
	/**
	 * A stub
	 * @param {array} vals 	 				unparsed values for options
	 * @param {string | array} selectValue	unparsed values of selected options
	 */
	preload: function( vals, selectValue ) {	
	},
	
	clearInvalidOnDependences: function() {
		if ( !this.dependentCtrls ) {
			return;
		}
		for (var i = 0; i < this.dependentCtrls.length; i++) { 
			// if children exists
			if ( this.dependentCtrls[i] ) {
				this.dependentCtrls[i].clearInvalid();
			}
		}
	},
	
	/**
	 * Complete other form's fields basing on 'Autofill' settings
	 * @param {object} updContext
	 */
	doAutoCompleteFields: function( updContext ) {
		if ( !updContext || typeof updContext !== "object" ) {
			updContext = {};
		}
		
		if ( !this.autoCompleteFields.length || updContext.resetHappend ) {
			return;
		}
		
		updContext.changedFields = updContext.changedFields || [];		
		
		var changedFields = updContext.changedFields,
			ajaxParams = {
				mainTable: Runner.pages.PageSettings.getShortTName( this.table ),
				mainField: this.fieldName,
				linkField: this.linkField,
				linkFieldVal: this.getValue(),
				pageType: this.pageType		
			};
		
		Runner.runnerAJAX(Runner.getPageUrl('autofillfields'), ajaxParams,
			$.proxy( function( respObj ) {
				if ( !respObj.success ) {
					return false;
				}
				var data = respObj.data,
					updContext = { 
						values: {},
						changedFields: changedFields.slice(0)
					},
					valToFill, i, ctrl;
				
				
				for (i = 0; i < this.autoCompleteFields.length; i++) {
					updContext.values[ this.autoCompleteFields[i].masterF ] = [ data[ this.autoCompleteFields[i].lookupF ] ];
					if ( $.inArray( this.autoCompleteFields[i].masterF, changedFields) === -1 ) {
						updContext.changedFields.push( this.autoCompleteFields[i].masterF );
					}
				}
				 
				for (i = 0; i < this.autoCompleteFields.length; i++) {
					ctrl = Runner.controls.ControlManager.getAt( this.table, this.id, this.autoCompleteFields[i].masterF );
					if ( !ctrl || $.inArray( ctrl.fieldName, changedFields) !== -1 ) {
						continue;
					}
					
					valToFill = data[ this.autoCompleteFields[i].lookupF ];
					valToFill = valToFill === null || valToFill === undefined ? '' : valToFill;
					ctrl.setValue( valToFill, true, updContext );
				}
				
			}, this )
		);
	},
	
	/**
	 * Override simple dropDown event,
	 * add reloading for dependent dropDowns
	 * @param {object} e		The event object or null 
	 * if the handler is invoked with the fireEvent method
	 * @param {object} updContext
	 */
	"change": function( e, updContext ) {		
		this.doAutoCompleteFields( updContext );
		
		// clear invalid state in dependent controls in anyway
		this.clearInvalidOnDependences();
		this.reloadDependeces( updContext, e );
		
		return false;
	},
	
	"keyup": function() {
		if ( Runner.isGecko ) {
			this.change();
		}
	}
	
});

/**
 * Radio control class
 * @requires Runner.controls.Control
 */
Runner.controls.RadioControl = Runner.extend( Runner.controls.LookupWizard, {
	/**
	 * Radio DOM elem id, starts from + _i 
	 * where i index of element, starts from 0
	 * @type {String} 
	 */
	radioElemsId: "",
	
	/**
	 * Radio jQuery obj
	 * @type {Array} 
	 */
	radioElemsArr: [],
	
	/**
	 * Radio name attr 
	 * @type {String}
	 */
	radioElemsNameAttr: "",
	
	/**
	 * jQuery object which contains all radios
	 * @type {jQuery object}
	 */
	radioElem: null,
	
	/**
	 * Count of radio buttons
	 * @type {Number}
	 */
	radioElemsCount: 0,
	
	/**
	 * Override parent contructor
	 * @constructor
	 * @param {Object} cfg
	 */
	constructor: function( cfg ) {
		Runner.controls.RadioControl.superclass.constructor.call( this, cfg );
	},
	
	/**
	 * Set the value element
	 */	
	assignValueElem: function() {
		Runner.controls.RadioControl.superclass.assignValueElem.call(this);
		
		// id starts from
		this.radioElemsId = "radio_" + this.goodFieldName + "_" + this.id + "_";
		// radio elems name attr
		this.radioElemsNameAttr = "radio_" + this.goodFieldName + "_" + this.id; 

		this.radioElem = $('input[name=' + this.radioElemsNameAttr + ']');
		this.radioElemsCount = this.radioElem.length;
		
		this.radioElemsArr = [];
		for (var i = 0; i < this.radioElemsCount; i++) {
			this.radioElemsArr.push( $("#" + this.radioElemsId + i) );
		}		
	},

	/**
	 * Set the DOM elements for the custom listeners usage
	 */	
	assignsElemsForEvent: function() {
		for (var i = 0; i < this.radioElemsCount; i++) {
			this.elemsForEvent.push( this.radioElemsArr[i].get(0) );
		}
	},

	/**
	 * Set the control's events list
	 */	
	assignListOfEvents: function() {
		this.addEvent( ["change", "keyup", "edited", "editing"] );
	},
		
	/**
	 * Set value to the control
	 * @param {string} val
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 * @return {boolean}
	 */
	setValue: function(val, triggerEvent, updContext) {
		var choosen = false,
			i;
			
		// loop for all radio elements
		for (i = 0; i < this.radioElemsCount; i++) {
			if (this.radioElemsArr[i].val() == val) {
				// set checked radio element
				this.radioElemsArr[i].prop("checked", true);
				//set value in hidden element
				this.valueElem.val( val );
				choosen = true;
			} else {
				this.radioElemsArr[i].prop("checked", false);
			}
		}
		if (!choosen) {
			this.valueElem.val('');
		}
		if (triggerEvent === true) { 
			this.fireEvent("change", updContext);
		}
		return choosen;
	},
	
	/**
	 * Sets disable radio control
	 * @method
	 */
	setDisabled: function() {
		for (var i = 0; i < this.radioElemsCount; i++) {
			this.radioElemsArr[i].get(0).disabled = true;
		}
		return true;
	},
	/**
	 * Sets disaqble attr false
	 * Should be overriden for sophisticated controls
	 * @method
	 */
	setEnabled: function() {
		for (var i = 0; i < this.radioElemsCount; i++) {
			this.radioElemsArr[i].get(0).disabled = false;
		}
		return true;
	},	

	/**
	 * The change event handler
	 * @param {object} e		The event object or null 
	 * if the handler is invoked with the fireEvent method
	 * @param {object} updContext
	 */
	"change": function( e, updContext ) {
		if ( e && e.target.value != this.getValue() ) {
			// set new val to hidden elem for chrome
			this.setValue( e.target.value, false );
			this.doAutoCompleteFields();
		}
		this.reloadDependeces( updContext, e );
	},
	
	/**
	 * Initialize the control's tooltip
	 * @param {string} text
	 * @param {object} pageObj		The page's object reference	
	 */	
	initToolTip: function( text, pageObj ) {		
		if ( this.mode === Runner.controls.constants.MODE_SEARCH || !this.spanContElem.length ) {
			return;
		}
		
		this.spanContElem.addClass('titleHintBox').inputHintBox({
			div: $('#shiny_box'), 
			div_sub: '.shiny_box_body', 
			html: text, 
			isFly: pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP
		});
		
		this.initToolTip = Runner.emptyFn;
	},
	
	makeReadonly: function() {
		this.setDisabled();
		return true;
	},
	
	makeReadWrite: function() {
		this.setEnabled();
		return true;
	},
	
	/**
	 * Get the displayed field's value
	 * @return {string}
	 */
	getDisplayValue: function() {
		var value = this.valueElem.val(),
			i;
			
		for (i = 0; i < this.radioElemsCount; i++) {
		    if ( this.radioElemsArr[i].val() == value && this.radioElemsArr[i].prop("checked") ) {
				return $( "#label_" + this.radioElemsArr[i].attr("id") ).text();		
			}
		}
		return "";
	},
	
	/**
	 * First loading, without ajax. Should be called directly
	 * @param {string} txt unparsed values for checkboxes
	 * @param {string} selectValue unparsed values of selected checkboxes
	 */
	preload: function(vals, selectValue) {
		// clear all old radios
		this.clearCtrl();
		// adds new checkboxes
		this.addRadioByArr( vals );
		// don't need to use ajax reload call
		this.setValue( selectValue, false );
	},
	
	/**
	 * Reloading radio control. Called by change event handler
	 * @param {string} value of master ctrl
	 * @param {object} updContext
	 */
	reload: function( masterCtrlValue, updContext ) {	
		var ctrl = this, 
			selectValue = this.getValue(),
			ajaxParams = {
				mode: this.mode,
				field: this.fieldName,
				value: masterCtrlValue,
				pageType: this.pageType,
				isExistParent: this.parentCtrl ? 1 : 0
			};	
			
		// get content
		Runner.runnerAJAX( Runner.getPageUrl( this.shortTableName, "autocomplete" ), ajaxParams, function( respObj ) {
			var data = respObj.data;
			// clear ctrl
			ctrl.clearCtrl();
			// if bad data from server, or timeout ends..
			if ( data === false ) {
				return false;
			}
			// add new radios
			ctrl.addRadioByArr( data );
			// restore the previously marked radios
			ctrl.setValue( selectValue, false );
			
			if ( updContext && updContext.resetHappend ) {
				// the control's initial reset was invoked earlier than reloading
				ctrl.reset( updContext );
			}				
		});
	},
	
	/**
	 * Deletes all radios from ctrl
	 * @method
	 */
	clearCtrl: function() {
		var divWrapper = this.spanContElem.find('div');
		divWrapper.children().remove();
		
		this.radioElemsArr = [];
		this.radioElemsCount = 0;
	},
	
	/**
	 * Adds radio to ctrl
	 * @param {string} text
	 * @param {string} val
	 */
	addRadio: function(text, value) {
		var radioButton, radioLabel,
			delim = '&nbsp;',
			ind = this.radioElemsArr.length,
			divWrapper = $('div', this.spanContElem).not('.rnr-error-text'),
			spanWrapper = $('<span></span>').appendTo( divWrapper );
			
		divWrapper.addClass( this.isHorizontalLookup ? 'rnr-horizontal-lookup' : 'rnr-vertical-lookup' );
		
		radioButton = $('<input>')
			.attr('id', this.radioElemsId + ind)
			.addClass('rnr-radio-button')
			.attr('type', 'radio')
			.attr('name', this.radioElemsId)
			.val( value );
		
		radioLabel = $('<span>')
			.attr('id', 'label_' + this.radioElemsId + ind)
			.addClass('rnr-radio-label')
			.html( text );	
		
		spanWrapper.append( radioButton ).append( delim ).append( radioLabel );
		
		this.radioElemsArr.push( radioButton ); 
		this.radioElemsCount++;
	},
	
	/**
	 * Add radios from array.
	 * Array must have such structure:
	 * array[0] = value, array[1] = text,
	 * array[2] = value, array[3] = text,
	 * 2*i - indexes of values; 2*i+1 - indexes of text. I starts from 0   
	 * @param {array} radioElemsArr
	 */
	addRadioByArr: function( radioElemsArr ) {
		var i;
		for (i = 0; i < radioElemsArr.length - 1; i = i + 2) {  
			this.addRadio( radioElemsArr[i+1], radioElemsArr[i] );
		}
		this.radioElem = $('input[name=' + this.radioElemsNameAttr + ']');
		// count of elems get from jQuery obj
		this.radioElemsCount = this.radioElemsArr.length;

		//reinit Custom Events
		this.purgeListeners();
		this.initCustomEvents();
	},
		
	/**
	 * Sets focus to the element
	 * Since focus cannot be set properly on the contol's value element 
	 * It sets focus on the first radio button in the list
	 * @method
	 * @intellisense
	 */
	setFocus: function( triggerEvent ) {
		var firstValueElem = this.radioElemsArr[0];
		
		if ( !this.appearOnPage() || !this.showStatus || firstValueElem.is(':disabled') ) {
			this.isSetFocus = false;
			return;
		}
		
		firstValueElem.focus();
		this.isSetFocus = true;
		
		if (triggerEvent === true) {
			this.fireEvent("focus");
		}
	},

	/**
	 * Process the new added 'on the fly' item 
	 * @param {string} text
	 * @param {string | number} value
	 */	
	processNewFlyAdded: function(text, value) {
		this.addRadio(text, value);
		this.setValue(value, true);
		
		//reinit Custom Events
		this.purgeListeners();
		this.initCustomEvents();
	},
	
	/**
	 * Clone html for iframe submit
	 * @return {array}
	 * @intellisense
	 */
	getForSubmit: function() {
		if ( !this.appearOnPage() ) {
			return [];
		}
		
		var cloneElem = this.valueElem.clone(),
			val = this.valueElem.val(), 
			i, rButton;
		
		if (!val) {		
			for (i = 0; i < this.radioElemsArr.length; i++) {
				rButton = this.radioElemsArr[i];
				// the second condition is for the elements that were moved in DOM
				if ( rButton.is(":checked") || $("#" + rButton.attr("id")).is(":checked") ) {
					val = rButton.val();
					break;
				}
			}
		}
		
		return [ cloneElem.val( val ) ];
	} 	
});
/**
 * Select control class. 
 * @requires Runner.controls.LookupWizard
 * @class Runner.controls.DropDownLookup
 */
Runner.controls.DropDownLookup = Runner.extend( Runner.controls.LookupWizard, {
	/**
	 * The number of rows in a select element
	 * @type {number} 
	 */
	selectSize: 1,
	
	/**
	 * DropDown DOM options array
	 * @type {Array}
	 */
	optionsDOM: null,
	
	/**
	 * @type {jQuery object} 
	 */
	simpleSearchBox: {},

	/**
	 * @type {boolean}
	 */
	multiSelectionWithTabsEnabled: false,
	
	/**
	 * Override parent contructor 
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.controls.DropDownLookup.superclass.constructor.call( this, cfg );			
	},
	
	/**
	 * Set the value elements
	 */	
	assignValueElem: function() {
		Runner.controls.DropDownLookup.superclass.assignValueElem.call( this );	

		// add options array property
		this.optionsDOM = this.appearOnPage() ? this.valueElem.get(0).options : [];	
		
		this.initMultiselectionWithTabs();
		
		if ( this.mode === Runner.controls.constants.MODE_SEARCH && this.valueElem.data("usesuggests") && !this.multiSelectionWithTabsEnabled ) {
			this.simpleSearchBox = $("#" + this.valContId + "_simpleSearchBox");
		}

		this.initChanginAppearance();	
	},
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */
	assignsElemsForEvent: function() {
		Runner.controls.DropDownLookup.superclass.assignsElemsForEvent.call( this );	
		
		if ( this.mode === Runner.controls.constants.MODE_SEARCH && this.valueElem.data("usesuggests") && !this.multiSelectionWithTabsEnabled ) {
			this.elemsForEvent.push( this.simpleSearchBox.get(0) ); 
		}
	},
	
	/**
	 * Set the control's events list
	 */	
	assignListOfEvents: function() {
		Runner.controls.DropDownLookup.superclass.assignListOfEvents.call( this );

		if ( this.mode === Runner.controls.constants.MODE_SEARCH && this.valueElem.data("usesuggests") && !this.multiSelectionWithTabsEnabled ) {
			this.addEvent( ["keyup"] ); 
		}		
	},

	/**
	 * Adjust the select element with jQuery.chosen plugin 
	 */
	initMultiselectionWithTabs: function() {
		if ( this.selectSize == 1 && this.multiSelectionAllowed ) {
			this.valueElem.chosen({
				placeholder_text_multiple: Runner.lang.constants.TEXT_PLEASE_SELECT,
				width: this.valueElem.width() + "px"
			});

			var chosen = this.valueElem.data("chosen");
			// change a chosen container's positioning
			chosen.container.css("position", "static");
			chosen.dropdown.css("top", 0);
			
			// augment showing/hiding results methods 
			this.valueElem
				.on("chosen:showing_dropdown", function( e, data ) {
					var chosen = data.chosen,
						position = chosen.container.position();

					chosen.dropdown.css( {
						width: chosen.container.width(),
						top: position.top + chosen.container.outerHeight(),
						left: position.left
					}).show();	
				})		
				.on("chosen:hiding_dropdown", function( e, data ) {
					data.chosen.dropdown.hide();
				});
			
			this.multiSelectionWithTabsEnabled = true;
		}
	},
	
	/**
	 * Set the control's default value
	 */
	setDefaultValue: function() {
		this.defaultValue = this.getValue( true );		
	},
	
	/**
	 * Sets value to DropDown. Tries to set all values from array if multiselect control
	 * @param {mixed} pvals
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 * @return {boolean} true if success otherwise false
	 */
	setValue: function( pvals, triggerEvent, updContext ) {
		var vals = Runner.isArray( pvals ) ? pvals : [ pvals ],
			ctrl = this,
			// number of choosen options
			choosen = 0;
		
		this.valueElem.find( 'option' ).each( function( i, option ) {
			for (var j = 0; j < vals.length; j++) {
				if ( option.value == vals[j] ) {
					try {
						ctrl.optionsDOM[i].selected = true;
						choosen++;
					} catch(e){};
					
					if ( ctrl.multiSelectionAllowed ) {
						break;
					} 
					
					ctrl.valueElem.prop("selectedIndex", i);
					return false;
				}
				
				try {
					ctrl.optionsDOM[i].selected = false;
				} catch(e){};	
			}
			
			if ( !vals.length ) {
				ctrl.optionsDOM[i].selected = false;
			}
		});
		
		if ( !!vals.length && !choosen || !this.multiSelectionWithTabsEnabled && choosen > this.selectSize ) {			
			return false;
		}
		
		if ( this.multiSelectionWithTabsEnabled ) {
			this.valueElem.trigger("chosen:updated");
		}
		
		if ( triggerEvent === true ) {
			this.fireEvent("change", updContext);
		}			
		
		return true;
	},
	
	/**
	 * Returns values from dropDown. 
	 * @method
	 * @param {boolean} returnArray
	 * @return {mixed}
	 */
	getValue: function( returnArray ) {
		var selVals = [], i;

		if ( !this.optionsDOM ) {
			return "";
		}
		
		// loop for all options
		for (i = 0; i < this.optionsDOM.length; i++) {
			if ( this.optionsDOM[i].selected ) {
				selVals.push(this.optionsDOM[i].value)
			}
		}
		if ( !this.optionsDOM.length && this.appearOnPage() ) {
			this.valueElem.find( 'option:selected' ).each( function( i, option) {
				selVals.push( option.value );
			});
		}
		
		if ( returnArray === true || selVals.length > 1 ) { 
			return selVals;
		}
		if ( selVals.length === 1 ) {
			return selVals[0];
		}
		return "";
	},
	
	/**
	 * Return an escaped string value
	 * @param {Array} valueArray	 
	 * @return {string}
	 * @intellisense
	 */	
	getStringValue: function( valueArray ) {		
		var valsArr = valueArray || this.getValue( true ), i;
		
		if ( !this.multiSelectionAllowed ) {
			return valsArr[0];
		}
		
		for (i = 0; i < valsArr.length ;i++) {
			if ( valsArr[i].indexOf(',') !== -1 || valsArr[i].indexOf('"') !== -1 ) {
				valsArr[i] = '"' + valsArr[i].replace(/"/g, '""') + '"';
			}
		}
		
		return valsArr.join(",");
	},	
	
	/**
	 * Get the default control's value
	 * @return {String | Number}
	 */
	getDefaultControlValue: function() {
		if ( this.defaultValue === '' ) {
			return '';
		}
		return this.getStringValue( this.defaultValue );
	},
	
	/**
	 * Checks if control value is empty. 
	 * @method
	 * @return {boolean}
	 */
	isEmpty: function() {
		var selVals = this.getValue();
		
		return selVals === "";
	},
	
	/**
	 * Deletes all options from ctrl
	 * @method
	 */
	removeOptions: function() {
		var select = this.valueElem.get(0), i;
		
		for (i = this.optionsDOM.length; i--; ) {
			select.remove(i);
		}
		
		if ( this.multiSelectionWithTabsEnabled ) {
			this.valueElem.trigger("chosen:updated");
		}		
	},
	
	/**
	 * Add a new option to the select element
	 * @param {string} text
	 * @param {string} val
	 */
	addOption: function( text, val ) {
		this.valueElem.append('<option value="' + val + '">' + text + '</option>');
		
		if ( this.multiSelectionWithTabsEnabled ) {
			this.valueElem.trigger("chosen:updated");
		}
	},
	
	/**
	 * Add options from array.
	 * Array must have the following structure:
	 * 		array[0] = value, array[1] = text,
	 * 		array[2] = value, array[3] = text,
	 * 		2*i - indexes of values; 2*i+1 - indexes of text. I starts from 0 
	 * @param {array} optionsArr
	 */
	addOptionsArr: function( optionsArr ) {		
		for (var i = 0; i < optionsArr.length - 1; i = i + 2) { 
			this.addOption( optionsArr[i + 1], optionsArr[i] );
		}
	},
	
	/**
	 * First loading, without ajax. Should be called directly
	 * @param {array} vals 	 				unparsed values for options
	 * @param {string | array} selectValue	unparsed values of selected options
	 */
	preload: function( vals, selectValue ) {
		// clear all old options
		this.removeOptions();	

		if ( !this.multiSelectionAllowed ) {
			// add empty option for non multiselect
			this.addOption( Runner.lang.constants.TEXT_PLEASE_SELECT, "" );				
		}

		// load options
		this.addOptionsArr( vals );
		if ( selectValue !== null && selectValue !== '' ) {			
			if ( !Runner.isArray( selectValue ) ) {
				selectValue = selectValue.toString().split(",");
			}
			// don't need to use ajax reload call
			this.setValue( selectValue, false );
			return;	
		}
		
		if ( this.optionsDOM.length > 0  && this.mode !== Runner.controls.constants.MODE_SEARCH ) {
			this.setValue( [ this.optionsDOM[0].value ], false );	
		}			
	},	
	
	/**
	 * Reload dropdown.
	 * @param {string} masterCtrlValue value of master ctrl
	 * @param {object} updContext
	 */
	reload: function( masterCtrlValue, updContext ) {	
		// can't reload if no parent ctrl - for safety use
		if ( masterCtrlValue && !this.parentCtrl ) {
			return;
		}	
		
		var ctrl = this,
			ajaxParams = {
				mode: this.mode,
				field: this.fieldName,
				value: masterCtrlValue,
				pageType: this.pageType,
				isExistParent: this.parentCtrl ? 1 : 0
			},
			selectedValues = this.getValue( true );				
	
		Runner.runnerAJAX( Runner.getPageUrl( this.shortTableName, "autocomplete" ), ajaxParams, function( respObj ) {	
			var data = respObj.success ? respObj.data : [],
				pvals;
				
			ctrl.removeOptions();	
			// add empty option for non multiple select if it doesn't comes from server data
			if ( !ctrl.multiSelectionAllowed ) {
				// add empty option for non multiselect
				ctrl.addOption( Runner.lang.constants.TEXT_PLEASE_SELECT, "" );				
			}
			// load options
			ctrl.addOptionsArr( data );
			
			// if only one values except please select, so choose it
			if ( ctrl.optionsDOM.length == 2 && !ctrl.multiSelectionAllowed || ctrl.optionsDOM.length == 1 && ctrl.multiSelectionAllowed ) {
				ctrl.setValue( [ ctrl.optionsDOM[ ctrl.optionsDOM.length - 1 ].value ], false );	
			} else {
				ctrl.setValue( selectedValues, false );
			}				
			
			if ( updContext && updContext.values && updContext.values[ ctrl.fieldName ] ) {
				pvals = updContext.values[ ctrl.fieldName ];
				ctrl.setValue( pvals, true, updContext );	
			}
			
			// fire change event, for reload dependent ctrls
			ctrl.fireEvent("change", updContext);
			// after reload clear invalid massages			
			ctrl.clearInvalid();
		});
	},
	
	/**
	 * Initilize the two-states behaviour for the search control with the same displayed and link fields #8538
	 */
	initChanginAppearance: function() {
		if ( this.mode !== Runner.controls.constants.MODE_SEARCH || !this.valueElem.data("usesuggests") || !this.simpleSearchBox.length ) {
			this.updateAppearance = Runner.emptyFn;
			return;
		}
		
		// redifine some basic methods:
		this.getStringValue = function( valueArray ) {
			if ( this.simpleSearchBox.is(":visible") && !valueArray ) {
				return this.simpleSearchBox.val(); 
			}
			return Runner.controls.DropDownLookup.prototype.getStringValue.call( this, valueArray );	
		};
		
		this.isEmpty = function() {
			if ( this.simpleSearchBox.is(":visible") ) {
				return this.simpleSearchBox.val() === "";
			}
			return Runner.controls.DropDownLookup.prototype.isEmpty.call( this );
		};

		this.makeReadonly = function() {
			this.simpleSearchBox.prop({
				'disabled': true,
				'readonly': true
			});	
			return Runner.controls.DropDownLookup.prototype.makeReadonly.call( this );
		};
		
		this.makeReadWrite = function() {
			this.simpleSearchBox.prop({
				'disabled': false,
				'readonly': false
			});
			return Runner.controls.DropDownLookup.prototype.makeReadWrite.call( this );			
		};
		
		this.setDisabled = function() {
			this.simpleSearchBox.prop('disabled', true);
			return Runner.controls.DropDownLookup.prototype.setDisabled.call( this );	
		}; 
		
		this.setEnabled = function() {
			this.simpleSearchBox.prop('disabled', false);
			return Runner.controls.DropDownLookup.prototype.setDisabled.call( this );	
		};

		this.getValue = function( returnArray ) {
			if ( this.simpleSearchBox.is(":visible") ) {
				return this.simpleSearchBox.val();
			}
			return Runner.controls.DropDownLookup.prototype.getValue.call( this, returnArray );	
		};
		
		this.setValue = function( value ) {
			if ( this.simpleSearchBox.is(":visible") ) {
				return this.simpleSearchBox.val( value );
			}
			return Runner.controls.DropDownLookup.prototype.setValue.call( this, value );	
		};
		
		this.preload = function( vals, selectValue ) {
			if ( this.simpleSearchBox.is(":visible") ) {
				return;
			}
			return Runner.controls.DropDownLookup.prototype.preload.call( this, vals, selectValue );
		};

		this.reload = function( masterCtrlValue, updContext ) {
			if ( this.simpleSearchBox.is(":visible") ) {
				return;
			}
			return Runner.controls.DropDownLookup.prototype.reload.call( this, masterCtrlValue, updContext );			
		};

		this.getDispElem = function() {
			if ( this.simpleSearchBox.is(":visible") ) {
				return this.simpleSearchBox;
			}
			return Runner.controls.DropDownLookup.prototype.getDispElem.call( this );
		};

		this.implySuggests = function() {
			return this.simpleSearchBox.is(":visible");
		};		
	},
	
	/**
	 * Change the search control's appearance on the search option change #8538		
	 * @param {string} searchOption
	 */	
	updateAppearance: function( searchOption ) {
		var simpleControlOptions = [ "Contains", "NOT Contains", "Starts with", "NOT Starts with" ];
		if ( $.inArray( searchOption, simpleControlOptions ) === -1 ) {
			( this.isReadonly() ? this.readonlyElem : this.valueElem ).show();
			this.simpleSearchBox.hide();
			return;
		}
		( this.isReadonly() ? this.readonlyElem : this.valueElem ).hide();
		this.simpleSearchBox.show();		
	},	
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr true
	 * Sets hidden css style true for link add New
	 * @method
	 */
	setDisabled: function() {
		if ( !this.valueElem ) {
			return false;
		}
		
		this.valueElem.prop('disabled', true);
	
		if ( this.addNew ) {
			this.addNew.css('visibility', 'hidden');					
		}			
		
		if ( this.multiSelectionWithTabsEnabled ) {
			$('option', this.valueElem).prop('disabled', true);
			this.valueElem.trigger("chosen:updated");
		}
		
		return true;
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr false
	 * Sets visible css style true for link add New
	 * @method
	 */
	setEnabled: function() {
		if ( !this.valueElem ) {
			return false;
		}
		
		this.valueElem.prop('disabled', false);
		
		if ( this.addNew ) {
			this.addNew.css('visibility', 'visible');					
		}	

		if ( this.multiSelectionWithTabsEnabled ) {
			$('option', this.valueElem).prop('disabled', false);
			this.valueElem.trigger("chosen:updated");
		}
		
		return true;
	},
	
	/**
	 * Clone html for iframe submit.
	 * jQuery clone method won't clone object with new selected values
	 * that's why we need to set values in clone object separetely
	 * @return {array}
	 */
	getForSubmit: function() {
		if ( !this.appearOnPage() ) {
			return [];
		}
		
		var clone = this.valueElem.clone(), 
			selVals = this.getValue( true ),
			cloneOpt = clone.get(0).options,
			i, j;
			
		for (i = 0; i < cloneOpt.length; i++) {
			for (j = 0; j < selVals.length; j++) {
				if ( cloneOpt[i].value == selVals[j] ) {
					if ( !this.multiSelectionAllowed ) {
						clone.get(0).selectedIndex = i;
					}
					cloneOpt[i].selected = true;
					break;
				} 
				cloneOpt[i].selected = false;
			}
			
			if ( !selVals.length ) {
				cloneOpt[i].selected = false;
			}
		}
		
		if ( this.multiSelectionWithTabsEnabled && !cloneOpt.length || !selVals.length ) {
			clone.append( '<option selected="selected" value=""></option>' ); 
		}
		return [ clone ];
	},
	
	/**
	 * Make the control 'readonly'
	 */
	makeReadonly: function() {
		this.addNew.hide(); 
	
		if ( this.multiSelectionWithTabsEnabled ) {
			$('option', this.valueElem).prop('disabled', true);
			this.valueElem.trigger("chosen:updated");
			return;
		}
		
		Runner.controls.DropDownLookup.superclass.makeReadonly.call( this );	
	},
	
	/**
	 * Make the control writable
	 */
	makeReadWrite: function() {
		this.addNew.show();
		
		if ( this.multiSelectionWithTabsEnabled ) {
			$('option', this.valueElem).prop('disabled', false);
			this.valueElem.trigger("chosen:updated");
			return;
		}

		Runner.controls.DropDownLookup.superclass.makeReadWrite.call( this );	
	},
	
	/**
	 * Get the displayed field's value
	 * @return {string}
	 */
	getDisplayValue: function() {
		var displayValues = [],
			i = this.multiSelectionAllowed ? 0 : 1;
		
		for ( ; i < this.optionsDOM.length; i++) {
			if ( this.optionsDOM[i].selected ) {
				displayValues.push( this.optionsDOM[i].text );			
			}
		}
		return displayValues.join(", ");
	},
	
	/**
	 * Process the new added 'on the fly' item 
	 * @param {string} text
	 * @param {string | number} value
	 */		
	processNewFlyAdded: function( text, value ) {
		var values;
		
		if ( this.multiSelectionAllowed  ) {
			values = this.getValue( true ); 
			values.push( value );
		} else {
			values = [ value ];
		}
		
		this.addOption( text, value );		
		this.setValue( values, true );
	},
	
	/**
	 * Set an empty value to the control
	 */	
	clear: function() {
		this.clearInvalid();
		if ( !this.multiSelectionWithTabsEnabled ) {
			this.setValue('');	
			if($("#"+this.valContId+"_simpleSearchBox"))
				$("#"+this.valContId+"_simpleSearchBox").val("");
		} else {
			$('option:selected', this.valueElem).prop('selected', false);
			this.valueElem.trigger("chosen:updated");
		}
	},
	
	/**
	 * Sets focus to the control's element.
	 * @param {Boolean} triggerEvent
	 * @method
	 * @intellisense
	 */	
	setFocus: function( triggerEvent ) {
		if ( !this.multiSelectionWithTabsEnabled ) {
			Runner.controls.DropDownLookup.superclass.setFocus.call( this, triggerEvent );		
			return;
		}
		
		var chosenCtrl = this.valueElem.data('chosen');
		
		if ( !this.appearOnPage() || this.valueElem.prop('disabled') || !this.showStatus || !chosenCtrl.container.is(':visible') ) {
			return;
		}
		
		chosenCtrl.search_field.focus();
		this.isSetFocus = true;
	},
	
	/**
	 * Check if search suggests need initializing for the control
	 * @return {boolean}
	 */
	useSearchSuggests: function() {
		return this.mode === Runner.controls.constants.MODE_SEARCH && this.valueElem.data("usesuggests") && !this.multiSelectionWithTabsEnabled;
	}
});

/**
 * Multiple select control class
 * @requires Runner.controls.LookupWizard
 * @class Runner.controls.CheckBoxLookup
 * @extends Runner.controls.LookupWizard
 */
Runner.controls.CheckBoxLookup = Runner.extend( Runner.controls.LookupWizard, {
	/**
	 * type hidd element jQuery obj
	 * @type {object}
	 */
	typeElem: null,
	
	/**
	 * Number of checkboxes
	 * @type {Number}
	 */
	checkBoxCount: 0,
	
	/**
	 * Array of checkbox jQuery elements
	 * @type {array}
	 */
	checkBoxesArr: null,
	
	/**
	 * The indicator showing if the checkbox field is the lookup wizard
	 * @type {boolean}
	 */
	isTrueLookUpWizard: false,
	
	/**
	 * Override parent contructor
	 * @param {object} cfg
	 */ 
	constructor: function( cfg ) {
		// add checkboxes elements
		this.checkBoxesArr = [];

		Runner.controls.CheckBoxLookup.superclass.constructor.call(this, cfg);
	},

	/**
	 * Set the value element and the corresponding properties
	 */	
	assignValueElem: function() {
		var $checkBox, typeElemId,
			control = this;
		
		this.isTrueLookUpWizard = this.lcType === Runner.controls.constants.LCT_CBLIST;
		
		Runner.controls.CheckBoxLookup.superclass.assignValueElem.call(this);
	
		// assign the control's type hidden element		
		typeElemId = "type_" + this.goodFieldName + "_" + this.id;
		this.typeElem = $("#" + typeElemId);
		
		if ( this.isTrueLookUpWizard ) {
			// checkbox is used as lookup		
			$("[id^='" + this.valContId + "_']").each( function() {
				control.checkBoxesArr.push( $(this) );
			});
			return;
		}
		
		$checkBox = $("#" + this.valContId);
		if ( $checkBox.length ) {
			this.checkBoxesArr.push( $checkBox );	
		}
	},

	/**
	 * Set the DOM elements for the custom listeners usage
	 */	
	assignsElemsForEvent: function() {
		for (var i = 0; i < this.checkBoxesArr.length; i++) { 
			this.elemsForEvent.push( this.checkBoxesArr[i].get(0) );
		}
	},
	
	/**
	 * Sets array of values to checkboxes
	 * @method
	 * @param {mixed} value 			The contorl's value or an array of values
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 * @return {Boolean} true if success otherwise false
	 */	
	setValue: function( value, triggerEvent, updContext ) {
		var valsArr = [], 
			checkCount = 0,
			i, j;
		
		//	edit as Checkbox
		if ( !this.isTrueLookUpWizard ) {
			this.checkBoxesArr[0].get(0).checked = ( value && value != 0 );
		} else {
			if ( value === true && this.checkBoxesArr.length == 1 ) {
				// set checked
				this.checkBoxesArr[0].get(0).checked = true;
			} else if (!value) {
				for (i = 0; i < this.checkBoxesArr.length; i++) {
					// set all unchecked
					this.checkBoxesArr[i].get(0).checked = false;
				}
			} else {
				valsArr = typeof value === 'string' ? [value] : value;

				//loop for all checkboxes
				for (i = 0; i < this.checkBoxesArr.length; i++) {
					// set unchecked
					this.checkBoxesArr[i].get(0).checked = false;
					// loop for all vals
					for (j = 0; j < valsArr.length; j++) {
						// if check box val same as val in arr to check
						if ( this.checkBoxesArr[i].val() == valsArr[j] ) {
							this.checkBoxesArr[i].get(0).checked = true;
							checkCount++;
							break;
						}
					}
				}
			}
		}
		
		if ( triggerEvent === true ) {
			//this.fireEvent("click", updContext);
			this.fireEvent("change", updContext);
		}
		// check number of checked boxes
		if ( checkCount == valsArr.length && checkCount <= this.checkBoxesArr.length ) {
			return true;
		}
		return false;
	},
	/**
	 * Returns array of checked values
	 * @return {array}
	 */
	getValue: function() {
		var checkedArr = this.getCheckedBoxes(),
			valsArr = [];
		// get value from each checkbox
		for (var i = 0; i < checkedArr.length; i++) {
			valsArr.push( checkedArr[i].val() );
		}		
		return valsArr;
	},
	
	/**
	 * Return an escaped string value
	 * @param {Array} valueArray
	 * @return {string}
	 * @intellisense
	 */
	getStringValue: function( valueArray ) {
		var valsArr = valueArray || this.getValue(), i;
		
		if ( !this.isTrueLookUpWizard ) {
			return valsArr[0];
		}
		
		for (i = 0; i < valsArr.length; i++) {
			if ( valsArr[i].indexOf(',') !== -1 || valsArr[i].indexOf('"') !== -1 ) {
				valsArr[i] = '"' + valsArr[i].replace(/"/g, '""') + '"';
			}
		}
		
		return valsArr.join(",");
	},

	/**
	* Get the default control's value
	* @return {String | Number}
	*/
	getDefaultControlValue: function() {
		return this.getStringValue( this.defaultValue );
	},
	
	/**
	 * Checks if control value is empty. Used for isRequired validation
	 * @method
	 * @return {boolean}
	 */
	isEmpty: function() {
		return !this.getValue().length;
	},	
	
	/**
	 * Sets disable attr true
	 * @method
	 */
	setDisabled: function() {
		for (var i = 0; i < this.checkBoxesArr.length; i++) {
			this.checkBoxesArr[i].prop('disabled', true);
		}			
		return true;
	},
	
	/**
	 * Sets disaqble attr false
	 * @method
	 */
	setEnabled: function() {
		for (var i = 0; i < this.checkBoxesArr.length; i++) {
			this.checkBoxesArr[i].prop('disabled', false);
		}			
		return true;
	},
	
	/**
	 * Returns array of cheked checkBoxes
	 * @return {array}
	 */
	getCheckedBoxes: function() {
		var chekedArr = [], i, checkBox;
		
		// get value from each checkbox
		for (i = 0; i < this.checkBoxesArr.length; i++) {			
			checkBox = this.checkBoxesArr[i];
			// the second condition is for the elements that were moved in DOM
			if ( checkBox.is(":checked") || $("#" + checkBox.attr("id") ).is(":checked") ) {
				chekedArr.push( this.checkBoxesArr[i] );
			}
		}
		
		return chekedArr;
	},
	
	/**
	 * Returns array of jQuery object for inline submit
	 * @return {array}
	 */
	getForSubmit: function() {
		var checkedArr = this.getCheckedBoxes(), 
			cloneArr = [],
			realCb, cbClone, i;
		
		// get clone of each checkbox
		for (i = 0; i < checkedArr.length; i++) {
			realCb = checkedArr[i];	
			cbClone = $('<input>')
				.attr('type', 'hidden')	
				.attr('id', realCb.attr('id'))
				.attr('name', realCb.attr('name'))
				.val( realCb.val() );

			cloneArr.push( cbClone.get(0) );	
		}
		
		cloneArr.push( this.typeElem );
		return cloneArr;
	},

	/**
	 * Deletes all checkBoxes from ctrl
	 * @method
	 */
	removeCheckBoxes: function() {
		var divWrapper = this.spanContElem.find('div');	
		divWrapper.children().remove();
		
		this.checkBoxesArr = [];
		this.checkBoxCount = 0;
	},

	/**
	 * Add checkboxes from array.
	 * Array must have such structure:
	 * array[0] = value, array[1] = text,
	 * array[2] = value, array[3] = text,
	 * 2*i - indexes of values; 2*i+1 - indexes of text. I starts from 0 
	 * @param {array} checkBoxesArr
	 */
	addCheckBoxArr: function( checkBoxesArr ) {
		for (var i = 0; i < checkBoxesArr.length - 1; i = i + 2) { 
			this.addCheckBox( checkBoxesArr[i + 1], checkBoxesArr[i] );
		}
		//reinit Custom Events
		this.purgeListeners();
		this.initCustomEvents();
	},		
	
	/**
	 * Adds checkbox to ctrl
	 * @param {string} text
	 * @param {string} val
	 */
	addCheckBox: function( text, value ) {
		var checkBox, boxLabel,
			delim = '&nbsp;', 
			ind = this.checkBoxesArr.length,
			divWrapper = $('div', this.spanContElem).not('.rnr-error-text'),
			spanWrapper = $('<span></span>').appendTo( divWrapper );
		
		divWrapper.addClass( this.isHorizontalLookup ? 'rnr-horizontal-lookup' : 'rnr-vertical-lookup' ); 
		
		checkBox = $('<input>')
			.attr('id', this.valContId + "_" + ind)
			.addClass('rnr-checkbox')
			.attr('type', 'checkbox')
			.attr('name', this.valContId + '[]')
			.val(value);

		boxLabel = $('<b>')
			.attr('id', 'data_' + this.valContId + '_' + ind)
			.addClass('rnr-checkbox-label')
			.html(text);
			
		spanWrapper.append( checkBox ).append( delim ).append( boxLabel );
		
		this.checkBoxesArr.push( checkBox );
		this.checkBoxCount++;		
	},
	
	/**
	 * First loading, without ajax. Should be called directly
	 * @param {string} vals 		unparsed values for checkboxes
	 * @param {array} selectValue 	unparsed values of selected checkboxes
	 */
	preload: function( vals, selectValue ) {
		// clear all old checkboxes
		this.removeCheckBoxes();
		// load checkboxes
		this.addCheckBoxArr( vals );
		// don't need to use ajax reload call
		this.setValue( selectValue, false );
	},
	
	/**
	 * Reloading checkboxes. Called by change event handler
	 * @param {string} masterCtrlValue 			The value of the master control
	 * @param {object} updContext (optional)
	 */
	reload: function( masterCtrlValue, updContext ) {	
		var ctrl = this, 
			arSelectedValues = this.getValue(),		
			ajaxParams = {
				mode: this.mode,
				field: this.fieldName,
				value: masterCtrlValue,
				pageType: this.pageType,
				isExistParent: this.parentCtrl ? 1 : 0
			};		

		// get content
		Runner.runnerAJAX(Runner.getPageUrl(this.shortTableName, "autocomplete"), ajaxParams, function(respObj) {
			var data = respObj.data,
				pvals;
			
			// clear all checkboxes
			ctrl.removeCheckBoxes();
			// if bad data from server, or timeout ends..
			if ( data === false ) {
				return false;
			}
			// add checkboxes to ctrl
			ctrl.addCheckBoxArr(data);
			// restore the previously marked checkboxes
			ctrl.setValue( arSelectedValues, false );
			
			if ( updContext && updContext.values && updContext.values[ ctrl.fieldName ] ) {
				pvals = updContext.values[ ctrl.fieldName ];
				ctrl.setValue( pvals, true, updContext );
			}
			
			// fire change event, for reload dependent ctrls
			ctrl.fireEvent("change", updContext);
			// after reload clear invalid massages
			ctrl.clearInvalid();
		});
	},

	/**
	 * Initialize the control's tooltip
	 * @param {string} text
	 * @param {object} pageObj		The page's object reference	
	 */	
	initToolTip: function( text, pageObj ) {		
		if ( this.mode === Runner.controls.constants.MODE_SEARCH || !this.spanContElem.length ) {
			return;
		}
		
		this.spanContElem.addClass('titleHintBox').inputHintBox({
			div: $('#shiny_box'), 
			div_sub: '.shiny_box_body', 
			html: text, 
			isFly: pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP
		});
		
		this.initToolTip = Runner.emptyFn;
	},
	
	/**
	 * Set the field in 'readonly' mode 
	 * hiding the real checkboxes and adding 
	 * their disabled clones to the page
	 */
	makeReadonly: function() {
		if ( !this.appearOnPage() ) {
			return false;
		}
	
		for (var i = 0; i < this.checkBoxesArr.length; i++) {
			var elemChk = this.checkBoxesArr[i], 
				readonlyElem = elemChk.clone(),
				elId = elemChk.get(0).id;
				
			readonlyElem.prop({
				id: "readonly_" + elId,
				name: "readonly_" + elId,
				disabled: true
			});	
			elemChk.before( readonlyElem ).hide();
		}
		return true;
	},
	
	/**
	 * Set the field in 'read/write' mode 
	 * showing the real checkboxes and 
	 * removing their disabled substitutes
	 */	
	makeReadWrite: function() {
		if ( !this.appearOnPage() || !this.isReadonly() ) {
			return false;
		}
	
		for (var i = 0; i < this.checkBoxesArr.length; i++) {
			var elemChk = this.checkBoxesArr[i],
				elId = elemChk.get(0).id;
				
			$('#readonly_' + elId).remove();
			elemChk.show();
		}
		return true;
	},
	
	/**
	 * Check if the field in the 'readonly' mode 
	 * @return {boolean}
	 */
	isReadonly: function() {
		for (var i = 0; i < this.checkBoxesArr.length; i++) {
			if ( $('#readonly_' + this.checkBoxesArr[i].get(0).id).length ) {
				return true;
			}
		}
		return false;
	},
	
	/**
	 * Get the displayed field's value
	 * @return {string}
	 */
	getDisplayValue: function() {
		var displayValues = [];
		
		for (var i = 0; i < this.checkBoxesArr.length; i++) {
			if ( this.checkBoxesArr[i].prop("checked") ) {
				displayValues.push( $("#data_" + this.checkBoxesArr[i].attr("id")).text() );
			}
		}
		return displayValues.join(", ");		
	},
	
	/**
	 * Checks whether the control exists or not
	 * @method
	 * @return {boolean}
	 * @intellisense
	 */	
	appearOnPage: function() {
		return this.checkBoxesArr.length;
	},
	
	/**
	 * Sets focus to the element.
	 * Since focus cannot be set properly on the contol's value element 
	 * It sets focus on the first checkbox in the list 
	 * @param {Boolean} triggerEvent
	 * @method
	 * @intellisense
	 */
	setFocus: function( triggerEvent ) {
		var firstValueElem = this.checkBoxesArr[0];
		
		this.isSetFocus = false;
		
		if ( !this.appearOnPage() || !this.showStatus || firstValueElem.is(':disabled') ) {
			return;
		}
	
		firstValueElem.focus();
		this.isSetFocus = true;
		
		if (triggerEvent === true) {
			this.fireEvent("focus");
		}	
	},

	/**
	 * Process the new added 'on the fly' item 
	 * @param {string} text
	 * @param {string | number} value
	 */	
	processNewFlyAdded: function( text, value ) {
		var values = this.getValue();
		
		values.push( value );
		this.addCheckBox( text, value );
		this.setValue( values, true );

		//reinit Custom Events
		this.purgeListeners();
		this.initCustomEvents();
	}	
});


/**
 * Base abstract class for lookups with textFields
 * Contains text box editor as display field and hidden field for submit values
 * @class
 * @requires Runner.controls.LookupWizard
 */
Runner.controls.TextFieldLookup = Runner.extend( Runner.controls.LookupWizard, {
	/**
	 * jQuery element that display value
	 * Value element in EditBoxLookup is hidden, and used for submit data
	 * @type {jQuery object}
	 */
	displayElem: null,

	/**
	 * An array containig multiselect control's 
	 * default options data (value and text)
	 * @type {array}
	 */
	defaulOptionsData: null,
	
	/**
	 * Override parent contructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		Runner.controls.TextFieldLookup.superclass.constructor.call( this, cfg );							
	},

	/**
	 * Set the value element
	 */	
	assignValueElem: function() {
		Runner.controls.TextFieldLookup.superclass.assignValueElem.call(this);
			
		//get the jQuery object representing the displayed element
		this.displayElem = $("#display_" + this.valContId);

		this.initMultiselectionWithTabs();	
	},
	
	/**
	 * Initialize a multiselect control if multiple selection is allowed
	 */
	initMultiselectionWithTabs: function() {
		if ( !this.multiSelectionAllowed ) {
			return;
		}
		
		var ctrl = this,
			chosenCtrl;
		
		this.valueElem.chosen( { 
				disable_search: false,
				placeholder_text_multiple: " ",
				width: this.valueElem.width() + "px" 				
			} );
		
		chosenCtrl = this.valueElem.data("chosen");
		
		this.valueElem
			.on("chosen:showing_dropdown", function() {				
				chosenCtrl.results_showing = true;
				chosenCtrl.results_hide();
			})
			.on("change", function( e, data ) {
				if ( data && data.deselected ) {
					ctrl.removeMultiselectOption( data.deselected );
				}
			});			
	},
	
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */	
	assignListOfEvents: function() {
		this.addEvent( ["blur"] );
		Runner.controls.TextFieldLookup.superclass.assignListOfEvents.call(this);
	},

	/**
	 * Set the control's default value
	 */
	setDefaultValue: function() {
		var ctrl = this;
		
		if ( !this.multiSelectionAllowed ) {
			this.defaultValue = [ this.getValue(), this.getDisplayValue() ];
			return;
		}
		
		this.defaultValue = this.getValue( true );
		
		this.defaulOptionsData = [];
		$('option', this.valueElem).each( function( ind, option ) {
			var $option = $( option );
			
			ctrl.defaulOptionsData.push( {
				linkVal: $option.val(), 
				dispVal: $option.text()
			});			
		});		
	},
	
	/**
	 * Set value to display element
	 * @param {mixed} val
	 * @return {bool} true if success otherwise false
	 */
	setDisplayValue: function( val ) {
		if ( this.displayElem ) {
			return this.displayElem.val( val );
		}
		return false;
	},
	
	/**
	 * Get value from value element. 
	 * Should be overriden for sophisticated controls
	 * @method
	 */
	getDisplayValue: function() {			
		if ( this.displayElem ) {
			return this.displayElem.val();
		}
		return false;
	},
	
	/**
	 * Get display field value by set value (search by link field)
	 * @param {string} value
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 */ 
	setValue: function( value, triggerEvent, updContext ) {
		var ctrl = this,
			multiselection = this.multiSelectionAllowed && Runner.isArray( value ),
			ajaxParams = {
				lookupValue: '',
				mode: this.mode,
				searchByLinkField: true,
				pageType: this.pageType,
				table: this.shortTableName,
				searchField: this.goodFieldName,
				searchFor: multiselection ? value.join(",") : value, 
				category: this.parentCtrl ? this.parentCtrl.getValue() : "",
				isExistParent: this.parentCtrl ? 1 : 0,
				editMode: this.mode,
				multiselection: multiselection
			}
			
		if ( this.freeInput ) {
			ctrl.setLookupValue( value, triggerEvent, value, updContext );
			return;
		}
		
		Runner.runnerAJAX( Runner.getPageUrl("lookupsuggest"), ajaxParams, function( respObj ) {
			if ( !respObj.success ) {
				return false;
			}
			
			var data = respObj.data, 
				i, j;

			for (i = 0, j = 0; i < data.length - 1; i = i + 2, j++) {
				if ( multiselection && $.inArray( data[i], value ) !== -1 || data[i] == value ) {
					ctrl.setLookupValue( data[i], triggerEvent, data[i + 1], updContext );
				}
			}
		});
	},
	
	/**
	 * Value in editBoxLookup is pair of display and hidden values
	 * @method
	 * @param {mixed} linkVal
	 * @param {mixed} dispVal
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 * @return {boolean} true if success otherwise false
	 */	
	setLookupValue: function( linkVal, triggerEvent, dispVal, updContext ) {
		if ( this.multiSelectionAllowed ) {
			//this.removeMultiselectOptions();
			this.addMultiselectOption( linkVal, dispVal );			
			return ;
		}
		
		var changed = this.valueElem.val() != linkVal && this.getDisplayValue() != dispVal;			

		this.valueElem.val( linkVal );	
		
		isSetDispVal = this.setDisplayValue( dispVal );
		if ( isSetDispVal === false ) {
			changed = false;
		}

		if ( changed && triggerEvent === true ) {
			this.fireEvent("change", updContext, true);
		}
		
		return changed;
	},
	
	/**
	 * @param {boolean} returnArray
	 * @return {mixed}
	 */
	getValue: function( returnArray ) {
		if ( !this.multiSelectionAllowed ) {
			return this.valueElem.val();
		}
		
		var optionValues = [];
		
		$('option:selected', this.valueElem).each( function( ind, option ) {
			optionValues.push( option.value );
		})
		
		if ( returnArray || optionValues.length > 1 ) {
			return optionValues;
		}
		
		if ( optionValues.length === 1 ) {
			return optionValues[ 0 ];
		}		
		
		return "";
	},	
	
	/**
	 * Set the default value to the control
	 * @param {object} updContext
	 */
	reset: function( updContext ) {
		var ctrl = this;
		
		this.clearInvalid();	
		
		if ( !this.multiSelectionAllowed ) {
			this.setLookupValue( this.defaultValue[0], true, this.defaultValue[1], updContext );
			return;
		}
		
		this.removeMultiselectOptions( !!this.defaulOptionsData.length );
			
		$.each( this.defaulOptionsData, function( idx, optionData ) {
			ctrl.addMultiselectOption( optionData[ 'linkVal' ], optionData[ 'dispVal' ], true );
		});
		
		this.fireEvent("change", updContext );
	},
	
	/**
	 * Sets disable attr true
	 * @method
	 */
	setDisabled: function() {
		if ( this.multiSelectionAllowed ) {
			$('option', this.valueElem).prop('disabled', true);
		}
		
		if ( this.displayElem ) {
			this.displayElem.prop('disabled', true);
		}
		
		return this.displayElem || this.multiSelectionAllowed;			
	},

	/**
	 * Sets disable attr false
	 * @method
	 */
	setEnabled: function() {
		if ( this.multiSelectionAllowed ) {
			$('option', this.valueElem).prop('disabled', false);
		}	
		
		if ( this.displayElem ) {
			this.displayElem.prop('disabled', false);
		}
		
		return this.displayElem || this.multiSelectionAllowed;
	},
	
	/**
	 * Sets focus to the element
	 * @method
	 * @param {Boolean} triggerEvent
	 */
	setFocus: function( triggerEvent ) {
		this.isSetFocus = false;
		
		if ( !this.displayElem || !this.displayElem.length || this.displayElem.prop("disabled") ) {
			return;
		}
		
		this.displayElem.get(0).focus();
		this.isSetFocus = true;
		
		if ( triggerEvent === true ) {
			this.fireEvent("focus");
		} 
	},
	
	/**
	 * Removes css class to value element
	 * @param {string} className
	 */
	removeCSS: function( className ) {
		this.displayElem.removeClass( className );
	},
	
	/**
	 * Removes css class to value element
	 * @param {string} className
	 */
	removeClass: function( className ) {
		var $displayElem = this.getDispElem();
		$displayElem.removeClass( className );
	},
	
	/**
	 * Adds css class to value element
	 * @param {string} className
	 */
	addCSS: function( className ) {
		this.displayElem.addClass( className );
	},
	
	/**
	 * Adds css class to value element
	 * @param {string} className
	 */
	addClass: function( className ) {
		var $displayElem = this.getDispElem();
		$displayElem.addClass( className );
	},
	
	/**
	 * Returns specified attribute from value element
	 * @param {string} attrName
	 */
	getAttr: function( attrName ) {
		return this.displayElem.attr( attrName );
	},
	
	/**
	 * Return element that used as display.
	 * Usefull for suggest div positioning
	 * @return {object}
	 */
	getDispElem: function() {
		if ( this.multiSelectionAllowed ) {
			return this.valueElem.data('chosen').container;
		}
		
		return this.displayElem;
	},
	
	/**
	 * Checks if control value is empty. Used for isRequired validation
	 * @method
	 * @return {boolean}
	 */
	isEmpty: function() {
		if ( !this.multiSelectionAllowed ) {
			return this.getDisplayValue().toString() == "";
		}
		
		return this.getValue( true ).length == 0;
	},	
	
	/**
	 * First loading, without ajax. Should be called directly
	 * @param {array} vals					txt unparsed values for options
	 * @param {string | array} selectValue 	unparsed values of selected options
	 */
	preload: function( vals, selectValue ) {
		for (var i = 0; i < vals.length - 1; i = i + 2) {
			if ( this.multiSelectionAllowed && $.inArray( vals[i], selectValue ) !== -1 || !this.multiSelectionAllowed && vals[i] === selectValue ) {					
				this.setLookupValue( vals[i], false, vals[i + 1] );
			}
		}		
	},
	
	/**
	 * Reload the control basing on its master control's value
	 * @param {string} masterCtrlValue
	 * @param {object} updContext	 
	 */
	reload: function( masterCtrlValue, updContext ) {		
		// can't reload if no parent ctrl - for safety use
		if ( masterCtrlValue && !this.parentCtrl || updContext && updContext.resetHappend ) {
			return;
		}		
		var ctrl = this,
			selectedValues = this.getValue( true ),
			ajaxParams = {
				mode: this.mode,
				field: this.fieldName,
				value: masterCtrlValue,
				pageType: this.pageType,
				isExistParent: this.parentCtrl ? 1 : 0
			};
				
		Runner.runnerAJAX( Runner.getPageUrl( this.shortTableName, "autocomplete" ), ajaxParams, function( respObj, reqStatus ) {
			var data = respObj.success ? respObj.data : [], 
				triggerEvent = false;
			
			ctrl.clearTextLookup();
			
			if ( data.length == 2 ) {
				// set values if from server comes only one value
				if ( ctrl.getValue() != data[0] ) {
					triggerEvent = true;
				}
				ctrl.setLookupValue( data[0], triggerEvent, data[1], updContext );			
			} else {
				ctrl.setValue( selectedValues );
			}
			
			//if exist autofill values set it
			if ( updContext && updContext.values && updContext.values[ ctrl.fieldName ] ) {
				ctrl.removeMultiselectOptions();
				
				triggerEvent = false;
				// if value changed, so fire change event
				if ( ctrl.getValue() != updContext.values[ ctrl.fieldName ][0] ) {
					triggerEvent = true;
				}
				
				if ( updContext.values[ ctrl.fieldName ].length == 2 ) {
					ctrl.setLookupValue( updContext.values[ ctrl.fieldName ][0], triggerEvent, updContext.values[ ctrl.fieldName ][1], updContext );
				} else {
					ctrl.setValue( updContext.values[ ctrl.fieldName ], triggerEvent, updContext );	
				}	
			}
			
			// after reload clear invalid massages
			ctrl.clearInvalid();
		});
		
	},
	
	/**
	 * Initialize the control's tooltip
	 * @param {string} text
	 * @param {object} pageObj		The page's object reference	
	 */		
	initToolTip: function( text, pageObj ) {
		if ( this.mode === Runner.controls.constants.MODE_SEARCH ) {
			return;
		}
		
		var options = this.getTooltipOptions( text, pageObj );
		
		this.displayElem.addClass('titleHintBox').inputHintBox( options );
		this.initToolTip = Runner.emptyFn;
	},
	
	/**
	 * Get the tooltip constructor options
	 * @param {string} text
	 * @param {object} pageObj
	 * @return {object}
	 */
	getTooltipOptions: function( text, pageObj ) {
		return {
			div: $('#shiny_box'), 
			div_sub: '.shiny_box_body', 
			html: text, 
			isFly: pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP,
			el: this.getToolTipPositionElem()
		}; 
	},
	
	/**
	 * Make the control 'readonly'
	 */
	makeReadonly: function() {
		if ( !this.appearOnPage() ) {
			return false;
		}
		
		this.addNew.hide();
		
		this.displayElem.prop({
			"disabled": true,
			"readonly": true
		});
		
		if ( this.multiSelectionAllowed ) {
			$('option', this.valueElem).prop('disabled', true);
		}		
	},
	
	/**
	 * Make the control writable
	 */	
	makeReadWrite: function() {
		if ( !this.appearOnPage() ) {
			return false;
		}
		
		this.addNew.show();
		
		this.displayElem.prop({
			"disabled": false,
			"readonly": false
		});
		
		if ( this.multiSelectionAllowed ) {
			$('option', this.valueElem).prop('disabled', false);
		}				
	},
	
	/**
	 * Get the default control's value
	 * @return {String | Number}
	 */
	getDefaultControlValue: function() {
		if ( !this.multiSelectionAllowed ) {
			return this.defaultValue[0];
		}

		if ( this.defaultValue[0] === '' ) {
			return '';
		}	
		
		return this.getStringValue( this.defaultValue );
	},	
	
	/**
	 * Get a particular multiselect control option
	 * @param {string} linkVal
	 * @return {jQuery object}
	 */
	getMultiselectOption: function( linkVal ) {
		return $('option', this.valueElem).filter( function() { 
				return this.value == linkVal; 
			}); 
	},
	
	/**
	 * Add an option for the multiselect control
	 * @param {string} linkVal
	 * @param {string} dispVal
	 * @param {boolean} notFireChangeEvent
	 */
	addMultiselectOption: function( linkVal, dispVal, notFireChangeEvent ) {
		if ( !this.multiSelectionAllowed || this.getMultiselectOption( linkVal ).length ) {
			return;
		}
		
		this.valueElem.append('<option selected="selected" value="' + linkVal + '">' + dispVal + '</option>');
		this.valueElem.trigger("chosen:updated");
		if ( !notFireChangeEvent ) {
			this.fireEvent("change");
		}
	},

	/**
	 * Set an empty value to the control
	 */
	clear: function() {
		this.clearInvalid();
		this.clearTextLookup();
	},
	
	/**
	 * Set an empty value to the text lookup control
	 */	
	clearTextLookup: function() {
		if ( this.multiSelectionAllowed ) {
			this.removeMultiselectOptions();
			return;
		}
		
		this.setLookupValue( '', false, '' );		
	},	
	
	/**
	 * Clear selected options for the multiselect control
	 * @param {boolean} notFireChangeEvent	 
	 */
	removeMultiselectOptions: function( notFireChangeEvent ) {
		if ( this.multiSelectionAllowed ) {
			$('option', this.valueElem).remove();
			if ( !notFireChangeEvent ) {
				this.valueElem.trigger("chosen:updated");
				this.fireEvent("change");
			}
		}
	},

	/**
	 * Remove a particular multiselect control option
	 * @param {string} linkVal
	 */
	removeMultiselectOption: function( linkVal ) {
		if ( !this.multiSelectionAllowed ) {
			return;
		}
		
		this.getMultiselectOption( linkVal )
			.remove();
			
		this.valueElem.trigger("chosen:updated");
		this.fireEvent("change");
	}	
});

/**
 * Edit box with ajax popup class with suggest div handling
 * @requires Runner.controls.TextFieldLookup
 * @class Runner.controls.EditBoxLookup
 */
Runner.controls.EditBoxLookup = Runner.extend( Runner.controls.TextFieldLookup, {
	/**
	 * Focus indicator
	 * @type Boolean
	 */
	focusState: false,
	
	/**
	 * suggestDiv cursor ind
	 * @type 
	 */
	cursor: -1,
	
	/**
	 * Array of suggest vals
	 * @type {array}
	 */
	suggestValues: null,
	
	/**
	 * Array of lookup vals
	 * @type {array}
	 */
	lookupValues: null,
	
	/**
	 * Lookup div id
	 * @type String
	 */	
	lookupDivId: "",
	
	/**
	 * Lookup div jQuery object
	 * @type {object}
	 */
	lookupDiv: null,
	
	/**
	 * Lookup div jQuery object
	 * @type {object}
	 */
	lookupIframe: null,
	
	/**
	 * Set suggest value from ajaxsuggest or not
	 * @type {boolean}
	 */
	isSetSuggestVal: false,
	
	/**
	 * A flag indicating if 'free input' is allowed.
	 * It could be equal to true if the lookup link and 
	 * displayed fields are the same only
	 * @type {boolean}
	 */	
	freeInput: false,

	/**
	 * @type {boolean}
	 */
	isError: false,
	
	/**
	 * Reference to timeout set up during the last keyup event
	 */
	submitTimout: null,

	/**
	 * An indicator showing if the search control is in the simple search mode
	 * @type {boolean}
	 */
	simpleSearchControlMode: false,
	
	
	/**
	 * Override parent contructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		this.suggestValues = [];
		this.lookupValues = [];
		
		Runner.controls.EditBoxLookup.superclass.constructor.call( this, cfg );
		
		this.freeInput = this.freeInput || this.mode == Runner.controls.constants.MODE_SEARCH;
		this.lookupDivId = 'lookupSuggest_' + this.valContId;
		
		this.delegateSuggestsContainerDestroying();	
	},
	
	/**
	 * Set the value element
	 */	
	assignValueElem: function() {
		Runner.controls.EditBoxLookup.superclass.assignValueElem.call( this );
		this.simpleSearchControlMode = !this.multiSelectionAllowed && this.displayElem.data("simpleSearchMode");
	},

	/**
	 * Initialize a multiselect control if multiple selection is allowed
	 */
	initMultiselectionWithTabs: function() {		
		if ( !this.multiSelectionAllowed ) {
			return;
		}
		
		Runner.controls.EditBoxLookup.superclass.initMultiselectionWithTabs.call( this );
	
		var chosenCtrl = this.valueElem.data('chosen');
		
		this.displayElem = chosenCtrl.search_field
			.unbind('keyup.chosen')
			.unbind('keydown.chosen')
			.width( 100	); 
	},
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */
	assignsElemsForEvent: function() {
		this.elemsForEvent = [ this.displayElem.get(0) ];	
	},
	
	/**
	 * Set the control's events list
	 */
	assignListOfEvents: function() {
		this.addEvent( ["focus", "keydown"] );
		Runner.controls.EditBoxLookup.superclass.assignListOfEvents.call( this );
	},
	
	/**
	 * Set the events that will fire "edited", "editing" events
	 */
	addEditEditingListeners: function() {
		this.on("change", function( e, updateContext, lookupValueSet ) {
			updateContext = updateContext && typeof updateContext === "object" ? updateContext : {};
			if ( e === null && ( lookupValueSet || this.multiSelectionAllowed ) ) { //#7845
				this.fireEvent("edited", updateContext);
			}	
		});
		
		this.on("keydown", function(e) {
			if ( !e || !Runner.isAcceptableKeyCode(e) ) {
				return false;
			}
			this.fireEvent("editing");
		});
	},
	
	/**
	 * Destroy sugessts container on 'outer' click
	 */
	delegateSuggestsContainerDestroying: function() {
		var ctrl = this,
			destroySuggestDivDelegate = function(e) {
				$target = $( e.target );
				if ( !$target.hasClass( "suggest_link_over" ) && !$target.hasClass( "suggest_link" ) ) {
					clearTimeout( ctrl.submitTimeout );
					ctrl.destroyDiv();
				}	
			};
		
		$('body, a').on('click', destroySuggestDivDelegate);
		$('body').on('click', 'input', destroySuggestDivDelegate);		
	},
	
	/**
	 * Update the control 'isError' state.
	 * Add/remove the red frame basing on the control's 'isError' state
	 * @param {boolean} errorHappend
	 */
	setFrame: function( errorHappend ) {
		this.isError = errorHappend && this.getDisplayValue() !== "" && !this.freeInput;
		this.isError ? this.addClass("highlight") : this.removeClass("highlight");
	},
	
	/**
	 * Set the default value to the control
	 * @param {object} updContext
	 */
	reset: function( updContext ) {
		Runner.controls.EditBoxLookup.superclass.reset.call( this, updContext );
		this.setFrame( false );
	},
	
	/**
	 * Destructor with suggest div remove
	 */
	destructor: function() {
		Runner.controls.EditBoxLookup.superclass.destructor.call(this);
		
		clearTimeout( this.submitTimeout );
		this.destroyDiv();
	},
	
	/**
	 * @return {boolean}
	 */
	isEmpty: function() {
		return Runner.controls.EditBoxLookup.superclass.isEmpty.call( this ) || this.isError;
	},
	
	/**
	 * Keycode after which lookupSuggest should start
	 * @param {number} keyCode
	 * @return {boolean}
	 */
	checkKeyCodeForRunSuggest: function( keyCode ) {
		return ( keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 
				|| keyCode == 8 || keyCode == 46 || keyCode == 32 || keyCode==222 );
	},
	
	/**
	 * Keyup event handler, for call lookupsuggest
	 * Do all work after keypressed
	 */
	"keydown": {
		fn: function(e) {
			var editBox = this, changed;
				
			switch( e.keyCode ) {
				case 38: //up arrow
					this.moveUp();
				break;
				case 40: //down arrow
					this.moveDown();
				break;
				case 13: //enter 
					if ( this.multiSelectionAllowed ) {
						this.setSuggestValueToControl( this.lookupValues[ this.cursor ], this.suggestValues[ this.cursor ].replace(/\<(\/b|b)\>/gi, "") );					
					}					
					this.destroyDiv();
					this.stopEvent(e);
				return;
			}

			if ( !Runner.isAcceptableKeyCode(e) ) {
				return;
			}
			
			if ( this.submitTimeout ) {
				clearTimeout(this.submitTimeout);
			}
			
			if ( this.freeInput && !this.multiSelectionAllowed ) {			
				changed = this.getDisplayValue() != this.getValue();
				this.setValue( this.getDisplayValue(), changed );
				
				if ( changed ) {
					this.fireEvent("change");
				}
			}
			
			this.submitTimeout = setTimeout( function() {
				if ( editBox.getDisplayValue() == "" ) {
					editBox.destroyDiv();
					editBox.setFrame( false );
					
					// set empty val and trigger error
					editBox.setValue("", true);
					return;
				}

				editBox.focus.call( editBox );
				// filter keys
				if ( e && editBox.checkKeyCodeForRunSuggest(e.keyCode) ) {
					editBox.isSetSuggestVal = false;
					// do request for suggest div data
					editBox.lookupAjax();
				}
			}, 500);
		},
		options: {
			buffer: 200
		}
	},

	/**
	 * Creates and set position of lookup div.
	 * Also set suggest vals
	 * @param {array} divsArr
	 */
	showSuggests: function( divsArr ) {
		this.destroyDiv();

		if ( !divsArr.length ) {
			return;
		}

		this.lookupDiv = $('<div id="' + this.lookupDivId + '" class="search_suggest"></div>')
			.css("visibility", "visible")
			.appendTo( document.body )
			.on('mouseenter', function(e) {
				$(this).data( "hovered", true );
			})
			.on('mouseleave', function(e) {
				$(this).data( "hovered", false );
			});			
	
		for (var i = 0; i < divsArr.length; i++) {
			this.lookupDiv.append( divsArr[i] );
		}

		this.setDivPos();
	},

	/**
	 * Destroys lookupDiv from DOM
	 */
	destroyDiv: function() {
		if ( this.lookupDiv ) {
			this.lookupDiv.remove();
		}
		this.cursor = -1;
		// clear link 
		this.lookupDiv = null;
	},
	
	/**
	 * Set div coords
	 */
	setDivPos: function() {
		if ( !this.lookupDiv ) {
			return;
		}
		
		var $displayedElem = this.getDispElem(),
			dElementOffset = $displayedElem.offset();
		
		this.lookupDiv.css({
			top: dElementOffset.top + $displayedElem.outerHeight() + "px",
			left: dElementOffset.left + ( Runner.isDirRTL() ? $displayedElem.outerWidth() - this.lookupDiv.outerWidth() : 0 ) + "px" 
		});
		
		// add highest z index
		Runner.setZindexMaxToElem( this.lookupDiv );
	},
	
	/**
	 * On hover suggest div value div handler
	 * @param {object} divHovered
	 */
	suggestOver: function( divHovered ) {
		// set new cursor index
		this.cursor = divHovered.id.substring( 10 );
		this.dispSuggestVal( true );
	},
	/**
	 * On unhover suggest div value div
	 * @param {object} divValue
	 */
	suggestOut: function( divValue ) {
		divValue.className = 'suggest_link';
		this.isSetSuggestVal = false;
	},
	
	/**
	 * Function that makes request to server and parse content
	 */
	lookupAjax: function() {
		var ctrl = this,
			ajaxParams = {
				mode: this.mode,
				table: this.shortTableName,
				pageType: this.pageType,
				searchFor: this.getDisplayValue(), 
				searchField: this.goodFieldName,
				lookupValue: this.getValue(),
				category: this.parentCtrl ? this.parentCtrl.getValue() : "",
				isExistParent: this.parentCtrl ? 1 : 0,
				editMode: this.mode
			};
		
		Runner.runnerAJAX( Runner.getPageUrl("lookupsuggest"), ajaxParams, function( respObj ) {
			if ( !respObj.success ) {
				// if error add red frame
				ctrl.setFrame( true );
				ctrl.destroyDiv();
				return;
			}
			
			var data = respObj.data, 
				dispVal = ctrl.getDisplayValue(),
				found = ctrl.freeInput,
				divsArr = [],
				i, j, eventsFlag;

			ctrl.suggestValues = [];
			ctrl.lookupValues = [];

			// get suggest and lookup values
			for (i = 0, j = 0; i < data.length - 1; i = i + 2, j++) {
				if ( ctrl.focusState ) {
					divsArr.push( ctrl.getSuggestContainer( 'suggestDiv' + j, data[ i + 1 ], data[ i ] ) );
				}

				ctrl.suggestValues[ j ] = data[ i + 1 ];
				ctrl.lookupValues[ j ] = data[ i ];
				
				if ( !found && ctrl.suggestValues[ j ] == dispVal ) {
					//	trigger events if value changed
					eventsFlag = ctrl.lookupValues[ j ] !== ctrl.getValue();
					ctrl.setLookupValue( ctrl.lookupValues[ j ], true, ctrl.suggestValues[ j ] );
					found = true;
				}
			}	
			
			ctrl.setFrame( !found );
			
			if ( !found && !ctrl.multiSelectionAllowed ) {
				eventsFlag = ctrl.getValue() !== "";
				ctrl.setLookupValue( "", eventsFlag, dispVal );
			}
			
			if ( !ctrl.focusState ) {
				return;
			}
					
			ctrl.showSuggests( divsArr );
		});
	},
	
	/**
	 * Create a suggest div container
	 * @param {string} containerId
	 * @param {string} suggestValue
	 * @param {string} lookupValue
	 * @return {jQuery object}
	 */
	getSuggestContainer: function( containerId, suggestValue, lookupValue ) {
		var ctrl = this;
		
		return $('<div id="' + containerId + '" class="suggest_link"></div>')
					.css("cursor", "pointer")
					.html( suggestValue )
					.bind("mouseover", function() {
						ctrl.suggestOver( this );
					}).bind("mouseout", function() {
						ctrl.suggestOut( this );
					}).bind("click", function() {
						ctrl.setFrame( false );
						ctrl.setSuggestValueToControl( lookupValue, suggestValue );
						ctrl.destroyDiv();
					});
	},
	
	/**
	 * Down arrow handler
	 */
	moveDown: function() {
		if ( !this.lookupDiv ) {
			return;
		}
		
		var $suggests = this.lookupDiv.children();
		if ( !$suggests.length || this.cursor >= $suggests.length ) {
			return;
		}
		
		// there are any suggest vals and cursor not on last of them
		// add cursor count - same to move down
		this.cursor++;
		// loop for all suggest vals
		this.dispSuggestVal();
		// for cursor loop
		if ( this.cursor == $suggests.length ) {
			this.cursor = -1;
			this.focus(); 
		}
	},
	
	/**
	 * Up arrow handler
	 */
	moveUp: function() {
		if ( !this.lookupDiv ) {
			return;
		}
		
		var $suggests = this.lookupDiv.children();
		// there are any suugest vals and dont't know why check that cursor >= -1
		if ( !$suggests.length || this.cursor < -1 ) {
			return;
		}
		
		// move up same as make cursor less
		this.cursor--;
		// set cursor on the last values, for loop
		if ( this.cursor == -2 ) {
			this.cursor = $suggests.length - 1; 
			this.focus(); 
		}
		// set styles and values
		this.dispSuggestVal();	
	},
	
	/**
	 * Set the current suggest value for the control
	 * @param {boolean} hover
	 */
	dispSuggestVal: function( hover ) {
		var ctrl = this;
		
		this.lookupDiv.children().each( function( index, suggest ) {
			var suggestVal, lookupVal;
			
			suggest.className = index === ctrl.cursor ? "suggest_link_over" : "suggest_link";
			if ( index !== ctrl.cursor ) {
				return;
			}
			if ( hover ) {
				ctrl.isSetSuggestVal = true;
				return;
			}
			
			suggestVal = ctrl.suggestValues[ ctrl.cursor ].replace(/\<(\/b|b)\>/gi, "");
			lookupVal = ctrl.lookupValues[ ctrl.cursor ];
			// if lookup val changes, than fireEvent
			if ( ctrl.getValue() != lookupVal ) { 
				ctrl.setFrame( false );
			}
			
			if ( !ctrl.multiSelectionAllowed ) {
				ctrl.setLookupValue( lookupVal, true, suggestVal );
			}
		});
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr true
	 * Sets hidden css style true for link add New
	 * @method
	 */
	setDisabled: function() {
		var res = Runner.controls.EditBoxLookup.superclass.setDisabled.call( this );
		if ( res ) {
			this.addNew.css('visibility', 'hidden');
		}
		
		return res;
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr false
	 * Sets visible css style true for link add New
	 * @method
	 */
	setEnabled: function() {
		var res = Runner.controls.EditBoxLookup.superclass.setEnabled.call( this );
		if ( res ) {
			this.addNew.css('visibility', 'visible');
		}
		
		return res;
	},
	
	/**
	 * Blur event handler
	 * @event
	 */
	"blur": function(e) {
		var ctrl = this,
			dispValue = this.getDisplayValue();
				
		if ( this.freeInput && this.multiSelectionAllowed && ( !this.lookupDiv || !this.lookupDiv.data('hovered') ) && dispValue.trim() !== "" ) {
			this.setSuggestValueToControl( dispValue, dispValue );
		}
		
		this.focusState = false;
		if ( !this.multiSelectionAllowed && !this.freeInput && !this.isSetSuggestVal && this.suggestValues.length ) {
			this.setFrame( dispValue !== "" && $.inArray( dispValue, this.suggestValues ) === -1 );
		}
		
		if ( this.multiSelectionAllowed  && !this.freeInput ) {
			this.setFrame( false );
		}
		
		setTimeout( function() {
			ctrl.destroyDiv();
			if ( ctrl.multiSelectionAllowed	) {
				ctrl.displayElem.width( 100 );
			}
		}, 250);
		
		this.stopEvent(e);
		this.isSetFocus = false;	
	},
	
	/**
	 * Focus event handler
	 * @event
	 */
	"focus": function(e) {
		if ( !this.multiSelectionAllowed ) {
			this.stopEvent(e);
		}
		this.focusState = true;
	},
	
	/**
	 * Get a string representation of the control's value
	 * @return {string}
	 */
	getStringValue: function( valueArray ) {
		if ( this.mode === Runner.controls.constants.MODE_SEARCH && this.simpleSearchControlMode ) {
			return this.getDisplayValue();
		}

		if ( this.multiSelectionAllowed ) {
			var valsArr = valueArray || this.getValue( true ), i;
		
			for (i = 0; i < valsArr.length ;i++) {
				if ( valsArr[i].indexOf(',') !== -1 || valsArr[i].indexOf('"') !== -1 ) {
					valsArr[i] = '"' + valsArr[i].replace(/"/g, '""') + '"';
				}
			}
			
			return valsArr.join(",");
		}
		
		return this.getValue();
	},

	/**
	 * Change the search control's appearance on the search option change #8538		
	 * @param {string} searchOption
	 */	
	updateAppearance: function( searchOption ) {
		if ( this.multiSelectionAllowed ) {
			return;
		}
		
		var simpleControlOptions = [ "Contains", "NOT Contains", "Starts with", "NOT Starts with" ];
		this.simpleSearchControlMode = $.inArray( searchOption, simpleControlOptions ) !== -1;
	},
	
	/**
	 * Update the control values' list
	 * @param {array} vals
	 * @param {string | array} selectValue
	 */
	preload: function( vals, selectValue ) {
		if ( this.simpleSearchControlMode ) {
			return;
		}
		
		if ( this.freeInput && this.multiSelectionAllowed ) {
			for (var i = 0; i < selectValue.length; i++ ) {
				this.setLookupValue( selectValue[i], false, selectValue[i] );
			}
			return;
		}
		
		Runner.controls.EditBoxLookup.superclass.preload.call( this, vals, selectValue );
	},
	
	/**
	 * Reload the control basing on its master control's value
	 * @param {string} masterCtrlValue
	 * @param {object} updContext	 
	 */
	reload: function( masterCtrlValue, updContext ) {
		if ( this.simpleSearchControlMode ) {
			return;
		}
		Runner.controls.EditBoxLookup.superclass.reload.call( this, masterCtrlValue, updContext );	
	},
	
	/**
	 * Clone html for iframe submit
	 * @return {array}
	 * @intellisense
	 */
	getForSubmit: function() {
		if ( !this.appearOnPage() ) {
			return [];
		}
		
		clearTimeout( this.submitTimeout );
		
		var cloneElem = this.valueElem.clone(),
			$options;
		
		if ( this.multiSelectionAllowed ) {
			$options = $('option', cloneElem).prop('selected', true);
			if ( !$options.length ) {
				cloneElem.append('<option selected="selected" value=""></option>');
			}
			
			return [ cloneElem ];			
		}
		
		if ( this.freeInput || !this.multiSelectionAllowed && this.getDisplayValue() === "" ) {
			return [ cloneElem.val( this.displayElem.val() ) ];
		}
		
		return [ cloneElem.val( this.valueElem.val() ) ];
	},

	/**
	 * Process the new added 'on the fly' item 
	 * @param {string} text
	 * @param {string | number} value
	 */
	processNewFlyAdded: function( text, value ) {
		if ( !this.suggestValues ) {
			return;
		}

		this.suggestValues.push( text );
		this.lookupValues.push( value );
		
		this.setSuggestValueToControl( value, text );
		
		this.setFrame( false );
	},

	/**
	 * Get the tooltip constructor options
	 * @param {string} text
	 * @param {object} pageObj	 
	 * @return {object}
	 */
	getTooltipOptions: function( text, pageObj ) {
		var options = Runner.controls.EditBoxLookup.superclass.getTooltipOptions.call( this, text, pageObj );
		
		if ( !this.freeInput ) {
			options.incrementLeft = 4;	
		}
		
		return options;
	},
	
	/**
	 * Set a selected suggest value to the control
	 * @param {mixed} linkVal
	 * @param {mixed} dispVal	 
	 */
	setSuggestValueToControl: function( linkVal, dispVal ) {
		if ( !this.multiSelectionAllowed ) {
			this.setLookupValue( linkVal, true, dispVal );
			return;
		}
		
		$option = this.getMultiselectOption( linkVal );
		
		if ( !$option.length ) {
			this.addMultiselectOption( linkVal, dispVal );
		}			
	},
	
	/**
	 * Reload dependent lookups
	 * @param {object} updContext
	 * @param {event Object} e
	 */	
	reloadDependeces: function( updContext, e ) {
		if ( this.freeInput || e === null ) {
			Runner.controls.EditBoxLookup.superclass.reloadDependeces.call( this, updContext, e );
		}
	}	
});
/**
 * List page with search lookup control class
 * @requires Runner.controls.TextFieldLookup
 */
Runner.controls.ListPageLookup = Runner.extend( Runner.controls.TextFieldLookup, {	
	/**
	 * The 'Select' link 
	 * @type {jQuery object}
	 */
	selectLinkElem: null,
	
	/**
	 * @type {Array}
	 */ 
	lookupVals: null,
		
	/**
	 * Override parent contructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.controls.ListPageLookup.superclass.constructor.call( this, cfg );

		this.initSelectLink();
		this.initChanginAppearance();		
	},

	/**
	 * Set the DOM elements for the custom listeners usage
	 */	
	assignListOfEvents: function() {
		Runner.controls.ListPageLookup.superclass.assignListOfEvents.call( this );
		if ( this.mode === Runner.controls.constants.MODE_SEARCH && this.valueElem.data("usesuggests") ) {
			this.addEvent( ["keyup"] );
		}
	},
	
	/**
	 * Set the DOM elements for the custom listeners usage
	 */
	assignsElemsForEvent: function() {
		Runner.controls.ListPageLookup.superclass.assignsElemsForEvent.call( this );
		if ( this.mode === Runner.controls.constants.MODE_SEARCH && this.valueElem.data("usesuggests") ) {
			this.elemsForEvent.push( this.displayElem.get(0) );
		}		
	},
	
	/**
	 * Initialize the 'Select' link
	 */
	initSelectLink: function() {
		var ctrl = this,
			pageParams = {
				tName: this.lookupTable, 
				pageType: Runner.pages.constants.PAGE_LIST, 
				lookupCtrl: this,
				modal: true,
				baseParams: {
					parId: this.id, 
					field: this.fieldName, 
					category: this.parentCtrl ? this.parentCtrl.getValue() : '', 
					table: this.table, 
					firstTime: 1,
					mode: "lookup",
					editMode: this.mode,
					pageType: this.pageType
				}
			},
			selectLinkId = "open_lookup_" + this.goodFieldName + "_" + this.id;					
				
		this.selectLinkElem = $("#" + selectLinkId)
			.on("click", function(e) {							
				if ( ctrl.selectLinkElem.hasClass("disabled") ) {
					return false;
				}
				
				if ( $("#search_suggest").length > 0 && typeof DestroySuggestDiv != "undefined" ) {
					DestroySuggestDiv();
				}
				
				if ( ctrl.parentCtrl ) {
					pageParams.baseParams.category = ctrl.parentCtrl.getValue();
					if ( !pageParams.baseParams.category && ctrl.parentCtrl.value ) {
						pageParams.baseParams.category = ctrl.parentCtrl.value;
					}
				}
				
				ctrl.pageId = Runner.pages.PageManager.openPage( pageParams );
				ctrl.setDisabled();
				
				return false;
			});		
	},

	/**
	 * Initialize a multiselect control if multiple selection is allowed
	 */
	initMultiselectionWithTabs: function() {
		if ( !this.multiSelectionAllowed ) {
			return;
		}
		
		Runner.controls.ListPageLookup.superclass.initMultiselectionWithTabs.call( this );
		
		var ctrl = this,
			chosenCtrl = this.valueElem.data("chosen");
	
		chosenCtrl.search_field.prop('readonly', true);		
		chosenCtrl.container
			.on('click', function(e) {
				ctrl.selectLinkElem.trigger('click');
			});
	},
	
	/**
	 * Get the tooltip position element distinct from the value element
	 * @return {Mixed}
	 */
	getToolTipPositionElem: function() {
		return this.selectLinkElem;
	},
	
	/**
	 *	Initilize the two-states behaviour for the search control with the same displayed and link fields #8538
	 */
	initChanginAppearance: function() {
		if ( this.mode !== Runner.controls.constants.MODE_SEARCH || this.multiSelectionAllowed ) {
			this.updateAppearance = Runner.emptyFn;
			return;
		}
		
		var ctrl = this;
		this.displayElem
			.on("change", function(e) {
				var dispVal = $(this).val();
				ctrl.setLookupValue( dispVal, true, dispVal );
			})
			.on("keyup", function(e) {
				if ( !Runner.isAcceptableKeyCode(e) ) {
					return;
				}
				var dispVal = $(this).val();
				ctrl.setLookupValue( dispVal, true, dispVal );	
			});
	},
	
	/**
	 * Change the search control's appearance on the search option change #8538	
	 * @param {string} searchOption
	 */	
	updateAppearance: function( searchOption ) {
		var simpleControlOptions = [ "Contains", "NOT Contains", "Starts with", "NOT Starts with" ];
		
		if ( $.inArray( searchOption, simpleControlOptions ) === -1 ) {
			this.displayElem.prop('readonly', true);
			this.selectLinkElem.css('visibility', 'visible');
			return;
		}
		
		this.displayElem.prop('readonly', false);
		this.selectLinkElem.css('visibility', 'hidden');
	},	

	/**
	 * Update the control values' list
	 * @param {array} vals
	 * @param {string | array} selectValue
	 */
	preload: function( vals, selectValue ) {
		if ( !this.multiSelectionAllowed && !this.displayElem.prop('readonly') ) {
			return;
		}
		Runner.controls.ListPageLookup.superclass.preload.call( this, vals, selectValue );
	},
	
	/**
	 * Reload the control basing on its master control's value
	 * @param {string} masterCtrlValue
	 * @param {object} updContext	 
	 */
	reload: function( masterCtrlValue, updContext ) {	
		if ( !this.multiSelectionAllowed && !this.displayElem.prop('readonly') ) {
			return;
		}
		Runner.controls.ListPageLookup.superclass.reload.call( this, masterCtrlValue, updContext );
	},	
	
	/**
	 * Check if suggests should be displayed for the control
	 * @return {boolean}
	 */
	implySuggests: function() {
		return !this.multiSelectionAllowed && !this.displayElem.prop('readonly');
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr true
	 * Sets hidden css style true for image selectLinkElem
	 * @method
	 */
	setDisabled: function() {
		var res = Runner.controls.ListPageLookup.superclass.setDisabled.call( this );
		
		if ( res && this.selectLinkElem ) {
			this.selectLinkElem
				.css('visibility', 'hidden')
				.addClass('disabled');
		}
		
		return res;
	},
	
	/**
	 * Overrides parent function for element control
	 * Sets disable attr false
	 * Sets visible css style true for image selectLinkElem
	 * @method
	 */
	setEnabled: function() {
		var res = Runner.controls.ListPageLookup.superclass.setEnabled.call( this );
		
		if ( res && this.selectLinkElem ) {
			this.selectLinkElem
				.css('visibility', 'visible')
				.removeClass('disabled');
		}
		
		return res;	
	},
	
	/**
	 * @param {number} valInd
	 */
	setValByInd: function( valInd ) {		
		var $option,
			linkVal = this.lookupVals[ valInd ].linkVal,
			dispVal = this.lookupVals[ valInd ].dispVal;
			
		if ( !this.multiSelectionAllowed ) {
			this.setLookupValue( linkVal, true, dispVal );
			return;
		}
		
		$option = this.getMultiselectOption( linkVal );
		
		if ( !$option.length ) {
			this.addMultiselectOption( linkVal, dispVal );
		}	
	},
	
	/**
	 * Add a new element to the lookupVals array property
	 * @param {string} linkVal
	 * @param {string} dispVal
	 * @return {number}			An index of the new added element
	 */	
	addLookupVal: function( linkVal, dispVal ) {
		return this.lookupVals.push( {'linkVal': linkVal, 'dispVal': dispVal} ) - 1;
	},
	
	/**
	 * Use for init link
	 * helper closure function, for sending correct ind link
	 * @param {jQuery object} link
	 * @param {number} ind
	 */
	initLink: function( $link, ind ) {
		var ctrl = this;
		
		$link.bind('click', function(e) {
			ctrl.setValByInd( ind );
			Runner.pages.PageManager.unregister( ctrl.lookupTable, ctrl.pageId );
			ctrl.setFocus();
			// for detail table on master add page
			ctrl.fireEvent("keyup");
			return false;
		});
	},
	
	/**
	 * Initialize links
	 * @param {number} winId
	 */
	initLinks: function( winId ) {	
		var ctrl = this,
			$links = $("a[type='lookupSelect" + winId + "']");
		
		this.setEnabled();
		
		$links.each( function( i, link ) {
			ctrl.initLink( $(link), i );
		});
	},
	
	/**
	 * Make the control 'readonly'
	 */
	makeReadonly: function() {
		Runner.controls.ListPageLookup.superclass.makeReadonly.call( this );
		this.selectLinkElem
			.addClass('disabled')
			.hide();
	},
	
	/**
	 * Make the control writable
	 */
	makeReadWrite: function() {
		Runner.controls.ListPageLookup.superclass.makeReadWrite.call( this );
		this.selectLinkElem
			.removeClass('disabled')
			.show();
	},
	
	/**
	 * @param {mixed} value
	 * @param {boolean} triggerEvent
	 * @param {object} updContext
	 */
	setValue: function( value, triggerEvent, updContext ) {
		Runner.controls.ListPageLookup.superclass.setValue.call( this, value, triggerEvent, updContext );	
		
		if ( this.multiSelectionAllowed ) {
			this.valueElem.trigger("chosen:updated");
		}
		return true;
	},
	
	/**
	 * Clone the value DOM element to submit
	 * @return {array}
	 */
	getForSubmit: function() {
		if ( !this.multiSelectionAllowed ) { 
			return Runner.controls.ListPageLookup.superclass.getForSubmit.call(this);
		}
		
		if ( !this.appearOnPage() ) {
			return [];
		}
		
		var cloneElem = this.valueElem.clone(),
			$options = $('option', cloneElem).prop('selected', true);
			
		if ( !$options.length ) {
			cloneElem.append('<option selected="selected" value=""></option>');
		}		
		
		return [ cloneElem ];
	},
	
	/**
	 * Return an escaped string value
	 * @param {Array} valueArray	 
	 * @return {string}
	 */
	getStringValue: function( valueArray ) { 
		if ( !this.multiSelectionAllowed ) {
			return Runner.controls.ListPageLookup.superclass.getStringValue.call( this );
		}
		
		var valsArr = valueArray || this.getValue( true ), i;
		
		for (i = 0; i < valsArr.length ;i++) {
			if ( valsArr[i].indexOf(',') !== -1 || valsArr[i].indexOf('"') !== -1 ) {
				valsArr[i] = '"' + valsArr[i].replace(/"/g, '""') + '"';
			}
		}
		
		return valsArr.join(",");		
	}, 
	
	/**
	 * Check if search suggests need initializing for the control
	 * @return {boolean}
	 */
	useSearchSuggests: function() {
		return this.mode === Runner.controls.constants.MODE_SEARCH && !this.multiSelectionAllowed && this.valueElem.data("usesuggests");
	}	
});

Runner.namespace('Runner.pages');

Runner.pages.constants = {
	NOT_TABLE_BASED_TNAME: ".global",
	
	PAGE_LIST: "list",
	PAGE_ADD: "add",
	PAGE_INLINE_ADD: "inline_add",
	PAGE_EDIT: "edit",
	PAGE_INLINE_EDIT: "inline_edit",
	PAGE_VIEW: "view",
	
	PAGE_SEARCH: "search",
	PAGE_REPORT: "report",
	PAGE_CHART: "chart",
	PAGE_DREPORT: "dreport",
	PAGE_DCHART: "dchart",
	PAGE_PRINT: "print",
	PAGE_REPORT_PRINT: "rprint",
	PAGE_EXPORT: "export",
	PAGE_IMPORT: "import",
	PAGE_ADMIN_MEMBERS: "admin_members",
	PAGE_ADMIN_RIGHTS: "admin_rights",
	PAGE_MASTER_INFO_LIST: "masterlist",
	PAGE_MASTER_INFO_PRINT: "masterprint",
	
	PAGE_REGISTER: "register",
	PAGE_MENU: "menu",
	PAGE_REMIND: "remind",
	PAGE_CHANGEPASS: "changepwd",
	PAGE_LOGIN: "login",

	PAGE_DASHBOARD: "dashboard",

	LIST_SIMPLE: 0,
	LIST_LOOKUP: 1,
	LIST_DETAILS: 3,
	LIST_AJAX: 4,
	RIGHTS_PAGE:  5,
	MEMBERS_PAGE:  6,
	LIST_DASHBOARD: 7,
	LIST_DASHDETAILS: 8,
	
	ADD_SIMPLE: 0,
	ADD_INLINE: 1,
	ADD_ONTHEFLY: 2,
	ADD_MASTER: 3,
	ADD_POPUP: 4,
	ADD_DASHBOARD: 5,
	ADD_MASTER_POPUP: 6,
	
	EDIT_SIMPLE: 0,
	EDIT_INLINE: 1,
	EDIT_ONTHEFLY: 2,
	EDIT_POPUP: 3,
	EDIT_DASHBOARD: 4,
	
	SEARCH_DASHBOARD: 1,
	
	MODE_AJAX: "ajax",
	MODE_SIMPLE: "",
	MODE_LOOKUP: "lookup",
	MODE_LIST_DETAILS: "listdetails",
	
	OPENMODE_POPUP: 1,
	OPENMODE_CONTAINER: 2,
	OPENMODE_PRELOADED: 3,
	OPENMODE_FULLSCREEN: 4,
	OPENMODE_DASHCONTAINER: 5,
	OPENMODE_TABVIEW: 6,
	
	DP_POPUP: 0,
	DP_INLINE: 1,
	DP_NONE: 2,
	
	SEARCH_OPTIONS: {
		"Contains": "contains",
		"Equals": "equals",
		"Starts with": "startswith",
		"More than": "morethan",
		"Less than": "lessthan",
		"Between": "between",
		"Empty": "empty", 
		"NOT Contains": "notcontain", 
		"NOT Equals": "notequal", 
		"NOT Starts with": "notstartwith",
		"NOT More than": "lessequal",
		"NOT Less than": "moreequal", 
		"NOT Between": "notbetween", 
		"NOT Empty": "notempty"
	},
	
	MINUS_GIF: Runner.getFullResourcePath("images/minus.gif"),
	PLUS_GIF: Runner.getFullResourcePath("images/plus.gif"),
	CLOSE_RED_GIF: "remove",
	OK_GIF: "iesave",
	CANCEL_GIF: "iecancel",
	
	HORIZONTAL_LAYOUT: 0,
	VERTICAL_LAYOUT: 1,
	COLUMNS_LAYOUT: 2,

	LOGIN_SEPARATE: 0,
	LOGIN_POPUP: 1,
	LOGIN_EMBEDED: 2,
	
	PORTRAIT_PRINT_ORIENTATION: 0,
	LANDSCAPE_PRINT_ORIENTATION: 1,
	
	STEPPED_LAYOUT: 0,
	BLOCK_LAYOUT: 1,
	OUTLINE1_LAYOUT: 2,
	ALIGN1_LAYOUT: 3,
	TABULAR_LAYOUT: 6,
	
	REPORT_MODE_PRINT_FRIENDLY: 0,
	REPORT_MODE_PRINT_WHOLE_REPORT: 1,
	
	REPORT_PRINT_PAGE_FIT: 0,
	REPORT_PRINT_FIXED_GROUPS: 1,
	
	REPORT_TYPE_STANDART: 0,
	REPORT_TYPE_CROSSTAB: 1,
	
	VPRINT_PAGE_WIDTH: 700,
	VPRINT_PAGE_HEIGHT: 900,
	
	HPRINT_PAGE_WIDTH: 1000,
	HPRINT_PAGE_HEIGHT: 700,
	
	/** 
	*	Dashboard element types 
	*/
	DASHBOARD_LIST: 0,
	DASHBOARD_CHART: 1,
	DASHBOARD_REPORT: 2,
	DASHBOARD_RECORD: 3,
	DASHBOARD_SEARCH: 4,
	DASHBOARD_DETAILS: 5
	
};
// create namespace
Runner.namespace('Runner.util.inlineEditing');

/**
 * Base abstract class for InlineAdd and InlineEdit
 * provides base functionality and event handling
 * @class Runner.util.inlineEditing.InlineEditor
 */
Runner.util.inlineEditing.InlineEditor = Runner.extend( Runner.util.Observable, {
	
	id: -1,
	
	tName: "",
	
	pageType: "",
	
	shortTName: "",
	
	rowPref: "gridRow",
	
	/**
	 * @type {array}
	 */
	rows: null,

	/**
	 * @type {array}
	 */	
	fNames: null,
	
	/**
	 * @type {array}
	 */		
	totalFields: null,
	
	/**
	 * @type {string}
	 */
	ajaxRequestUrl: "",

	/**
	 * @type {object}
	 */
	baseParams: null, 
	
	/**
	 * The host list page object
	 * @type {object}
	 */
	pageObj: null,
	
	/**
	 * @type {jQuery object}
	 */
	saveAllButt: null,

	/**
	 * @type {jQuery object}
	 */	
	cancelAllButt: null,

	lookupTable: "",
	
	categoryValue: "",
	
	lookupField: "",
	
	massRecButtEditMode: false,
	
	loadSettings: false,
	
	isEditOwn: false,
	
	isOldLayout: false,
	
	rowFocussed: false,
	
	classNameHidden: "",
	classNameRow: "", 
	classNameBottomRow: "",
	classNameMessage: "",
	classNameInlineError: "",
	classNameLocking: "",
	
	/**
	 * It shows if the object is set up 
	 * for a dashboard grid element
	 */
	dashGridBased: false,
	
	
	constructor: function( cfg ) {
		this.rows = [];
		this.fNames = [];
		this.baseParams = {};
		
		Runner.apply( this, cfg );
		Runner.util.inlineEditing.InlineEditor.superclass.constructor.call( this, cfg );	
		
		this.pageObj = Runner.pages.PageManager.getAt( this.tName, this.id ); 
		this.isEditOwn = Runner.pages.PageSettings.getTableData( this.tName, "isEditOwn" );
		this.totalFields = Runner.pages.PageSettings.getTableData( this.tName, "totalFields" );
		this.ajaxRequestUrl = Runner.getPageUrl( this.shortTName, this.pageType );
		this.listGridLayout = Runner.pages.PageSettings.getTableData(this.tName, "listGridLayout");
		
		this.assignClassNames();
		
		this.addEvents(
			'rowsEdited',
			'createControls',
			'beforeSubmit',
			'afterSubmit',
			'afterSave',
			'submitFailed',
			'beforeProcessNewRow',
			'revertRow',
			'validationFailed',
			'afterInit',
			'afterPageReady',
			'beforeRequestControls',
			'recalcGridSize',
			'beforeCancel',
			'cancel'
		);
	},

	/**
	 * Assign the class names properties
	 */
	assignClassNames: function() {
		var classPrefix = this.isOldLayout ? 'runner-' : 'rnr-';
			
		this.classNameHidden = classPrefix + "hiddenelem";
		this.classNameRow = classPrefix + "row";
		this.classNameBottomRow = classPrefix + "bottomrow";
		this.classNameMessage = classPrefix + "message";;
		this.classNameInlineError = classPrefix + "inline-error";
		this.classNameLocking = classPrefix + "locking";		
	},	
	
	/**
	 * Get submit URL
	 * @return {string}
	 */
	getSubmitUrl: function() {
		return Runner.getPageUrl( this.shortTName, this.pageType );
	},
	
	init: function() {	
		this.initButtons();
		this.initEvents();		
	},
	
	/**
	 * Subscribe handlers for default events ("afterInit", "afterPageReady")
	 */
	initEvents: function() {
		var events = Runner.pages.PageSettings.getTableEventsData( this.tName, this.pageType ),
			evName, eventHnArr, i;
			
		for ( evName in events ) {
			if ( evName !== 'afterInit' && evName !== 'afterPageReady' ) {
				continue;
			}
			
			eventHnArr = events[ evName ];
			for (i = 0; i < eventHnArr.length; i++) {
				this.on( evName, eventHnArr[i].hn, eventHnArr[i].scope || this.pageObj || this );
			}	
		}		
		
		this.on('rowsEdited', function() {
			this.toggleMassRecButt();
			this.calcTotals();
		}, this);			
	},

	/**
	 * Reinit inline object properties
	 * Use for example to ajax reload list page
	 * id and parId can be no need
	 * @param {Array} gridRows
	 */
	reInit: function( gridRows ) {
		this.rows = gridRows;
		if ( this.pageObj.pageMode === Runner.pages.constants.MODE_LIST_DETAILS ) {
			this.initButtons();
		}
	},
	
	/**
	 * UnSelect all records
	 */
	resetSelectAll: function() {
		var $selectAllButton = $('#select_all' + this.id);
		
		if ( $selectAllButton.length ) {
			$selectAllButton.get(0).checkAllStatus = false;
			$selectAllButton.html( Runner.lang.constants.SELECT_ALL );
		}
		if ( $('.chooseAll' + this.id).length ) {
			$('input[type="checkbox"][id^="chooseAll_' + this.id + '"]').prop("checked", false);
		}
	},
	
	/**
	 * Initialize 'Save all', 'Cancel' and 'Edit selected' buttons.
	 * Add corresponding props to the inline object and add on click
	 * handlers to 'Save all' and 'Cancel' buttons.
	 * As for the 'Cancel' button's on click handler doesn't depends
	 * only on base class props It's initialised once
	 */
	initButtons: function() {
		var inlineObj = this;
		
		this.editAllButt = $("a[id=edit_selected" + this.id + "]");
		this.cancelAllButt = $("a[id=revertall_edited" + this.id + "]");
		this.saveAllButt = $("a[id=saveall_edited" + this.id + "]").bind("click", function(e) {
			inlineObj.saveAll();
			inlineObj.resetSelectAll();
			return false;
		});
		
		//cancelAll and resetSelectAll don't depend on a patricular 'this' object
		if ( !this.pageObj.inlineButtonsIntialized ) {
			this.cancelAllButt.bind("click", function(e) {
				inlineObj.cancelAll();
				inlineObj.resetSelectAll();
				return false;
			});
		}
		this.pageObj.inlineButtonsIntialized = true;
	},
	
	/**
	 * Reinitialize the 'Save all', 'Cancel' and 'Edit selected' buttons.
	 */
	reinitButtons: function() {
		this.initButtons();
	},

	/**
	 * @param {string} val
	 * @param {string} format
	 * @return {number}
	 */
	parseForTotals: function( val, format ) {
		if ( format == 'Time' ) {
			var timeArr = val.split(':');
			
			if ( timeArr.length !== 3 ) {
				return '';
			}
					
			return parseInt(timeArr[2], 10) + parseInt(timeArr[1], 10) * 60 + parseInt(timeArr[0], 10) * 3600;
		}

		if ( format == 'Number' ) {
			return parseFloat( val.replace(',', '.') );
		}
		
		return parseFloat( val.toString().trim() ); 
	},
	
	/**
	 * Update the 'Total' value for the field 
	 * @param {string} fName
	 * @param {string} format	The total field's view format
	 */		
	calcTotalField: function( fName, format ) {
		var i, fVal, s, m, h, d,
			totalVal = 0;
		
		for (i = 0; i < this.rows.length; i++) {
			if ( !this.rows[i].data || this.rows[i].data[ fName ] === undefined ) {
				this.getValuesFromSpan( this.rows[i] );
			}
			
			fVal = this.parseForTotals( this.getValueFromSpan( this.rows[i], fName ), format );	
			
			if ( isNaN(fVal) ) { 
				continue;
			}
			
			totalVal += fVal;
		}
		
		if (format == 'Time') {
			s = totalVal % 60;
			totalVal -= s;
			totalVal /= 60;
			m = totalVal % 60;
			totalVal -= m;
			totalVal /= 60;
			h = totalVal % 24;
			totalVal -= h;
			totalVal /= 24;
			d = totalVal;
			totalVal = (d > 0 ? d + 'd ' : '') + (h == 0 ? '00' : h) + ':' + (m > 9 ? m : (m == 0 ? '00' : '0' + m)) + ':' + (s > 9 ? s : (s == 0 ? '00' : '0' + s));
		} 
		
		$("#total" + this.id + "_" + Runner.goodFieldName( fName )).html( totalVal );
	},
	
	/**
	 * Update 'COUNT' value for the total field (fName)
	 * Set the obtained value as html for the correspondig jQuery element
	 * @paran {string} fName
	 * @paran {string} format	The total field's view format
	 */
	calcCountField: function( fName, format ) {
		var fVal, i, row, fieldSpan,
			totalVal = 0,
			gfName = Runner.goodFieldName( fName ),
			totalId = "total" + this.id + "_" + gfName;
			
		for (i = 0; i < this.rows.length; i++) {
			row = this.rows[ i ];
			
			if ( row.rowVals && typeof row.rowVals[ fName ] === "string" ) {
				fVal = row.rowVals[ fName ].trim();
			} else {
				fieldSpan = Runner.getFieldSpan( fName, row.id );
				fVal = fieldSpan.attr("val").trim();
			}
			
			if ( fVal ) {
				totalVal++;
			}
		}
		
		$("#" + totalId).html( totalVal );
	},
	
	/**
	 * Update the 'Average' value for the field 	
	 * @param {string} fName
	 * @param {string} format	The total field's view format
	 */		
	calcAverageField: function( fName, format ) {
		var i, fVal, s, m, h, d,
			totalVal = 0, 
			numRows = 0;
			
		for (i = 0; i < this.rows.length; i++) {
			if ( !this.rows[i].data || this.rows[i].data[ fName ] === undefined ) {
				this.getValuesFromSpan( this.rows[i] );
			}
			
			fVal = this.parseForTotals( this.getValueFromSpan( this.rows[i], fName ), format );
			
			if ( isNaN(fVal) ) {
				continue;
			}
			
			totalVal += fVal;
			numRows += 1;
		}
		
		if ( format == 'Time' && numRows ) {
			totalVal = Math.round(totalVal / numRows);
			s = totalVal % 60;
			totalVal -= s;
			totalVal /= 60;
			m = totalVal % 60;
			totalVal -= m;
			totalVal /= 60;
			h = totalVal % 24;
			totalVal -= h;
			totalVal/=24;
			d = totalVal;
			totalVal = (d > 0 ? d + 'd ' : '') + (h == 0 ? '00' : h) + ':' + (m > 9 ? m : (m == 0 ? '00' : '0' + m)) + ':' + (s > 9 ? s : (s == 0 ? '00' : '0' + s));
		} else if ( numRows ) {
			totalVal = Math.round((totalVal / numRows) * 100) / 100;
		} else {
			totalVal = "";
		}
		
		$("#total" + this.id + "_" + Runner.goodFieldName( fName )).html( totalVal );
	},
	
	/**
	 * Count for total fields the corresponding total function's value.
	 * Show the obtained value in the total's row 
	 */		
	calcTotals: function() {
		if ( this.pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP || !this.totalFields.length ) { 
			return;
		}
		
		var totalsTr, i, totalField;
		
		for (i = 0; i < this.totalFields.length; i++) {
			totalField = this.totalFields[i];
			
			if ( totalField.type == "TOTAL" ) {
				this.calcTotalField( totalField.fName, totalField.format );
				continue;	
			}
			if ( totalField.type == "COUNT" ) {
				this.calcCountField( totalField.fName, totalField.format );
				continue;
			}
			if ( totalField.type == "AVERAGE" ) {
				this.calcAverageField( totalField.fName, totalField.format );
			}
		};
		
		totalsTr = $('tr[rowid="totals"]', this.pageObj.gridElem);
		if ( totalsTr.css('display') == 'none') {
			totalsTr.show();
		}
	},
	
	/**
	 * Assign the row's basicForm property with the Runner BasicForm object reference
	 * or if it's alredy assigned update its properties
	 * @param {object} row
	 */		
	initForm: function( row ) {
		row.basicForm = row.basicForm || this.createRowForm( row ); 

		// add/update form properties dependent on the row's state
		row.basicForm.id = row.id;
		row.basicForm.setFocus = !this.rowFocussed;
		row.basicForm.baseParams.id = row.id;
		row.basicForm.fieldControls = Runner.controls.ControlManager.getAt( this.tName, row.id );
	},
	
	/**
	 * Create a form for a particular row
	 * @param {object} row 
	 * @return {object}
	 */
	createRowForm: function( row ) {
		var inlineObj = this,
			baseParams = Runner.apply( this.baseParams, {
				id: row.id, 
				editType: 'inline',
				a: this.pageType === Runner.pages.constants.PAGE_ADD ? 'added' : 'edited', 
			});
			
		return new Runner.form.BasicForm({
			isFileUpload: true,
			submitUrl: this.getSubmitUrl(),
			baseParams: baseParams,
			successSubmit: {
				fn: function( respObj, formObj, fieldControls ) {
					if (!respObj.success) {
						if (respObj.fatalError) {
							formObj.clearForm();
						}
						this.fireEvent("submitFailed", respObj, this, formObj, fieldControls);											
						inlineObj.makeError( respObj.message, row );	
					} else {
						if (respObj['nonEditable']) {
							row.isEditable = false;
						}
						this.afterSubmit(row, respObj);
						if (typeof row.onAfterSubmit != "undefined") {
							row.onAfterSubmit();
						}
					}
					if (row.saveLink) {
						row.saveLink.removeClass('disabled');
					}
				},
				scope: this
			},
			submitFailed: {
				fn: function(respObj, formObj, fieldControls) {
					if (respObj.success === false) {
						this.makeError( respObj.message, row );
					} else {
						this.makeError( respObj, row );
					}
					this.fireEvent("submitFailed", {}, this, formObj, fieldControls);
					if (row.saveLink) {
						row.saveLink.removeClass('disabled');
					}
				},
				scope: this
			},
			beforeSubmit: {
				fn: function(formObj) {
					if (typeof row.onBeforeSubmit != "undefined") {
						var rowBeforeResult = row.onBeforeSubmit();
						if (rowBeforeResult === false) {
							return false;
						}
					}
					return this.fireEvent("beforeSubmit", row, this, formObj);
				},
				scope: this
			},
			validationFailed: {
				fn: function(formObj, fieldControls) {
					this.fireEvent("validationFailed", formObj, fieldControls);
					inlineObj.rowFocussed = true;
					if (row.saveLink) {
						row.saveLink.removeClass('disabled');
					}
				},
				scope: this
			}
		});
	},
	
	/**
	 * Cancel all Inline Add/Edit for all grid's rows
	 */
	cancelAll: function() {
		var canceledAll = true;
		for (var i = 0; i < this.rows.length; i++) {
			if (!this.rows[i].submitted) {
				if (this.rows[i].isAdd) {
					if (Runner.util.inlineEditing.InlineAdd.prototype.cancelButtonHn.call(this, this.rows[i],true)) {	
						i--;
					} else {
						canceledAll = false;
					}
				} else if (this.pageObj.inlineEdit) {
					this.pageObj.inlineEdit.cancelButtonHn(this.rows[i], true);
				}
			}
		}
		if ( canceledAll ) {
			this.fireEvent("recalcGridSize");
			this.toggleMassRecButt();
		}
	},
	
	/**
	 * @param {object} row
	 */
	submit: function( row ) {
		row.revertted = false;
		this.initForm( row );
		row.basicForm.submit();	
	},
	
	/**
	 * Save all Inline Add/Edit grid's rows
	 */
	saveAll: function() {
		var allVals = [], allKeys = [], allRowIds = [];
		
		this.rowFocussed = false;
		
		for (var i = 0, l = this.rows.length; i < l; i++) {
			allVals.push( this.rows[i].data );
			allKeys.push( this.rows[i].keys );
			allRowIds.push( this.rows[i].id );
			
			if ( this.rows[i].submitted === false && this.rows[i].cancelLink.length ) {
				return false;
			}
		}
		// fire rowsEdited event if all rows submited
		this.fireEvent('rowsEdited', allVals, this.fNames, allKeys, allRowIds);
		return true;
	},
	
	/**
	 * The default cancel button's click handler
	 */ 
	cancelButtonHn: function() {	
		$('div.shiny_box').hide();
	},
	
	/**
	 * Load and show the row's controls
	 * @param {object} pageObj
	 * @param {object} row
	 * @param {boolean} hideRevertButt
	 * @param {boolean} hideSaveButt
	 */
	getControls: function( pageObj, row, hideRevertButt, hideSaveButt ) {
		var i, ind, 
			inlineObject = this, 
			masterKeys = pageObj.controlsMap.masterKeys,
			reqParams = {
				editType: "inline",
				id: row.id,
				mainMPageType: Runner.pages.PageSettings.getTableData(this.tName, "mainMPageType") || "",
				isNeedSettings: !Runner.pages.PageSettings.checkSettings(this.tName) || this.loadSettings,
				table: Runner.pages.PageSettings.getShortTName(this.lookupTable), 
				field: Runner.goodFieldName(this.lookupField), 
				category: this.categoryValue,
				screenWidth: window.screen.width,
				screenHeight: window.screen.height,
				orientation: Runner.getOrientation()
			};
		if ( this.dashGridBased && this.pageObj ) {
			reqParams['dashTName'] = this.pageObj.dashboard.tName;
		}
		for (ind in masterKeys) {
			reqParams[ ind.toLowerCase() ] = masterKeys[ ind ];
		}
		
		this.fireEvent('beforeRequestControls', this, row, reqParams);
		
		for (i = 0; i < row.keys.length; i++) {
			reqParams['editid' + (i + 1)] = row.keys[i];
		}
		
		Runner.runnerAJAX( this.ajaxRequestUrl, reqParams, function( ctrlsJSON ) {
			if ( ctrlsJSON.success !== false ) {
				if ( inlineObject.loadSettings && ctrlsJSON.settings ) {
					// add settings
					Runner.pages.PageSettings.addSettings( inlineObject.tName, ctrlsJSON.settings, false );
				}
				
				var init = function() {
					inlineObject.makeRowEditable( row, ctrlsJSON );					
					inlineObject.lockRow( row, ctrlsJSON );
					 
					inlineObject.getEditBlock( row, hideRevertButt, hideSaveButt );
					// the inline record's markup is ready
					inlineObject.setFocusOntheFirstControl( row );	
					if ( Runner.pages.PageSettings.getGlobalData("s508") )
						inlineObject.pageObj.s508Obj.s508inlineSaveCancel(row.id);
						
					inlineObject.fireEvent('afterInit', inlineObject.pageObj, inlineObject.pageObj.proxy, row.id, row, inlineObject);
				};
				
				if ( ctrlsJSON.additionalCSS ) {
					Runner.util.ScriptLoader.loadCSS( ctrlsJSON.additionalCSS );
				}
				
				if ( ctrlsJSON.additionalJS ) {
					for (var jsFile in ctrlsJSON.additionalJS) {
						Runner.util.ScriptLoader.addJS( [jsFile], ctrlsJSON.additionalJS[ jsFile ] );
					}
											
					Runner.util.ScriptLoader.onFilesLoaded( function() { 
						init();
						inlineObject.fireEvent('afterPageReady', inlineObject.pageObj, inlineObject.pageObj.proxy, row.id, row, inlineObject);
					}, inlineObject );	
						
					Runner.util.ScriptLoader.load();
					return;	
				}
				init();
			}
			inlineObject.makeError( ctrlsJSON.message, row );
			inlineObject.showRowButtons( row );
		});	
	},		
	
	/**
	 * Add the contorl's markup, add controls to controls' fabric 
	 * initialize the record's functionality (tooltips, buttons)
	 * @param {object} row
	 * @param {object} ctrlsJSON
	 */
	makeRowEditable: function( row, ctrlsJSON ) {
		var ctrlsMap = ctrlsJSON.controlsMap[ this.tName ][ this.pageType ][ row.id ].controls,
			ctrlsArr = [], 
			spanCont, i, parentCtrl;
		
		for (i = 0; i < this.fNames.length; i++) {
			spanCont = Runner.getFieldSpan( this.fNames[i], row.id );
			if ( row.isAdd ) {
				spanCont.append( ctrlsJSON['html'][ this.fNames[i] ] );
				continue;
			} 
			spanCont.html( ctrlsJSON['html'][ this.fNames[i] ] );
		}
			
		for (i = 0; i < ctrlsMap.length; i++) {
			if ( $.inArray( ctrlsMap[i].fieldName, this.fNames ) === -1 ) {
				continue;
			}

			ctrlsMap[i].table = this.tName;
			ctrlsArr.push( Runner.controls.ControlFabric( ctrlsMap[i], this.pageType, true ) );
		}
		
		for (i = 0; i < ctrlsArr.length; i++) { 
			if ( !ctrlsArr[i].isLookupWizard || !ctrlsArr[i].parentFieldName || ctrlsArr[i].skipDependencies === true ) {
				continue;
			}
			parentCtrl = Runner.controls.ControlManager.getAt( this.tName, row.id, ctrlsArr[i].parentFieldName );
			ctrlsArr[i].setParentCtrl( parentCtrl ); 
			if ( parentCtrl && parentCtrl.isLookupWizard ) {
				parentCtrl.addDependentCtrls( [ ctrlsArr[i] ] );
			}
		}
		
		Runner.pages.RunnerPage.prototype.initToolTips.call( this.pageObj, ctrlsJSON.controlsMap[ this.tName ][ this.pageType ][ row.id ].toolTips,this.tName );
		
		this.fireEvent('createControls', row, ctrlsArr);
	},
	
	/**
	 * Set focus on the first record's contorl
	 * Used when record is opened for the first time
	 * @param {object} row
	 */
	setFocusOntheFirstControl: function( row ) {
		if ( this.pageObj.pageMode === Runner.pages.constants.MODE_LIST_DETAILS && 
			 Runner.pages.PageManager.getAt( this.pageObj.masterTName, this.pageObj.parId ).pageType === Runner.pages.constants.PAGE_ADD ) {
			return;
		}
		
		Runner.pages.RunnerPage.prototype.setFirstFocus.call( this.pageObj, row.id );
	},
	
	/**
	 * @param {object} row
	 * @param {boolean} hideSaveButt
	 */
	getSaveLink: function( row, hideSaveButt ) {
		var inlineObj = this, 
			$link, $imgButt;
		
		if ( row.saveLink && row.saveLink.length && !hideSaveButt ) {
			row.saveLink.show();
			return row.saveLink;
		} else if ( hideSaveButt ) {
			return false;
		}
		
		$link = $('<a id="saveLink' + row.id + '" href="#" data-icon="' + Runner.pages.constants.OK_GIF + '"></a>')
			.attr('title', Runner.lang.constants.TEXT_SAVE)
			.addClass('saveEditing');
		
		if ( hideSaveButt ) {
			$link.css('display', 'none');
		}
		
		$link.bind("click", function(e) {				
			if ( row.saveLink.hasClass('disabled') ) {
				return false;
			}
			// flag for details recount
			row.saveLink.addClass('disabled');
			row.fileFieldsCount = 0;
			row.upploadErrorHappened = false;
			
			$('div.shiny_box').hide();

			inlineObj.rowFocussed = false;
			inlineObj.fromSaveBtn = true;
			inlineObj.waitForFilesUpload(row);
			return false;
		});
		
		return row.saveLink = $link;
	},
	
	/**
	 * @param {object} row
	 */
	waitForFilesUpload: function( row ) {
		var inlineObj = this, index,
			controls = Runner.controls.ControlManager.getAt( this.tName, row.id );
		
		for (index = 0; index < controls.length; index++) {
			if (controls[index].editFormat == Runner.controls.constants.EDIT_FORMAT_FILE
				&& controls[index].filesToUploadCount > 0) {
				row.fileFieldsCount++;
				controls[index].errorHappened = false;
				controls[index].uploadForm.bind('fileuploadstopped', { ctrl: controls[index] }, function(e, data) {
					row.fileFieldsCount--;
					$(this).unbind('fileuploadstopped');
					if (e.data.ctrl.errorHappened) {
						row.upploadErrorHappened = true;
						inlineObj.errorHn(row);
					} else {
						inlineObj.callSaveHn(row);
					}
				});
				$(".btn-primary.start", controls[index].uploadForm).click();
			} 
		}
		
		if ( row.fileFieldsCount < 1 ) {
			this.callSaveHn( row );
		}
	},
	
	/**
	 * @param {object} row
	 */
	errorHn:function( row ) {
		if ( row.fileFieldsCount < 1 ) {
			row.saveLink.removeClass('disabled');
		}
	},
	
	/**
	 * @param {object} row
	 */	
	callSaveHn: function( row ) {
		if ( row.fileFieldsCount < 1 && !row.upploadErrorHappened ) {
			this.submit( row );
			this.toggleMassRecButt();
			this.resetSelectAll();
			
		}
	},
	
	/**
	 * @param {object} row
	 * @param {boolean} hideRevertButt
	 */
	getCancelLink: function( row, hideRevertButt ) {
		var inlineObj = this,
			$link, $imgButt;
		
		if ( row.cancelLink && row.cancelLink.length && !hideRevertButt ) {
			row.cancelLink.show();
			return row.cancelLink;
		} 
		
		$link = $('<a id="revertLink' + row.id + '" href="#" data-icon="' + Runner.pages.constants.CANCEL_GIF + '"></a>')
			.attr('title', Runner.lang.constants.TEXT_CANCEL)
			.addClass('revertEditing');
			
		if ( hideRevertButt ) {
			$link.css('display', 'none');
		}
		
		$link.bind("click", function(e) {
			inlineObj.cancelButtonHn( row );
			if ( inlineObj.rows.length !== 0 ) {
				inlineObj.toggleMassRecButt();
			}
			inlineObj.resetSelectAll();

			return false;
		});
		
		return row.cancelLink = $link;
	},	
	
	/**
	 * Show the 'Save' and 'Cancel' button's in the editable row's header
	 * @param {object} row
	 * @param {boolean} hideRevertButt
	 * @param {boolean} hideSaveButt
	 */
	getEditBlock: function( row, hideRevertButt, hideSaveButt ) {
		if ( !row.saveLink || !row.saveLink.length || !row.cancelLink || !row.cancelLink.length ) {
			if (row.iEditLink.length) {
				row.iEditLink
					.after( this.getCancelLink( row, hideRevertButt ) )
					.after( this.getSaveLink( row, hideSaveButt ) );
			} else {
				var span, i;
				for (i = 0; i < this.fNames.length; i++) {
					span = Runner.getFieldSpan( this.fNames[i], row.id )
					if ( span.length ) {
						span.prepend( this.getCancelLink( row, hideRevertButt ) )
							.prepend( this.getSaveLink( row, hideSaveButt ) );
						break;
					}
				}
			}
			return;
		}
		
		this.getCancelLink( row, hideRevertButt );
		this.getSaveLink( row, hideSaveButt );
	},
	
	/**
	 * @param {object} row
	 */
	revertRow: function( row ) {
		// clear controls
		Runner.controls.ControlManager.unregister(this.tName, row.id);
		this.fireEvent('revertRow', row);
	},
	
	removeRowData: function( row, ind ) {
		if ( row.basicForm && row.basicForm.destructor ) {
			row.basicForm.destructor();
		}
		
		if ( row.row ) {
			row.row.remove();
		}
		if ( row.srow ) {
			row.srow.remove();
		}
		
		if ( this.rows.length === 1 ) {
			// hide the grid table
			this.pageObj.hideBrick("grid");
			$("thead tr, tr.footer, tr." + this.classNameBottomRow, this.pageObj.gridElem).addClass( this.classNameHidden );

			this.toggleRecordControlButtons( false );
		}
		
		return this.rows.splice( ind || this.getRowInd( row ), 1 );
	},
	
	/**
	 * Get the row index in the rows array
	 * @param {object} row
	 * @return {number}
	 */
	getRowInd: function( row ) {
		for (var i = 0; i < this.rows.length; i++) {
			if ( this.rows[i].id === row.id ) {
				return i;
			}
		}
		return -1;
	},
	
	getRowById: function( rowId ) {
		for (var i = 0; i < this.rows.length; i++) {
			if ( this.rows[i].id === parseInt( rowId, 10 ) ) {
				return this.rows[i]; 
			}
		}
		return false;
	},
	
	/**
	 * Show the row's 'Error ocirred >>' link that 
	 * show the error message on 'mouseover' 
	 * and hide it on 'mouseout' 	
	 * @param {string} msg
	 * @param {object} row
	 */
	makeError: function( msg, row ) {
		row.errorMess = msg;

		if ( !this.pageObj.gridElem ) {
			return;
		}

		if ( !row.errorDiv ) {
			var inlineObj = this,
				//get the first span in a row
				$span = $("span[id^=edit" + row.id + "_]:eq(0)", this.pageObj.gridElem),
				$errorLink = $('<a href="#" id="error_' + row.id + '" style="white-space:nowrap;"></a>').html( Runner.lang.constants.TEXT_INLINE_ERROR +' >>' );
				
			row.errorDiv = $("<div></div>")
				.addClass( this.classNameInlineError )
				.append( $errorLink )
				.appendTo( $span );
						
			
			if ( !this.errCont ) {	
				this.errCont = $("<div></div>")
					.addClass( "error" )
					.addClass( this.classNameMessage )
					.appendTo( document.body )
					.hide();
			}
			
			$errorLink
				.bind("mouseenter", function(e) {
					var errorPos = $errorLink.offset(),
						topPos = errorPos.top,
						adjustment;
						
					topPos += $errorLink.height();
					
					adjustment = $(document).height() - topPos - inlineObj.errCont.height();
					// check if an error is showing outside of the document
					if ( adjustment < 0 ) {
						// move the error container to a better place to make it possible to read it in full
						errorPos += adjustment;
					}
					
					inlineObj.errCont.css({
							"top": topPos + "px",
							"left": errorPos.left + $errorLink.width() + "px",
							"z-index": 100,
							"position": "absolute"
						})
						.show();
				})
				.bind("mouseleave", function(e) {
					inlineObj.errCont.hide();
				});
		}
		this.errCont.html( msg );
	},
	
	/**
	 * Remove the row's error container
	 * @param {object} row
	 */
	clearError: function( row ) {
		delete row.errorMess;
		if ( row.errorDiv ) {
			row.errorDiv.remove();
			delete row.errorDiv;
		}
	},
	
	/**
	 * A handler that is invoked after an inline row is submitted
	 * ( on the row's form successSubmit event or add popup was saved )
	 * @param {object} row			An inline row object
	 * @param {object} newData
	 * @param {object} extPageObj		A reference to a pop-up or dash page object (optional). 
	 */
	afterSubmit: function( row, newData, extPageObj ) {
		var checkBoxVals, i;
		
		this.fireEvent("beforeProcessNewRow", row, newData.vals, newData.fields, newData.keys);
		
		// add new data from server to row object
		row.data = Runner.apply( {}, newData.vals ); //shown data in grid
		row.keys = newData.keys;
		row.keyFields = newData.keyFields;
		row.rowVals = newData.rawVals; // data from BD
		
		// delete controls
		Runner.controls.ControlManager.unregister( this.tName, row.id );
		
		// proccess checkbox
		if ( row.checkBox.length && !newData.noKeys ) {
			checkBoxVals = [];
			
			for ( i = 0; i < newData.keys.length; i++ ) {
				checkBoxVals.push( newData.keys[i] );
			}

			row.checkBox
				.val( checkBoxVals.join( "&" ) )
				.prop("checked", false)
				.show();			
		}
		
		if ( !newData.noKeys ) {
			this.changeLinksKeys( row );
		}
		
		this.checkRowMasterKeys( row, newData.detKeys );
		
		if ( newData.hrefs ) {
			for (i = 0; i < newData.hrefs.length; i++) {
				$("#" + newData.hrefs[i].id + row.id).attr("href", newData.hrefs[i]["href"]);
			}
		}		
		
		// add values to lookupVals
		if ( this.pageObj.baseParams && this.pageObj.baseParams.mode == "lookup" && newData.linkValue ) {
			newData.vals[ this.pageObj.lookupCtrl.linkField ] = newData.linkValue;
			newData.vals[ this.pageObj.lookupCtrl.dispFieldAlias ? this.pageObj.lookupCtrl.dispFieldAlias : this.pageObj.lookupCtrl.dispField ] = newData.displayValue;
		}
		
		// change row to simple grid row with no editBoxes
		this.setValuesIntoSpans( row );
		if ( newData.noKeys !== true ) {
			this.showRowButtons( row );
		}
		
		// set submitted attr
		row.submitted = true;
		row.isAdd = false;
		this.fireEvent('afterSubmit', newData.vals, newData.fields, newData.keys, row.id, newData, extPageObj);
		
		if ( row.basicForm ) {
			setTimeout( function() {
				row.basicForm.destructor();
				row.basicForm = null;
			}, 0);
		}		
		
		if ( this.rows.length === 1 ) {
			this.pageObj.hideBrick("message");
		}
		if ( Runner.pages.PageSettings.getGlobalData("s508") )
			this.pageObj.s508Obj.s508setFocusToRow(row.id);				
	},
	
	/**
	 * @param {Object} row
	 */	
	fireUserEventAfterInline: function( row ) {
		var fieldsData = [], i;
		//make fileds data for user event
		for (i = 0; i < this.fNames.length; i++) {
			fieldsData[i] = {
				name: this.fNames[i],
				value: row.rowVals[ this.fNames[i] ],
				text: row.data[ this.fNames[i] ],
				container: Runner.getFieldSpan( this.fNames[i], row.id )
			};
		}
		//fire after save
		this.fireEvent("afterSave", fieldsData);
		//set user data to row
		for (i = 0; i < this.fNames.length; i++) {
			row.rowVals[ this.fNames[i] ] = fieldsData[i].value;
			row.data[ this.fNames[i] ] = fieldsData[i].text;
		}
	},
	
	/**
	 * @param {Object} row
	 * @return {Object}
	 */
	setValuesIntoSpans: function( row ) {
		var inlineObj = this,
			fName, pos, fSpan, viewFormat, i, j;
		
		this.fireEvent("beforeSetVals", row, this.fNames);
		
		if ( !row.revertted ) {
			this.fireUserEventAfterInline( row );
		}
		
		for (i = 0; i < this.fNames.length; i++) {
			fName = this.fNames[ i ];
			
			if ( typeof row.data[ fName ] === "undefined" ) {
				row.data[ fName ] = "";
				pos = $.inArray( fName, row.keyFields );
				if ( pos !== -1 ) {
					row.data[ fName ] = row.keys[ pos ].toString();
				}
			}
			
			fSpan = Runner.getFieldSpan( fName, row.id ) 
				.html( row.data[ fName ] );
			
			for (j = 0; j < this.totalFields.length; j++) {
				if ( this.totalFields[j].fName === fName ) {
					fSpan.attr('val', row.rowVals && row.rowVals[ fName ] ? row.rowVals[ fName ] : "");
					break;
				}
			}
			
			viewFormat = Runner.pages.PageSettings.getFieldData(this.tName, fName, 'viewFormat', this.pageType);
			if ( viewFormat !== Runner.controls.constants.FORMAT_MAP && viewFormat !== Runner.controls.constants.FORMAT_FILE_IMAGE ) {
				fSpan.find('img').each( function( index, image ) {
					var src = $(image).attr( 'src' );
					$(image).attr( 'src', inlineObj.replaceRndVal( src ) );
				});	
				fSpan.find('a').each( function( index, link ) {
					var href = $(link).attr( 'href' );
					$(link).attr( 'href', inlineObj.replaceRndVal( href ) );
				});					
			}
		}
		
		this.initRowViewControls( row );
		
		return row.data;
	},
	
	/**
	 * Init view updated field's view controls
	 * @param {Object} row
	 */
	initRowViewControls: function( row ) {
		if ( !this.pageObj.viewControlsMap || !this.pageObj.viewControlsMap.controls ) {
			return;
		}
		
		var rowContext = $('#' + this.rowPref + row.contextRowId),
			i, ctrl;
		
		for (i = 0; i < this.pageObj.viewControlsMap.controls.length; i++) {
			this.pageObj.viewControlsMap.controls[i].table = this.pageObj.tName;
			ctrl = Runner.viewControls.ViewControlFabric( this.pageObj.viewControlsMap.controls[i],	this.pageObj.pageType, rowContext, this.pageObj);
			
			if ( typeof ctrl.initInline === "function" ) {
				ctrl.initInline(row);
				continue;
			} 
			
			ctrl.init();
		}		
	},
	
	/**
	 * @param {string} src
	 * @return {string}
	 */
	replaceRndVal: function( src ) {
		if (!src) {
			return "";	
		}
		
		var rndValPos = src.indexOf('rndVal='),
			endPos;
			
		if (rndValPos === -1) {
			return src + (src.indexOf('?') != -1 ? "&" : "?") + "rndVal=" + Math.random();
		}
		endPos = src.indexOf('&', rndValPos);
		return src.slice(0, rndValPos + 7) + Math.random() + (endPos !== -1 ? src.slice(endPos) : '');
	},
	
	/**
	 * Fill up the row's 'data' object with html content of row fields' spans
	 * @param {object} row
	 */
	getValuesFromSpan: function( row ) {
		var fSpan, images, i, j;
		
		row.data = {};
		
		for (i = 0; i < this.fNames.length; i++) {
			fSpan = Runner.getFieldSpan( this.fNames[i], row.id );
			
			if ( $('.sudoslider', fSpan).length ) {
				images = "";
				$('li', fSpan).each( function( index, sliderPanel ) {	
					images += '<li>' + $(sliderPanel).html() + '</li>';
				});
				images = images ? '<div style="position:relative;"><div class="presudoslider"><ul>' + images + "</ul></div></div>" : images;					
				
				row.data[ this.fNames[i] ] = images;
				continue;
			} 
			
			$('.projekktor', fSpan).each( function(j, videoElement) {
				var vElementId = $(videoElement).attr("id"),
					playList = projekktor(vElementId).getPlaylist();
				
				projekktor( vElementId ).setStop().selfDestruct();

				if ( playList.length && playList[0].file.length ) {
					$( fSpan.find('video').get(j) ).attr({
						"src": playList[0].file[0].src,
						"type": playList[0].file[0].type
					});
				}
			});

			row.data[ this.fNames[i] ] = fSpan.html();
		}
	},
	
	/**
	 * @param {object} row
	 * @param {string} fName
	 * @return {string}
	 */		
	getValueFromSpan: function( row, fName ) {
		if ( row.rowVals && row.rowVals[ fName ] ) {
			return row.rowVals[ fName ];
		}
		
		var span = Runner.getFieldSpan( fName, row.id ),
			val = span.attr('val');
		
		return !val && row.data[ fName ] != null ? row.data[ fName ] : val;
	},
	
	/**
	 * @param {jQuery object} $link
	 * @param {object} row
	 * @return {jQuery object}
	 */	
	initCopyLink: function( $link, row ) {
		if ( !Runner.pages.PageSettings.getTableData(this.tName, "showAddInPopup") ) {
			return $link;
		}
		
		var inlineObj = this;
		
		return $link.bind("click", function(e) {
			var pageParams = {
				tName: inlineObj.tName, 
				pageType: Runner.pages.constants.PAGE_ADD, 
				modal: true, 
				keys: row.keys,
				keyFields: row.keyFields,
				keyPref: "copyid",
				baseParams: {
					parId: inlineObj.id,
					table: inlineObj.tName,
					editType: Runner.pages.constants.ADD_POPUP
				},
				afterSave: {
					fn: function(respObj, formObj, fieldControls, page) {
						if ( respObj.success ) {
							this.addRowToGrid( respObj );
							return true;		
						} 
						return false;				
					},
					scope: inlineObj
				}
			};
			
			Runner.pages.PageManager.openPage( pageParams );
			return false;
		});
	},
	
	/**
	 * Initialize the row's checkbox
	 * @param {jQuery object} $checkbox
	 * @return {jQuery object}
	 */	
	initCheckBox: function( $checkbox ) {
		$checkbox.parent().on( "click", function( e ) {
			if ( !$checkbox.is( e.target ) ) {
				$checkbox.trigger( "click" );
			}
		});
		
		return $checkbox;
	},
	
	/**
	 * @param {object} row	An inline row object
	 * Update 'href' attributes for a record's links
	 */		
	changeLinksKeys: function( row ) {		
		$( row.viewLink ).attr('href', Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_VIEW, row.keys, 'editid' ) );	
		$( row.editLink ).attr('href', Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_EDIT, row.keys, 'editid' ) );
		$( row.copyLink ).attr('href', Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_ADD, row.keys, 'copyid' ) );
	},

	/**
	 * @param {jQuery object} $link
	 * @param {object} row
	 * @return {jQuery object}
	 */	
	initViewLink: function( $link, row ) {
		if ( !Runner.pages.PageSettings.getTableData(this.tName, "showViewInPopup") || Runner.isMobile ) {
			return $link;
		}
		
		var inlineObj = this;
		
		return $link.bind("click", function(e) {				
			inlineObj.pageObj.hideBrick('message');
			
			var pageParams = {
				tName: inlineObj.tName, 
				pageType: Runner.pages.constants.PAGE_VIEW, 
				keys: row.keys,
				keyFields: row.keyFields,
				modal: true,
				baseParams: {
					parId: inlineObj.id,
					table: escape( inlineObj.tName )
				},
				inlineObjectParams: {
					getInlineObject: function() {
						return inlineObj;
					},
					rowId: row.id
				}
			};
			
			if ( inlineObj.dashGridBased && inlineObj.pageObj ) {
				pageParams.afterCreateHn = function() {
					inlineObj.pageObj.setSelected( row.id );
				};
				pageParams.baseParams.dashTName = inlineObj.pageObj.dashboard.tName;
			}
			
			Runner.pages.PageManager.openPage( pageParams );
			return false;
		});
	},
	
	/**
	 * @param {jQuery object} $link
	 * @param {object} row
	 * @return {jQuery object}
	 */	
	initEditLink: function( $link, row ) {
		if ( !Runner.pages.PageSettings.getTableData(this.tName, "showEditInPopup") || Runner.isMobile ) {
			return $link;
		}
		var inlineObj = this;
			
		return $link.bind("click", function(e) {
			var pageParams = {
				tName: inlineObj.tName,
				pageType: Runner.pages.constants.PAGE_EDIT, 
				keys: row.keys,
				keyFields: row.keyFields,
				modal: true,
				baseParams: {
					parId: inlineObj.id,
					rowId: row.id,
					table: escape( inlineObj.tName ),
					editType: Runner.pages.constants.EDIT_POPUP
				},
				afterSave: {
					fn: function( respObj, formObj, fieldControls, editPageObj ) {
						if ( respObj.success ) {
							this.afterSubmit(row, respObj, editPageObj);
							return;	
						} 
														
						if ( respObj.lockMessage ) {
							$('.' + this.classNameLocking).html( respObj.lockMessage ).show();
							return false;
						}
						
						if ( respObj.hideCaptcha ) {
							$('.captcha_block').remove();
						}
						//show invslid captcha message
						editPageObj.showCaptchaErrMessage( respObj.captcha );
						editPageObj.displayHalfPreparedMessage( respObj.message || "" );
						editPageObj.showBrick('message');
						
						editPageObj.adjustPopWindowHeightByContent();
						$( editPageObj.win.bodyNode.getDOMNode() ).animate( {scrollTop: 0} );
						return false;
					},
					scope: inlineObj
				},
				inlineObjectParams: {
					getInlineObject: function() {
						return inlineObj;
					},
					rowId: row.id
				}				
			};
			
			if ( inlineObj.dashGridBased && inlineObj.pageObj ) {
				pageParams.afterCreateHn = function() {
					inlineObj.pageObj.setSelected( row.id );
				};
				pageParams.baseParams.dashTName = inlineObj.pageObj.dashboard.tName;
			}			
			
			inlineObj.pageObj.hideBrick('message');				
			Runner.pages.PageManager.openPage( pageParams );
			return false;
		});
	},
	
	/**
	 * @param {jQuery object} $link
	 * @param {object} row
	 * @return {jQuery object}
	 */
	initInlineEditLink: function( $link, row ) {
		var newUrl = Runner.pages.getUrl(this.tName, Runner.pages.constants.PAGE_EDIT, row.keys, 'editid'),
			inlineObj = this;
		
		return $link.attr('href', newUrl)
			.bind("click", function(e) {		
				( inlineObj.inlineEditObj || inlineObj ).inlineEdit( row );
				return false;
			});
	},
	
	/**
	 * Toggle the 'Save all' and 'Cancel all' buttons
	 */
	toggleMassRecButt: function() {
		this.massRecButtEditMode = this.isRowsEditing();
		Runner.toggleButton( this.saveAllButt, this.massRecButtEditMode );
		Runner.toggleButton( this.cancelAllButt, this.massRecButtEditMode );
	},
	
	/**
	 * Check if thre are some unsubmitted rows
	 * @return {boolean}
	 */
	isRowsEditing: function() {
		for (var i = 0; i < this.rows.length; i++) {
			if ( this.rows[i].submitted !== undefined && !this.rows[i].submitted ) {
				return true;
			}
		}
		return false;
	},
	
	/** 
	 * Validate the rows controls
	 * Used for inline add/edit records on detail page
	 * @return {Boolean}
	 */
	validate: function() {
		var invalidControls = [];
		
		this.rowFocussed = false;
		
		for (var i = 0, l = this.rows.length; i < l; i++) {
			invalidControls = this.pageObj.getInvalidControls( Runner.controls.ControlManager.getAt( this.tName, this.rows[i].id ) );
			
			if ( invalidControls.length && (this.rows[i].isAdd || !this.rowFocussed) ) {				
				if ( this.pageObj.setFirstFocus(this.rows[i].id, invalidControls) ) {
					this.rowFocussed = true;
				}
			}
		}
		
		return !this.rowFocussed;
	},
	
	/**
	 * Add new row to grid
	 * Used after copy record
	 * @param {object} data 
	 * @param {object} extAddPageObj	A reference to an pop-up or dash add page (optional)
	 */
	addRowToGrid: function( data, extAddPageObj ) {
		var newAddRow = this.prepareRow( data.vals, true );
		this.getEditBlock( newAddRow );
		this.afterSubmit( newAddRow, data, extAddPageObj );
	},
	
	/**
	 * Initialize the row object
	 * @param {object} row
	 */
	initRow: function( row ) {
		row.submitted = true;
		row.revertted = false;
		row.data = {};
		row.saveLink = false;
		row.cancelLink = false;
		row.checkBox = this.initCheckBox( $('#check' + this.id + '_' + row.id) );
		row.copyLink = this.initCopyLink( $('#copyLink' + row.id), row );
		row.editLink = this.initEditLink( $('#editLink' + row.id), row );
		row.iEditLink = this.initInlineEditLink( $('#iEditLink' + row.id), row );
		row.viewLink = this.initViewLink( $('#viewLink' + row.id), row );
	},
	
	hideRowButtons: function( row ) {
		row.viewLink.hide();
		row.copyLink.hide();
		row.editLink.hide();
		row.iEditLink.hide();
		row.checkBox.hide();
	},
	
	showRowButtons: function( row ) {
		row.viewLink.show();
		row.copyLink.show();
		if (row.isEditable) {
			row.editLink.show();
			row.iEditLink.show();
		}
		row.checkBox.show();
		if (row.saveLink) {
			row.saveLink.hide();
		}
		if (row.cancelLink) {
			row.cancelLink.hide();
		}
	},
	
	/**
	 * Show or hide recordcontrols briks's buttons 
	 * basing on toggler value
	 * @param {boolean} toggler
	 */
	toggleRecordControlButtons: function( toggler ) {
		Runner.toggleButton( this.editAllButt, toggler );
		Runner.toggleButton( this.saveAllButt, toggler );
		Runner.toggleButton( this.cancelAllButt, toggler );
		Runner.toggleButton( $("a[id=print_selected" + this.id + "]"), toggler );
		Runner.toggleButton( $("a[id=export_selected" + this.id + "]"), toggler );
		Runner.toggleButton( $("a[id=delete_selected" + this.id + "]"), toggler );
		
		if ( this.pageObj.pageMode == Runner.pages.constants.LIST_DASHBOARD ) {
			toggler ? $('.rnr-b-recordcontrol', this.pageObj.pageCont).removeClass('rnr-hiddenbrick') : $('.rnr-b-recordcontrol', this.pageObj.pageCont).addClass('rnr-hiddenbrick');
		}
		else {
			this.pageObj.toggleBrick("recordcontrol", toggler);	
		}	
	},
	
	/**
	 * Clone the 'gridRowAdd' row and its separator and add them to
	 * the top of the grid element
	 * @param {object} vals
	 * @param {boolean} submitted
	 * @return {object}
	 */
	prepareRow: function( vals, submitted ) {
		var grid = this.pageObj.gridElem,
			$addRow = $(".gridRowAdd", grid).eq(0),
			$sepAddRow = $(".gridRowSepAdd", grid).eq(0),
			newRowId = Runner.genId(),
			pageId = this.id,
			newAddRow;
		
		if ( this.rows.length === 0 ) {
			// show the grid
			this.pageObj.showBrick("grid");	
			$("thead tr, tr.footer, tr." + this.classNameBottomRow, grid).removeClass( this.classNameHidden );

			this.toggleRecordControlButtons( true );
		}
		
		newAddRow = {
			row: $addRow.clone( true ),
			srow: false,
			id: newRowId,
			keys: [],
			keyFields: [],
			data: vals,
			isAdd: true,
			isEditable: true,
			contextRowId: newRowId
		};
		if ( $sepAddRow.length ) {
			newAddRow.srow = $sepAddRow.clone();
			newAddRow.srow.removeClass('gridRowSepAdd ' + this.classNameHidden);
		}
		
		this.rows.push( newAddRow );
		
		this.replaceElementsIdForAddedRow( newAddRow, pageId );
		
		newAddRow.row.removeClass('gridRowAdd ' + this.classNameHidden);
		$(".gridRowAdd", newAddRow.row).removeClass('gridRowAdd ' + this.classNameHidden);
		
		if ( this.listGridLayout === Runner.pages.constants.COLUMNS_LAYOUT ) {
			newAddRow.row.children("tr").attr("id", this.rowPref + newAddRow.id);
			newAddRow.row.children("tr.rnr-row").children("td").attr("data-record-id", newAddRow.id);
		} else if ( this.listGridLayout === Runner.pages.constants.VERTICAL_LAYOUT ||  newAddRow.row.hasClass( this.classNameRow ) ) {
			newAddRow.row.attr("id", this.rowPref + newAddRow.id);
			newAddRow.row.children("td").attr("data-record-id", newAddRow.id);	
		}	
		
		if ( newAddRow.srow ) {
			newAddRow.srow.insertAfter( $sepAddRow );
			newAddRow.row.insertAfter( $sepAddRow );
		} else {	
			if ( this.pageObj.addNewRecordsToBottom ) {
				newAddRow.row.appendTo( $addRow.parent() );
			} else {
				newAddRow.row.insertAfter( $addRow );
			}
		}
	
		// add extra properties to the newAddRow object such as 'checkBox', 'viewLink' and so on
		( this.inlineEditObj || this ).initRow( newAddRow );

		newAddRow.submitted = submitted;
		return newAddRow;
	},
	
	/**
	 * Replace the temp id values for some DOM elements within the added row
	 * @param {object} newAddRow
	 * @param {number} pageId
	 */
	replaceElementsIdForAddedRow: function( newAddRow, pageId ) {
		$("#editLink_add" + pageId, newAddRow.row).attr("id", "editLink" + newAddRow.id).hide();
		$("#copyLink_add" + pageId, newAddRow.row).attr("id", "copyLink" + newAddRow.id).hide();
		$("#check_add" + pageId, newAddRow.row).attr("id", "check" + pageId + "_" + newAddRow.id).hide();
		$("#viewLink_add" + pageId, newAddRow.row).attr("id", "viewLink" + newAddRow.id).hide();
		$("#inlineEdit_add" + pageId, newAddRow.row).attr("id", "iEditLink" + newAddRow.id).hide();
		
		$("[id$='_preview" + pageId + "']", newAddRow.row).hide().each( function() {
			var cntDet, cntDetId,
				reg = new RegExp( pageId + '$' );
			
			this.id = this.id.replace( reg, newAddRow.id );
			cntDet = $('span[id^=cntDet]', this);
			if ( cntDet.length ) {
				cntDet.attr('id', cntDet.attr('id') + newAddRow.id);
			}
		});
		
		$("[id^='master_'][id$='_add" + pageId + "']", newAddRow.row).hide().each( function() {
			var reg = new RegExp( 'add' + pageId + '$' );
			this.id = this.id.replace( reg, newAddRow.id );
		});
		
		$("[id^='add" + pageId + "_']", newAddRow.row).each( function() {
			var reg = new RegExp( '^add' + pageId );
			this.id = this.id.replace( reg, 'edit' + newAddRow.id ); 
		});
	},
	
	/**
	 * checkRowDetailKeys
	 * Check new and existent row masterKeys and update details count and popup links
	 * @param {object} changed row
	 * @param {object} new master keys
	 */
	checkRowMasterKeys: function( row, newMasterKeys ) {
		if ( !this.pageObj.dpObjs || !newMasterKeys || $.isEmptyObject( newMasterKeys ) ) {
			return;
		}
		
		$.each( this.pageObj.dpObjs, function( ind, obj ) {
			var isKeysChanged = false;
			
			if ( row.masterKeys == undefined ) {
				row.masterKeys = newMasterKeys;
				isKeysChanged = true;
			} else {
				$.each( newMasterKeys[ obj.tName ], function( kInd, kObj ) {
					if ( kObj != row.masterKeys[ obj.tName ][ kInd ] ) {
						isKeysChanged = true;
						return false;
					}
				});
			}
			
			if ( isKeysChanged ) {
				obj.updateChildRecNum( newMasterKeys[ obj.tName ], row.id );
				row.masterKeys[ obj.tName ] = newMasterKeys[ obj.tName ];
				obj.closeDetailsById( row.id );
			} else {
				obj.updateChildRecNum( row.masterKeys[ obj.tName ] );
			}
		});
	},
	
	/**
	 * A stub
	 * @param {object} row
	 * @param {object} ctrlJSON
	 */
	lockRow: function( row, ctrlsJSON ) {
	}	
});

/**
 * @class Runner.util.inlineEditing.InlineAdd
 */
Runner.util.inlineEditing.InlineAdd = Runner.extend( Runner.util.inlineEditing.InlineEditor, {	
	
	pageType: Runner.pages.constants.PAGE_ADD,

	/**
	 * It indicates if to show inline row without the Save button
	 */
	hideSaveButt: false,
	
	
	constructor: function( cfg ) {
		Runner.util.inlineEditing.InlineAdd.superclass.constructor.call( this, cfg );				
		this.addEvents("beforeSetVals", "beforeInlineAdd");
	},
	
	init: function() {
		Runner.util.inlineEditing.InlineAdd.superclass.init.call(this);
	},

	/**
	 * Get submit URL
	 * @return {string}
	 */
	getSubmitUrl: function() {
		return Runner.util.inlineEditing.InlineAdd.superclass.getSubmitUrl.call( this ) + "?submit=1&inline=1&";
	},	
	
	initButtons: function() {
		Runner.util.inlineEditing.InlineAdd.superclass.initButtons.call( this );	
		this.initAddButton();
	},
	
	/**
	 * Reinitialize the 'Save all', 'Cancel' buttons.
	 */
	reinitButtons: function() {
		Runner.util.inlineEditing.InlineAdd.superclass.initButtons.call( this );
	},	
	
	/**
	 * Initialize the 'Inline Add' button
	 */
	initAddButton: function() {
		var inlineAddObj = this;
		$("a[id=inlineAdd" + this.id + "]").bind("click", function(e) {
			inlineAddObj.inlineAdd( inlineAddObj.hideSaveButt );
			return false;
		});
	},	
	
	cancelButtonHn: function( row, isCancelAll ) {
		row.revokeCancel = false;
		
		if ( typeof row.onBeforeCancel != "undefined" ) {
			row.onBeforeCancel();
		}
		if ( row.revokeCancel ) {
			return false;
		}
		this.removeRowData(row);
		if ( !isCancelAll ) {
			this.fireEvent('recalcGridSize');
		}
		
		Runner.util.inlineEditing.InlineAdd.superclass.cancelButtonHn.call(this);
		
		if ( typeof row.onCancel != "undefined" ) {
			row.onCancel();
		}
			
		this.fireEvent('cancel', row, this.fNames);
		
		Runner.controls.ControlManager.unregister(this.tName, row.id);
		return true;
	},
	
	revertRow: function( row ) {
		Runner.util.inlineEditing.InlineAdd.superclass.revertRow.call(this, row);
		// clear row data from memory
		this.removeRowData(row);
	},
	
	/**
	 * Save all Inline Add grid's rows
	 *
	 * Go in reverse order because:
	 *		all added rows set in the end of array this.rows 
	 *		set focus to invalid control on last added row
	 */	
	saveAll: function() {
		if ( Runner.util.inlineEditing.InlineAdd.superclass.saveAll.call( this ) ) {
			return true;
		}
		
		for (var i = this.rows.length; i--; ) {			
			if ( this.rows[i] && !this.rows[i].submitted && this.rows[i].isAdd ) {
				this.rows[i].fileFieldsCount = 0;
				this.rows[i].upploadErrorHappened = 0;
				this.waitForFilesUpload( this.rows[i] );
			}
		}
		
		// to fire rowsEdited event for detail inline object in case only empty 'InlineAdd' rows were open
		Runner.util.inlineEditing.InlineAdd.superclass.saveAll.call( this );
	},
	
	fireUserEventAfterInline: function( row ) {
		if ( this.pageObj.isEventExist('afterInlineAdd') ) {
			Runner.util.inlineEditing.InlineEdit.superclass.fireUserEventAfterInline.call(this, row);
		}
	},
	
	/**
	 * Assign the row's basicForm property with the Runner BasicForm object reference
	 * or if it's alredy assigned update its properties
	 * @param {object} row
	 */		
	initForm: function( row ) {
		Runner.util.inlineEditing.InlineAdd.superclass.initForm.call( this, row );
		
		if ( this.pageObj.baseParams && this.pageObj.baseParams.mode == "lookup" ) {
			row.basicForm.baseParams["forLookup"] = true;
			row.basicForm.baseParams["pageType"] = this.pageObj.baseParams.pageType;
			row.basicForm.baseParams["table"] = this.pageObj.lookupCtrl.shortTableName;
			row.basicForm.baseParams["field"] = this.pageObj.lookupCtrl.fieldName;
		}		
	},
	
	/**
	 * A handler that is invoked after an inline add row is submitted
	 * ( on the row's form successSubmit event of add popup was saved)
	 * @param {objetc} row
	 * @param {newData} newData
	 * @param {newData} extAddPageObj 	A reference to a pop-up or dash add page (optional)
	 */	 
	afterSubmit: function( row, newData, extAddPageObj ) {
		Runner.util.inlineEditing.InlineAdd.superclass.afterSubmit.call(this, row, newData, extAddPageObj);
		
		if ( row.cancelLink ) {
			row.cancelLink.remove();
			row.cancelLink = null;
		}
		if ( row.saveLink ) {
			row.saveLink.remove();
			row.saveLink = null;
		}
		if ( this.isEditOwn ) {
			row.isAddOwnRow = true;
		}
		
		if ( this.pageObj.parId ) {
			Runner.pages.PageManager.getById( this.pageObj.parId ).setRecountFlagForPopup();
		}
		
		// fire rowsEdited event if all rows submited
		var allVals = [],
			allKeys = [],
			allRowIds = [];
		if ( typeof row.fromSaveBtn == "undefined" ) {
			for (var i = 0; i < this.rows.length; i++) {
				allVals.push(this.rows[i].data);
				allKeys.push(this.rows[i].keys);
				allRowIds.push(this.rows[i].id);
				if (this.rows[i].submitted === false) {
					this.pageObj.isDetailsRecountNeeded = true;
					return;
				}
			}
		}
		if ( this.rows.length === 1 ) {
			$("#select_all" + this.id).show();
		}
		
		this.fireEvent('rowsEdited', allVals, newData.fields, allKeys, allRowIds, false, row.fromSaveBtn);
		row.fromSaveBtn = undefined;
	},
	
	/**
	 * Toggle the 'Save all', 'Cancel all', 'Edit all' buttons
	 */
	toggleMassRecButt: function() {
		Runner.util.inlineEditing.InlineAdd.superclass.toggleMassRecButt.call( this );
		
		if ( !this.isRowsEditing() && this.rows.length ) {
			Runner.toggleButton( this.editAllButt, !this.massRecButtEditMode );
		}
	},
	
	/**
	 * Create a new 'Inline Add' row and add it to the page's grid element
	 * @param {Boolean} hideSaveButt
	 * @param {Boolean} hideRevertButt
	 */	 
	inlineAdd: function( hideSaveButt, hideRevertButt ) {
		var newAddRow;
		
		this.fireEvent("beforeInlineAdd");
		this.pageObj.hideBrick('message');
		
		hideRevertButt = hideRevertButt === undefined ? false : hideRevertButt;
		hideSaveButt = hideSaveButt === undefined ? false : hideSaveButt;		
		newAddRow = this.prepareRow( {}, false );
		
		this.toggleMassRecButt();
		this.hideRowButtons( newAddRow );
		this.getControls( this.pageObj, newAddRow, hideRevertButt, hideSaveButt );	
	},
	
	/**
	 * Show the cancel button for the Inline Add row
	 * @param {object} row
	 */
	showCancelButton: function( row ) {
		this.inlineAddChangeContent = true;
		this.getEditBlock( row, false, true );
	}
});

/**
 * @class Runner.util.inlineEditing.InlineEdit
 */
Runner.util.inlineEditing.InlineEdit = Runner.extend( Runner.util.inlineEditing.InlineEditor, {	
	
	pageType: Runner.pages.constants.PAGE_EDIT,
	
	/**
	 * @type {boolean}
	 */
	isUseLocking: false,
	
	
	constructor: function( cfg ) {
		Runner.util.inlineEditing.InlineEdit.superclass.constructor.call(this, cfg);	
		
		this.isUseLocking = Runner.pages.PageSettings.getTableData(this.tName, "locking");
		this.initLocking();
		
		this.addEvents("beforeEditRow");
	},
	
	init: function() {
		Runner.util.inlineEditing.InlineEdit.superclass.init.call(this);
		this.initRows();
	},

	/**
	 * Get submit URL
	 * @return {string}
	 */
	getSubmitUrl: function() {
		return Runner.util.inlineEditing.InlineEdit.superclass.getSubmitUrl.call( this ) + "?submit=1";
	},	
	
	/**
	 * Initialize a locking object
	 */
	initLocking: function() {
		if ( !this.isUseLocking ) {
			return;
		}
		
		this.locking = new Runner.Locking({
			tName: this.tName,
			pageId: this.id
		});	
	},

	/**
	 * Lock the row's record
	 * @param {object} row
	 * @param {object} ctrlJSON
	 */
	lockRow: function( row, ctrlsJSON ) {	
		if ( !this.isUseLocking ) {
			return;
		}
		
		var enableCtrls = ctrlsJSON.enableCtrls,
			confirmTime = ctrlsJSON.confirmTime;
		
		if ( enableCtrls === undefined ) {
			enableCtrls = ctrlsJSON.settings['tableSettings'][ this.tName ]['enableCtrls'];
		}
		
		if ( confirmTime === undefined ) {
			confirmTime = ctrlsJSON.settings['tableSettings'][ this.tName ]['confirmTime'];
		}
		
		if ( enableCtrls ) {			
			this.locking.StartLocking( this, row.id, this.getKeysForLocking( row ), confirmTime );
		}
	},
	
	/**
	 * Get the locking keys string for the row object
	 * @param {object} row
	 * @return {string}
	 */
	getKeysForLocking: function( row ) {
		return this.getLockingKeysString( row.keys );
	},
	
	/**
	 * Get the keys string for the 'locking' operations
	 * @param {array} keys
	 * @return {string}
	 */
	getLockingKeysString: function( keys ) {
		if ( !this.isUseLocking ) {
			return "";
		}
		
		var sKeys = [], i;

		keys = keys || [];
		
		for (i = 0; i < keys.length; i++) {
			sKeys.push( keys[i] ) ;
		}
		return sKeys.join("&");		
	},
	
	/**
	 * Show error massage for locked deleted records
	 */
	showErrorForLockingRecords: function() {
		var lockingRecords = Runner.pages.PageSettings.getTableData(this.tName, 'lockRecIds');
		if ( !lockingRecords.length ) {
			return;
		}
		for (var i = 0, l = lockingRecords.length; i < l; i++) {
			this.makeError( "Record is being edited by another user", this.getRowById( lockingRecords[i] ) );
			$('input[id=check' + this.id + '_' + lockingRecords[i] + ']', this.pageObj.gridElem).prop('checked', true);
		}
	},
	
	/**
	 * Initialize the row object
	 * @param {object} row
	 */
	initRow: function( row ) {
		Runner.util.inlineEditing.InlineEdit.superclass.initRow.call( this, row );
		row.isEditable = true;
	},
	
	initRows: function() {
		for (var i = 0; i < this.rows.length; i++) {
			this.initRow( this.rows[i] );
		}
		if ( this.isUseLocking ) {
			this.showErrorForLockingRecords();
		}
	},
	
	initInlineRowEditors: function() {
		for (var i = 0; i < this.rows.length; i++) {
			this.getInlineButtBlock( this.rows[i] );
		}
	},
	
	initButtons: function() {
		Runner.util.inlineEditing.InlineEdit.superclass.initButtons.call(this);
		this.initEditAll();
	},
	
	/**
	 * Initialize the 'Edit selected' button
	 */
	initEditAll: function() {
		var inlineObj = this;
		
		this.editAllButt.unbind("click").bind("click", function(e) {			
			var i, j, row, checkBox, 
				selBoxesArr = [],
				isEdit = false;
				
			$('input[type=checkbox][id^=check' + inlineObj.id + '_]:checked').each( function() {
				var $box = $(this),
					recordId = $box.attr('id').substr( $box.attr('id').lastIndexOf('_') + 1 );
				
				if ( inlineObj.isEditOwn && !$('#iEditLink' + recordId).length ) {
					$box.prop("checked", false);
					return;
				}
				selBoxesArr.push( $box );
			});
				
			for (i = 0; i < selBoxesArr.length; i++) {
				for (j = 0; j < inlineObj.rows.length; j++) {
					row = inlineObj.rows[j];
					checkBox = row.checkBox;
					
					if ($(checkBox[0]).attr('id') !== $(selBoxesArr[i]).attr('id')) {
						continue;
					}
					
					if ( row.keys && row.keys.length > 0 ) {
						inlineObj.inlineEdit( row );
						if ( !inlineObj.rows[i].submitted && !inlineObj.rows[i].isAdd ) {
							isEdit = true;
						}
					}
				}
			}
			if ( isEdit ) {
				inlineObj.toggleMassRecButt();
			}
			return false;	
		});
	},
	
	/**
	 * Reinitialize the InlineEdit functionality
	 */
	reInit: function( gridRows ) {
		Runner.util.inlineEditing.InlineEdit.superclass.reInit.call(this, gridRows);
		this.initRows();
	},
	
	/**
	 *
	 * @param {Object} row
	 * @param {Boolean} hideRevertButt
	 * @param {Boolean} hideSaveButt
	 */
	inlineEdit: function( row, hideRevertButt, hideSaveButt ) {
		hideRevertButt = hideRevertButt === undefined ? false : hideRevertButt;
		hideSaveButt = hideSaveButt === undefined ? false : hideSaveButt;

		this.pageObj.hideBrick('message');
		
		this.fireEvent("beforeEditRow", row);
		row.submitted = false;
		this.clearError( row );
		this.toggleMassRecButt();
		this.getValuesFromSpan( row );
		this.hideRowButtons( row );	
		this.getControls( this.pageObj, row, hideRevertButt, hideSaveButt );
		
		var inlineObj = this;
		setTimeout( function() {
			$("#" + inlineObj.rowPref + row.id).removeClass('hovered');
		});
	},
	
	editRecById: function( rowId ) {
		var row = this.getRowById(rowId);
		if (row) {
			this.inlineEdit(row);
			return true;
		}
		return false;
	},
	
	editAllRecs: function() {
		for (var i = 0; i < this.rows.length; i++) {
			this.inlineEdit( this.rows[i] );
		}
	},
	
	getRecsId: function() {
		var recsId = {};
		for (var i = 0; i < this.rows.length; i++) {
			recsId[i + 1] = this.rows[i].id;
		}
		return recsId;
	},
	
	/**
	 * Revert the edit record
	 * @param {object} row
	 */
	revertRow: function( row ) {
		row.submitted = true;
		row.revertted = true;
		row.errorDiv = false;
		
		if ( row.checkBox.length ) {
			row.checkBox.prop("checked", false);
		}
		// clear controls
		Runner.util.inlineEditing.InlineEdit.superclass.revertRow.call(this, row);
		// change row buttons
		this.showRowButtons( row );
		// set row data into spans
		this.setValuesIntoSpans( row );
		if ( this.isUseLocking ) {
			this.locking.UnlockRecordInline( this.getKeysForLocking( row ) );
		}
		row.checkBox.show();
	},
	
	/**
	 * Assign the row's basicForm property with the Runner BasicForm object reference
	 * or if it's alredy assigned update its properties
	 * @param {object} row
	 */		
	initForm: function( row ) {
		Runner.util.inlineEditing.InlineEdit.superclass.initForm.call( this, row );

		for (var i = 0; i < row.keys.length; i++) {
			row.basicForm.baseParams[ "editid" + (i + 1) ] = row.keys[i];
		}
	},
	
	/**
	 * The Cancel button's handler
	 * @param {object} row 
	 * @param {boolean} isCancelAll 
	 */
	cancelButtonHn: function( row, isCancelAll ) {
		row.revokeCancel = false;
		if ( typeof row.onBeforeCancel != "undefined" ) {
			row.onBeforeCancel();
		}
		if ( row.revokeCancel ) {
			return false;
		}
		
		this.revertRow( row );

		if ( typeof row.onCancel != "undefined") {
			row.onCancel();
		}
			
		this.fireEvent('cancel', row, this.fNames);	
		
		Runner.util.inlineEditing.InlineEdit.superclass.cancelButtonHn.call(this);

		if ( !isCancelAll ) {
			this.fireEvent('recalcGridSize');
		}
		return true;
	},
	
	/**
	 * Toggle the 'Save all', 'Cancel all', 'Edit all' buttons
	 */
	toggleMassRecButt: function() {
		Runner.util.inlineEditing.InlineEdit.superclass.toggleMassRecButt.call( this );
		if ( this.rows.length ) {
			Runner.toggleButton( this.editAllButt, !this.massRecButtEditMode )
		}
	},
	
	fireUserEventAfterInline: function( row ) {
		if ( this.pageObj.isEventExist('afterInlineEdit') ) {
			Runner.util.inlineEditing.InlineEdit.superclass.fireUserEventAfterInline.call(this, row);
		}	
	},
	
	/**
	 * A handler that is invoked after an Inline Edit row is submitted
	 * ( on the row's form successSubmit event or when the edit popup is saved )
	 * @param {object} row
	 * @param {object} newData
	 * @param {object} editPageObj		A reference to a pop-up or dash edit page (optional)
	 */
	afterSubmit: function( row, newData, editPageObj ) {
		var oldKeysForLocking = this.getKeysForLocking( row ), 
			isEdit;
		
		Runner.util.inlineEditing.InlineEdit.superclass.afterSubmit.call( this, row, newData, editPageObj );

		if ( this.isUseLocking ) {
			// reset confirming for the record with the old keys
			this.locking.ResetSetInterval( oldKeysForLocking ); 
			
			if ( editPageObj && !editPageObj.moveNext ) {
				// start confirming with new keys for the popup edit page without prev/next buttons
				editPageObj.sKeys = this.getLockingKeysString( newData.keys );
				this.locking.StartLocking( this, row.id, editPageObj.sKeys, Runner.pages.PageSettings.getTableData(this.tName, "confirmTime") );
			}
		}
		
		// fire the 'rowsEdited' event if all rows were submited
		var allVals = [],
			allKeys = [],
			allRowIds = [];
			
		for (var i = 0; i < this.rows.length; i++) {
			if (this.rows[i].submitted === false) {
				return;
			}
			allVals.push( this.rows[i].data );
			allKeys.push( this.rows[i].keys );
			allRowIds.push( this.rows[i].id );
		}
		
		//the following function code is invoked after the all edited row are submitted only	
		isEdit = !this.pageObj.isDetailsRecountNeeded;
		delete this.pageObj.isDetailsRecountNeeded;
		
		this.fireEvent('rowsEdited', allVals, newData.fields, allKeys, allRowIds, isEdit);
	},
	
	/**
	 * Save all Inline Edit grid's rows
	 */
	saveAll: function() {
		if ( Runner.util.inlineEditing.InlineEdit.superclass.saveAll.call( this ) ) {
			return true;
		}
		for (var i = 0; i < this.rows.length; i++) {
			if ( !this.rows[i].submitted && !this.rows[i].isAdd ) {
				this.rows[i].fileFieldsCount = 0;
				this.waitForFilesUpload( this.rows[i] );
			}
		}
	}
});


/**
 * The method creating a Filter control basing on its format and other params
 *
 * @param {object} baseCfg
 * @param {object} searchController		The searchController obejct reference
 */
Runner.controls.FilterControlFabric = function( baseCfg, searchController ) {
	//add to the filter Control's config the link to the Search Controller object
	var cfg = {
		searchController: searchController
	};
	cfg = Runner.apply( cfg, baseCfg );
	
	switch ( cfg.filterFormat ) {
		case Runner.controls.constants.FILTER_FORMAT_VALUES_LIST:
		case Runner.controls.constants.FILTER_FORMAT_INTERVAL_LIST:
			switch ( cfg.multiSelect ) {
				case Runner.controls.constants.FILTER_MULTISELECT_NONE:
				return new Runner.controls.SimpleFilterControl( cfg ); 	

				case Runner.controls.constants.FILTER_MULTISELECT_ON_DEMAND:
				return new Runner.controls.OnDemandFilterControl( cfg ); 			

				case Runner.controls.constants.FILTER_MULTISELECT_ALWAYS:
				return new Runner.controls.MultiSelectFilterControl( cfg );
				
				default:
					throw( "Invalid multiselect param(" + cfg.multiSelect + ") for the " + cfg.filterFormat + " format. Cannot create control!" );
				return;	
			}
		
		case Runner.controls.constants.FILTER_FORMAT_BOOLEAN:
		return new Runner.controls.SimpleFilterControl( cfg ); 
		
		case Runner.controls.constants.FILTER_FORMAT_INTERVAL_SLIDER:
			if ( cfg.isFieldDateType ) {
				return new Runner.controls.DateSliderFilterControl( cfg );
			}
			if ( cfg.isFieldTimeType ) {
				return new Runner.controls.TimeSliderFilterControl( cfg );
			}			
		return new Runner.controls.SliderFilterControl( cfg ); 
		
		default:
			throw( "Invalid filter control's format = " + cfg.filterFormat + ". Cannot create control!" );
	}
}


/**
 * The base abstract class for filter controls
 */
Runner.controls.FilterControl = Runner.extend( Runner.emptyFn, {
	/**
	 * It Stores the contol's value for non-multiselect filter contorls 
	 * @type {String | Number}
	 */
	ctrlValue: '',
	
	/**
	 * Filter control field's name	 
	 * @type {String}
 	 */
	fieldName: '',
	
	/**
	 * Filter contorl "good" field's name
	 * @type {String}
	 */
	gfieldName: '',
	
	/**
	 * Filter contorl's format
	 * @type {String}
	 */	
	filterFormat: '',
	
	/**
	 * The number indicating if a contol allows
	 * multiselection always, "on demand" or never
	 * @type {number}
	 */
	multiSelect: 0,
	
	/**
	 * The indicator if the control's field is filtered
	 * @type {Boolean}
	 */
	filtered: false,
	
	/**
	 * If the control is filters it stores values 
	 * used for the contol field's filtration
	 * @type {Array}
	 */
	defaultValuesArray: [],
	
	/**
	 * The name of the Filter panel container's class
	 * @type {String}
	 */
	filterPanelContainerClass: "filterPanelContainer",
	
	/**
	 * The jQuery object representing the Filter panel's div container
	 * @type {object}
	 */
	filterPanelContainer: {},

	/**
	 * The jQuery object representing the filter control's container
	 * @type {object}
	 */
	filterContainer: {},
	
	/**
	 * The the link to the search Controller intance 
	 * (that is the same for all filter controls)
	 * @type {Object} 
	 */
	searchController: {},

	/**
	 * The name of the Filter "Apply" button's class
	 * @type {String}
	 */
	btnApplyClass: "filter-btn-apply",

	/**
	 * The class of the element toggling control visibility
	 * @type {String}
	 */
	btnExpanderClass: "filter-expander",

	/**
	 * The class of the element showing whether filter is hidden or displayed
	 * @type {String}
	 */
	btnExpanderIndicatorClass: "filter-indicator",

	/**
	 * The jQuery object representing the filter control's expander element
	 * @type {object}
	 */
	expanderElem: {},
	
	/**
	 * The name of the filter's hidden values class
	 * @type {String}
	 */	
	hiddenValuesClass: "filter-hidden",

	/**
	 * The name of the filter's collapsed values class
	 * @type {String}
	 */	
	collapsedValuesClass: "filter-collapsed",

	/**
	 * The name of the filter value block container's class
	 * @type {String}
	 */
	filterValueBlockContainerClass: "filter-values",
	
	/**
	 * The filter's URL params separator
	 * @type {String}
	 */
	separator: "",
	
	/**
	 * The flag indicating if the filter control is dependent
	 * @type {Boolean}
	 */
	dependent: false,
	
	/**
	 * The flag indicating if the filter control has any dependent filters	
	 * @type {Boolean}
	 */	
	hasDependent: false,
	
	/**
	 * The name of the outermost parent filter
	 * It's not equal to an empty string for dependent filters only
	 * @type {String}
	 */
	goodOutermostParentName: "",

	/**
	 * The name of the immediate parent filter
	 * It's not equal to an empty string for dependent filters only
	 * @type {String}
	 */	
	goodParentName: "",
	
	/**
	 * An array storing the parent filters names 
	 * for a dependent filter control
	 * @param {Array}
	 */
	parentFilterNames: null,	
	
	/**
	 * @type {string}
	 */
	hiddenFilterItemClass: "filter-item-hidden",
	
	
	constructor: function( cfg ) {
		this.defaultValuesArray = [];
		
		Runner.apply( this, cfg );
		
		this.filterPanelContainer = $("." + this.filterPanelContainerClass);
		this.filterContainer = $(".filter-" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) + "-container");
		this.expanderElem = $("." + this.btnExpanderClass, this.filterContainer);
		
		this.init();
	},

	/**
	 * The stub preventing children objects that don't have 
	 * any 'init' method from undefined method invocations
	 */
	init: Runner.emptyFn,
	
	/**
	 * Add the Apply, 'Clear' and Expander buttons' click event handlers
	 * to the Filter panel's container.
	 */
	initButtons: function() {
		this.initBasicButtons();
		this.initClearButtons();
		this.initShowMoreButton();	
	},

	/**
	 * Initialize the basic filter buttons
	 * A dependatn control doesn't have its own expander and apply button
	 */
	initBasicButtons: function() {	
		if ( this.dependent ) {
			return;
		}
		
		var ctrl = this,
			hiddenValuesClass = this.hiddenValuesClass,
			collapsedValuesClass = this.collapsedValuesClass,
			btnExpanderIndicatorClass = this.btnExpanderIndicatorClass;	

		// delegate clicks on a particular filter contriner	
		this.filterContainer
			.on('click', '.' + this.btnApplyClass, function(e) {
				$( this ).data( 'activated', true ); 
				ctrl.searchController.submitSearch();
				
				return false;
			})
			.on('click', '.' + this.btnExpanderClass, function(e) {
				var expander = $( this ),
					siblings = expander.siblings(':not(.' + hiddenValuesClass + ')'),
					goingToHide = siblings.not('.' + collapsedValuesClass).length !== 0,
					expanderIndicator = expander.children('.' + btnExpanderIndicatorClass);
				
				//set the right 'expand/collapse' sign for the filer
				expanderIndicator.html( goingToHide ? '&#x25BC;' : '&#x25B2;' );	
				
				//show/hide the filter's content. The last collapsed sibling is actually visible 1px height element due to collapsedValuesClasss styles	
				siblings.slideToggle( 100 ).promise().done( function() {
					siblings
						.css('display', '')
						.toggleClass( collapsedValuesClass, goingToHide );
				});
				
				return false;
			});	
	},
	
	/**
	 * Init the 'Clear' buttons
	 */
	initClearButtons: function() {
		if ( !this.filtered ) {
			return;
		}
			
		var ctrl = this,
			clearBtnClass = 'filter-clear-' + ( this.dependent ? this.goodOutermostParentName : this.gfieldName );			
			
		$('.' + clearBtnClass).on('click', function(e) {
			ctrl.clearControl();
			ctrl.clearDependentFilters();		
			
			ctrl.searchController.submitSearch();
			return false;
		});
	},
	
	/**
	 * Initialize the 'Show N more' button's functionality
	 */
	initShowMoreButton: function() {
		var ctrl = this;
		
		$(".filterShowMore_" + this.gfieldName).on("click", function(e) {
			var $showMoreElement = $(this).parent();
	
			$showMoreElement.siblings("." + ctrl.hiddenFilterItemClass)
				.removeClass( ctrl.collapsedValuesClass )
				.removeClass( ctrl.hiddenFilterItemClass );
				
			$showMoreElement.hide();
			return false;
		});		
	},
	
	/**
	 * Clear dependent filters
	 * @param {Boolean} notMultiSelected
	 */
	clearDependentFilters: function( notMultiSelected ) {
		if ( !this.hasDependent ) {
			return;
		}
		this.searchController.clearDependentFilters( this.dependentFilterNames, notMultiSelected );
	},
	
	/**
	 * Set the control's value
	 * @param {String | Number} value
	 */
	setValue: function( value ) {
		this.ctrlValue = value;
	},
	
	/**
	 * Get the control's value
	 * @return {String}
	 */	
	getValue: function() {
		return this.ctrlValue;
	},
	
	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * @param {String | Number} value
	 * @param {Boolean} encoded
	 */ 
	getPreparedValue: function( value, encoded ) {
		if ( encoded && typeof value === "string" ) {
			return this.searchController.searchEscape( value );
		}
		return value;
	},
	
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the encoded param is defined and equal to true 
	 * It returns the encoded value
	 * @param {Boolean} encoded
	 * @return {String}
	 */
	getFilterValue: function( encoded ) {
		var value;
		
		if ( this.ctrlValue === '' ) {
			return '';
		}
		
		value = this.getPreparedValue( this.ctrlValue, encoded );
		return '(' + this.searchController.searchEscape( this.fieldName ) + this.separator + value + ')';
	},

	/**
	 * Get filter's encoded value ready to use in the field's filtration
	 * @return {String}
	 */
	getFilterValueEncoded: function() {
		return this.getFilterValue( true ); 	
	},
	
	/**
	 * Check if the filter control is visible	
	 * @return {Boolean}
	 */	
	isVisible: function() {
		return this.filterContainer.is(":visible");
	},
	
	/**
	 * Check if the filter control is collapsed or not	
	 * @return {Boolean}
	 */
	isCollapsed: function() {
		return this.expanderElem.siblings().not(".filter-collapsed").length === 0;
	},
	
	/**
	 * Adjust the flter's expander sign basing on the its state (expanded/collapsed).
	 * @pamam {Boolean} collapsed	
	 * @return {Boolean}
	 */
	adjustExpander: function( collapsed ) {
		var sign = collapsed ? "&#x25BC;" : "&#x25B2;";
		$("." + this.btnExpanderIndicatorClass, this.expanderElem).html( sign );
	},
	
	/**
	 * Clear the filter control's value
	 * the 'Clear' buttons 'click' handler
	 */
	clearControl: function() {
		this.setValue('');
	},

	/**
	 * Set a single value to the filter control
	 * @param {Mixed}
	 */
	updateValue: function( value ) {
		this.setValue( value );	
	},
	
	/**
	 * Check if the filter control is dependent
	 * @return {Boolean}
	 */
	isDependent: function() {
		return this.dependent;
	},
	
	/**
	 * Check if the filter control is multiselected
	 * @return {Boolean}
	 */
	isMultiSelected: function() {
		return false;
	}
});


Runner.controls.SimpleFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * The link to the Runner.controls.OnDemandFilterControl's base class
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	superclass: {},
		
	/**
	 * The filter values links class name
	 * @type {String}
	 */		
	valueLinkClass: "",
	

	constructor: function( cfg ) {
		Runner.controls.SimpleFilterControl.superclass.constructor.call( this, cfg );	
	},
	
	/**
	 * Set the control's default value and init contol's buttons and links
	 */
	init: function() {	
		this.superclass = Runner.controls.SimpleFilterControl.superclass ;
		this.valueLinkClass = this.gfieldName + "-filter-value";
		
		this.setValue( this.defaultValuesArray.join(', ') );
		this.initButtons();
	},
	
	/**
	 * Init the control's buttons and links
	 */
	initButtons: function() {
		var ctrl = this,
			delBtnClass = "delFilterCtrlButt_" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) + "_" + this.searchController.id;
				
		this.filterPanelContainer
			.on("click", "." + delBtnClass, function(e) {
				var $delButton = $(this);
					valueToDelete = $(this).data('delete').toString(); 
				
				ctrl.clearFilterValue( valueToDelete, $delButton.parent(".filter-values") );
				ctrl.searchController.submitSearch();
				return false;	
			})
			.on("click", "." + this.valueLinkClass, function(e) {		
				var $valueLink = $(this);
				
				ctrl.ctrlValue = $valueLink.data("filtervalue");
				
				ctrl.updateParentFilters( $valueLink.data("parentFiltersValues") );
				ctrl.clearDependentFilters();							
				ctrl.searchController.submitSearch();
				
				return false;
			});
				
		//call the base class method
		this.superclass.initButtons.call( this );	
	},
	
	/**
	 * Update parent filters' values
	 * @param {Object} parentFiltersValuesData
	 */
	updateParentFilters: function( parentFiltersValuesData ) {
		if ( !this.dependent ) {
			return;
		}
		this.searchController.updateParentFilters( parentFiltersValuesData );
	},

	/**
	 * Delete a particular value from the filter's submit-values
	 * @param {String} valueToDelete
	 * @param {jQuery object} $container
	 */
	clearFilterValue: function( valueToDelete, $container ) {
		this.setValue('');
	}
}); 


Runner.controls.MultiSelectFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * It stores the array of the filter checkboxes' jQuery objects
	 * @type {Array}
	 */
	checkboxes: [],
	
	/**
	 * The name of the filter checkboxes' class
	 * @type {String}
	 */
	checkboxClass: '',
	
	/**
	 * The link to the Runner.controls.OnDemandFilterControl's base class
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	superclass: {},
	
	/**
	 * The common multiselect checkbox class name
	 * @type {String}	
	 */
	commonCheckboxClass: "multifilter-checkbox",
	
	/**
	 * The parent filter checkbox class name
	 * @param {String}
	 */
	parentCheckboxClass: "",
	
	
	constructor: function( cfg ) {
		this.checkboxes = [];
		
		Runner.controls.MultiSelectFilterControl.superclass.constructor.call( this, cfg );
	},
	
	/**
	 * Init the checkboxes array with the array of the filter checkboxes' jQuery objects.
	 * Set the control's default value and init contol's buttons and links. 
	 */
	init: function() {
		this.superclass = Runner.controls.MultiSelectFilterControl.superclass;

		this.applyButton = $( ".filter-apply-" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName) ); 
		
		this.checkboxClass = "filter_" + this.gfieldName + "_" + this.searchController.id;
		this.checkboxes = $("." + this.checkboxClass);	
		this.selectAllCheckbox = $( ".filter-selectAll-" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) );
		this.parentCheckboxClass = this.dependent ? "filter_" + this.goodParentName + "_" + this.searchController.id : "";
				
		this.adjustSelectAllCheckbox();
		
		if ( this.filtered && !this.dependent ) {
			this.setValue( this.defaultValuesArray );
		}
		
		this.initButtons();
	},
		
	/**
	 * Adjust the flter's 'Select/Deselect All' checkbox basing on the filter's checkboxes state.
	 */	
	adjustSelectAllCheckbox: function() {
		var currentState = this.selectAllCheckbox.is(":checked"),
			allChecked = this.checkboxes.length === this.checkboxes.filter(":checked").length
		
		this.selectAllCheckbox.prop("checked", currentState && allChecked);
	},	
		
	/**
	 * Init the control's buttons
	 */	
	initButtons: function() {
		var ctrl = this;
				
		this.selectAllCheckbox
			.on("click", function(e) {
				e.stopPropagation();
			})
			.on("change", function(e) {
				ctrl.checkboxes.prop("checked", this.checked);
				ctrl.clearDependentFilters( true );
				return false;
			});
		
		this.checkboxes
			.on("click", function(e) {
				ctrl.adjustSelectAllCheckbox();
				ctrl.adjustDependentFilters( this );
				ctrl.adjustInvisibleCheckboxes( this );	
			})
			.on("change", function(e) {
				ctrl.adjustParentFilterCheckbox( this );
			});
			
		//call the base class method
		this.superclass.initButtons.call( this );	
	},
	
	/**
	 * Clear check boxes for multiselect dependent controls
	 * and clear values for not multiselected ones
	 * @param {DOM element} checkbox
	 */	
	adjustDependentFilters: function( checkbox ) {
		this.clearDependentFilters( true );
		this.adjustDependentFilterCheckboxes( checkbox );		
	},
	
	/**
	 * Update dependent filters checkboxes of the corresponding value blocks
	 * basing on the main filter's current checkbox state
	 * The method depends on the Filter panel value blocks markup
	 * @param {DOM element} checkbox
	 */
	adjustDependentFilterCheckboxes: function( checkbox ) {
		if ( !this.hasDependent ) {
			return;
		}
		
		var $checkbox = $( checkbox ),
			$filterValueBlock = $checkbox.parent( '.' + this.filterValueBlockContainerClass );
		
		$('.' + this.commonCheckboxClass, $filterValueBlock).prop('checked', $checkbox.is(':checked'));
	},
	
	/**
	 * Update the corresoinding parent filter's checkbox state
	 * basing on the value blocks's checkboxes state	
	 * The method depends on the Filter panel value blocks markup	 
	 * @param {DOM element} checkbox
	 */
	adjustParentFilterCheckbox: function( checkbox ) {
		if ( !this.dependent ) {
			return;
		}
		
		var $checkbox = $( checkbox ),
			$parentFilterValueBlock = $checkbox.parents( '.' + this.filterValueBlockContainerClass ).eq(1),
			checked = $checkbox.is(':checked') || $('.' + this.checkboxClass + ':checked', $parentFilterValueBlock).length > 0;

		
		$parentFilterValueBlock.find( '.' + this.parentCheckboxClass ).prop('checked', checked)
			.trigger('change');
	},	
	
	/**
	 * Update the corresponding checkboxes from invisible parent filters value blocks
	 * @param {DOM element} checkbox
	 */
	adjustInvisibleCheckboxes: function( checkbox ) {
		if ( !this.dependent ) {
			return
		}
		
		var $checkbox = $( checkbox ),
			checkboxValue = $checkbox.val(),
			parentValues = $checkbox.data('parentFiltersValues'),
			$similarHiddenBoxes = this.checkboxes.not(':visible').filter( function() {
				var $box = $(this),
					hiddenParentValues, pName;
					
				if ( $box.val() !== checkboxValue ) {
					return false;
				}				
				
				hiddenParentValues = $box.data('parentFiltersValues');
					
				for ( pName in hiddenParentValues ) {
					if ( hiddenParentValues[ pName ] !== parentValues[ pName ] ) {
						return false;
					}
				}
				
				return true; 
			});
			
		$similarHiddenBoxes.prop('checked', $checkbox.is(':checked'))
			.trigger('change');	
	},
	
	/**
	 * Checked the filter's checkboxes having the values contained in the array param
	 * @param {Array} arr
	 */
	setValue: function( arr ) {
		this.checkboxes.each( function(index, domCheckbox) {
			var checkbox = $( domCheckbox ),
				pos = $.inArray( checkbox.val(), arr );
			
			if ( pos !== -1 ) {
				checkbox.prop('checked', true);
				arr.splice(pos, 1); 
			} 
		});
		
	},
	
	/**
	 * Get the contorl's value as an array.
	 * The returned array contains all the cehcked control's cehckboxes' values 
	 * and some default values that are not represented among the contol's checkboxes
	 * (to the "filter" operation reversible)
	 *
	 * @return {Array} 
	 */
	getValue: function() {
		var arr = [], i,
			ctrl = this,
			$checked = $('.' + this.checkboxClass + ':checked'),
			onDemand = this instanceof Runner.controls.OnDemandFilterControl;
		
		if ( this.dependent ) {
			$checked = $checked.filter(':visible');
		}
		
		if ( this.filtered || this.applyButton.data('activated') || $checked.length !== this.checkboxes.length ) {	
			$checked.each( function( index, domCheckbox ) {		
				var $box = $( domCheckbox ),
					values = [ $box.val().replace('|', '\\|') ],
					parentFiltersValueData, i; 
				
				if ( ctrl.dependent ) {
					parentFiltersValueData = $box.data('parentFiltersValues');	
					
					for (i = 0; i < ctrl.parentFilterNames.length; i++) {
						values.push( parentFiltersValueData[ ctrl.parentFilterNames[i] ].toString().replace('|', '\\|') );
					}
				}
				
				arr.push( values.join('|') );				
			});			
		}
		
		return arr;
	},
	
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the encoded param is defined and equal to true 
	 * It returns the encoded value
	 * @param {Boolean} encoded
	 *
	 * @return {String}
	 */
	getFilterValue: function( encoded ) {
		var arr = this.getValue(),
			result = ''; 
		
		for (i = 0; i < arr.length; i++) {
			this.ctrlValue = this.getPreparedValue( arr[i], encoded );
						//call the base class method	
			result += this.superclass.getFilterValue.call( this, encoded );
		}
		
		return result;
	},
	
	/**
	 * Clear the filter control's value
	 */
	clearControl: function() {			
		this.checkboxes.prop('checked', false);
		this.selectAllCheckbox.prop('checked', false);		
	},
	
	/**
	 * Set a single value to the filter control
	 * @param {Mixed}
	 */
	updateValue: function( value ) {
		this.checkboxes.prop('checked', false);
		this.setValue( [value] );	
	},

	/**
	 * Check if the filter control is multiselected
	 * @return {Boolean}
	 */
	isMultiSelected: function() {
		return true;
	}	
});

/**
 * The class combaining the SimpleFilterControl and MultiSelectFilterControl functionalities
 */
Runner.controls.OnDemandFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * The indicator showing if control in multiselection mode ot not
	 * (this mode is turning on by clicking on the "Multiselect" button)
	 * @type {Boolean}
	 */
	multiSelection: false,
	
	/**
	 * It stores the array of the filter checkboxes' jQuery objects
	 * @type {Array}
	 */
	checkboxes: [],
	
	/**
	 * The name of the filter checkboxes' class
	 * @type {String}
	 */
	checkboxClass: '',
		
	/**
	 * The name of the Filter "Multiselect" button's class
	 * @type {String}
	 */
	btnMultiselectClass: "",
	
	/**
	 * The caption of the filter's "Apply" button
	 * @type {String}
	 */
	btnApplyCaption: Runner.lang.constants.TEXT_FILTER_APPLY,
		
	/**
	 * The link to the Runner.controls.OnDemandFilterControl's base class
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	superclass: {},

	/**
	 * The link to the Runner.controls.MultiSelectFilterControl
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	multiSelectFCtrl: {},
	
	/**
	 * The link to the Runner.controls.SimpleFilterControl
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	simpleFCtrl: {},

	/**
	 * The class name of the filtered not multiselected filter's values
	 * @type {String}
	 */
	filteredValuesClass: "filter-ready-value",	
	
	/**
	 * The filter values links class name
	 * @type {String}
	 */	
	valueLinkClass: "",

	/**
	 * The common multiselect checkbox class name
	 * @type {String}	
	 */
	commonCheckboxClass: "multifilter-checkbox",
	
	/**
	 * The parent filter checkbox class name
	 * @param {String}
	 */
	parentCheckboxClass: "",	
	
	
	constructor: function( cfg ) {
		this.checkboxes = [];
		
		Runner.controls.OnDemandFilterControl.superclass.constructor.call( this, cfg );
	},
	
	/**
	 * Init the checkboxes array with the array of the filter checkboxes' jQuery objects.
	 * Set the control's default value and init contol's buttons and links. 
	 */
	init: function() {	
		this.superclass = Runner.controls.OnDemandFilterControl.superclass;
		this.multiSelectFCtrl = Runner.controls.MultiSelectFilterControl.prototype;
		this.simpleFCtrl = Runner.controls.SimpleFilterControl.prototype; 

		this.btnMultiselectClass = 'filter-' + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) + '-btn-multiselect';		
		this.applyButton = $("." + this.btnMultiselectClass);
		
		this.checkboxClass = 'filter_' + this.gfieldName + "_" + this.searchController.id;
		this.checkboxes = $('.' + this.checkboxClass);		
		this.parentCheckboxClass = this.dependent ? 'filter_' + this.goodParentName + "_" + this.searchController.id : '';
		this.selectAllCheckbox = $('.filter-selectAll-' + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ));	
		
		this.valueLinkClass = this.gfieldName + '-filter-value';
		
		this.setValue( this.defaultValuesArray.join(', ') );
		this.initButtons(); 		
	},
	
	/**
	 * Adjust the flter's 'Select/Deselect All' checkbox basing on the filter's checkboxes state.
	 */	
	adjustSelectAllCheckbox: Runner.controls.MultiSelectFilterControl.prototype.adjustSelectAllCheckbox,
	
	/**
	 * Clear check boxes for multiselect dependent controls
	 * and clear values for not multiselected ones
	 * @param {DOM element} checkbox
	 */	
	adjustDependentFilters: Runner.controls.MultiSelectFilterControl.prototype.adjustDependentFilters,
	
	/**
	 * Update dependent filters checkboxes of the corresponding value blocks
	 * basing on the main filter's current checkbox state
	 * The method depends on the Filter panel blocks markup
	 * @param {DOM element} checkbox
	 */
	adjustDependentFilterCheckboxes: Runner.controls.MultiSelectFilterControl.prototype.adjustDependentFilterCheckboxes,

	/**
	 * Update the corresoinding parent filter's checkbox state
	 * basing on the value blocks's checkboxes state	
	 * The method depends on the Filter panel value blocks markup	 
	 * @param {DOM element} checkbox
	 */
	adjustParentFilterCheckbox: Runner.controls.MultiSelectFilterControl.prototype.adjustParentFilterCheckbox,
	
	/**
	 * A stub for the Runner.controls.OnDemandFilterControl class
	 */
	adjustInvisibleCheckboxes: Runner.emptyFn,
	
	/**
	 * Init control's buttons and links
	 */
	initButtons: function() {
		var ctrl = this,
			anotherApplyButtonExists = !!$(".filter-apply-" + this.gfieldName).not( this.applyButton ).length;
		
		if ( this.dependent ) {
			anotherApplyButtonExists = !!$(".filter-apply-" + this.goodOutermostParentName).not( this.applyButton ).length;
		}
		
		this.applyButton.one("click", function(e) {
			var $button = $(this);

			if ( anotherApplyButtonExists ) { 
				$button.hide();
			}		
			
			$button
				.text( ctrl.btnApplyCaption )
				.addClass( ctrl.btnApplyClass )
				.removeClass( ctrl.btnMultiselectClass );			
						
			$("." + ctrl.valueLinkClass)
				.removeClass( ctrl.valueLinkClass )
				.addClass( "multiSelect-" + ctrl.valueLinkClass );
			
			ctrl.checkboxes.show();
			ctrl.addNewValueLinkFunctionality();
			ctrl.selectAllCheckbox.show();
			
			if ( !ctrl.dependent || ctrl.filtered ) {				
				$("." + ctrl.hiddenValuesClass, ctrl.filterContainer)
					.show()
					.removeClass( ctrl.hiddenValuesClass );
				
				$("." + ctrl.filteredValuesClass + ".ondemand", ctrl.filterContainer)
					.hide()
					.addClass( ctrl.hiddenValuesClass );
			}
			
			if ( ctrl.dependent && !ctrl.searchController.hasFilteredParentFilter( ctrl.parentFilterNames) ) {
				// hide the 'delete filter' button after switching ti the multiselect mode
				$(".delFilterCtrlButt_" + ( ctrl.dependent ? ctrl.goodOutermostParentName : ctrl.gfieldName ) + "_" + ctrl.searchController.id).hide();
			}
			
			ctrl.multiSelection = true;
			return false;
		});

		//call the SimpleFilterControl's method
		this.simpleFCtrl.initButtons.call( this );
		//call the MultiSelectFilterControl's method
		this.multiSelectFCtrl.initButtons.call( this );		
	},

	/**
	 * Update parent filters' values
	 * @param {Object} parentFiltersValuesData
	 */
	updateParentFilters: Runner.controls.SimpleFilterControl.prototype.updateParentFilters,
	
	/**
	 * Reassign the value-links click handler
	 */
	addNewValueLinkFunctionality: function() {
		var newValueLinkClass = 'multiSelect-' + this.gfieldName + '-filter-value';
		
		this.filterPanelContainer.on('click', '.' + newValueLinkClass, function(e) {
			var $link = $(this),
				linkValue = $link.data('filtervalue')
				$checkbox = $link.siblings().filter( function() {
						return this.value === linkValue; 
					});
				
			$checkbox.prop('checked', true);	
			return false;
		});
	},
	
	/**
	 * Get filter's value. 
	 * If the multiselection is turned on for the "on Demand" control or its field is filtered
	 * It uses the borrowed method "getFilterValue" from the MultiSelectFilterControl.
	 * Otherwise it borrows the superclass "getFilterValue" method
	 *
	 * @return {String}
	 */
	getValue: function() { 
		if ( this.multiSelection || this.filtered ) {
					//call the MultiSelectFilterControl's method
			return this.multiSelectFCtrl.getValue.call( this );
		}
				//call the base class method
		return this.superclass.getValue.call( this );
	},
	
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the multiselection is turned on for the "on Demand" control or its field is filtered
	 * It uses the borrowed method "getFilterValue" from the MultiSelectFilterControl.
	 * Otherwise it borrows the superclass "getFilterValue" method
	 *
	 * @return {String}
	 */
	getFilterValue: function( encoded ) {
		if ( this.multiSelection || this.filtered ) {
					//call the MultiSelectFilterControl's method
			return this.multiSelectFCtrl.getFilterValue.call( this, encoded );
		}
				//call the base class method
		return this.superclass.getFilterValue.call( this, encoded );
	},

	/**
	 * Clear the filter control
	 */
	clearControl: function() {
		if ( this.multiSelection || this.filtered ) {
			this.checkboxes.prop('checked', false);
			this.selectAllCheckbox.prop('checked', false);
		} 
		
		this.setValue('');
	},
	
	/**
	 * Delete a particular value from the filter's submit-values
	 * by unchecking the corresponding checkbox
	 * @param {Strging} valueToDelete
	 * @param {jQuery object} $container	 
	 */
	clearFilterValue: function( valueToDelete, $container ) {
		if ( !this.dependent ) {
			this.checkboxes
				.filter( function() {	
					return this.value === valueToDelete;
				})
				.prop('checked', false);
			
			return;
		}
		
		this.checkboxes
			.filter( function() {
				return !!$container.find( this ).length;
			})
			.prop('checked', false);
		
		if ( this.hasDependent ) {
			$('.' + this.commonCheckboxClass, $container).prop('checked', false); 			
		}			
	},
	
	/**
	 * Set a single value to the filter control
	 * @param {Mixed}
	 */
	updateValue: function( value ) {
		if ( this.multiSelection ) {
			this.checkboxes.prop('checked', false);
			this.setValue( [value] );
		} 
		
		this.setValue( value );
	},
	
	/**
	 * Check if the filter control is multiselected	
	 * @return {Boolean}
	 */
	isMultiSelected: function() {
		return this.multiSelection;
	}
});


/**
* The Slider Filter control class
*/
Runner.controls.SliderFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * The jQueryUI slider object 
	 * @type {Object}
	 */
	sliderElem: {},
	
	/**
	 * The jQueryUI slider's range param
	 * It could be assigned with a corresponding key from the config
	 * @type {Number}
	 */
	range: true,

	/**
	 * The jQueryUI slider's min value
	 * It could be assigned with a corresponding key from the config
	 * @type {String|Number}
	 */	
	minValue: 0,

	/**
	 * The jQueryUI slider's max value
	 * It could be assigned with a corresponding key from the config
	 * @type {String|Number}
	 */	
	maxValue: 0, 

	/**
	 * The jQueryUI slider's step value
	 * It could be assigned with a corresponding key from the config
	 * @type {Number}
	 */	
	step: 1,

	/**
	 * A param setting th slider type 
	 * ("min", "max", "both")
	 * @type {Number}
	 */
	knobsType: 0,
	
	/**
	 * The rounded max slider's value
	 * @type {Number}
	 */
	roundedMax: 0,
	
	/**
	 * The rounded min slider's value	
	 * @type {Number}
	 */	
	roundedMin: 0,
	
	/**
	 * The rounded max slider knob's value	
	 * @type {Number}
	 */		
	roundedMaxKnobValue: 0,
	
	/**
	 * The rounded min slider knob's value		
	 * @type {Number}
	 */		
	roundedMinKnobValue: 0,	
	
	/**
	 * An indicator showing if the 'Apply' 
	 * button is added to the filter 
	 * @type {Boolean}
	 */
	useApllyBtn: false,

	
	constructor: function( cfg ) {
		Runner.controls.SliderFilterControl.superclass.constructor.call( this, cfg );
	},

	/**
	 * Set default filter's values
	 */
	setDefaultValues: function() {
		this.ctrlValues = [ this.minKnobValue, this.maxKnobValue ];
	},

	/**
	 * Get the string representation of the control's value
	 * @return {String}
	 */
	getValue: function() {
		return this.getCaptionValue( this.ctrlValues[0] ) + " - " + this.getCaptionValue( this.ctrlValues[1] );
	},
	
	/**
	 * Init the slider control
	 */
	init: function() {
		var jQsliderValues, sliderParams;
		
		jQsliderValues= $("#slider_values_" + this.gfieldName);
		this.jQmax = $(".slider-max", jQsliderValues); 
		this.jQmin = $(".slider-min", jQsliderValues);	
	
		this.setDefaultValues();	
		this.range = this.getRange();
		
		sliderParams = this.getSliderParams();	
		this.sliderElem = $("#slider_" + this.gfieldName)
			.slider( sliderParams );
			
		this.setPageMaxZIndex();	
		
		this.initButtons();			
	},
	
	/**
	 * A stub
	 */
	initShowMoreButton: Runner.emptyFn,
	
	/**
	 * Set the Runner 'z-index' counter not lower that the slider's handle 'z-index' value
	 */ 
	setPageMaxZIndex: function() {
		var handleZIndex = parseInt( $('.ui-slider-handle', this.sliderElem).css('z-index'), 10 );
		Runner.setZindexMax( handleZIndex );	
	},
	
	/**
	 * Get the jQuery slider range param
	 */
	getRange: function() {
		if ( this.knobsType === Runner.controls.constants.FILTER_KNOBS_MIN_ONLY ) {
			return 'max';
		}		
		if ( this.knobsType === Runner.controls.constants.FILTER_KNOBS_MAX_ONLY ) {
			return 'min';
		}	
		return true;
	},
	
	/**
	 * Get jQuery slider params
	 * @return {object}
	 */
	getSliderParams: function() {
		var filter = this,
			sliderParams = {
				range: this.range,
				min: this.roundedMin,
				max: this.roundedMax,
				step: parseFloat( this.step )
			},
			typeBasedParams;
			
		typeBasedParams = this.getSliderParamsByType( this.range );
		Runner.apply( sliderParams, typeBasedParams );
		
		if ( !this.useApllyBtn ) {	
			sliderParams.stop = function() {
				filter.searchController.submitSearch();
			}			
		}	
		return sliderParams;
	},
	
	/**
	 * Get jQuery slider params basing on the slider's range type
	 * @param {string | boolean} range
	 * @return {object}
	 */
	getSliderParamsByType: function( range ) {
		var filter = this;
		
		switch ( this.range ) {
			case 'min':
			return {
				value: parseFloat( this.roundedMaxKnobValue ),
				slide: function( event, ui ) {
					filter.processMaxValue( ui.value, $(this).slider("option", "min") === ui.value );	
				}
			};

			case 'max':
			return {
				value: parseFloat( this.roundedMinKnobValue ),
				slide: function( event, ui ) {
					filter.processMinValue( ui.value, $(this).slider("option", "max") === ui.value );
				}
			};

			default:
			return {
				values: [ parseFloat( this.roundedMinKnobValue ), parseFloat( this.roundedMaxKnobValue ) ],	
				slide: function( event, ui ) {
					var oldValues = $( this ).slider( "values" ),
						min = ui.values[ 0 ],
						max = ui.values[ 1 ],
						oldMin = oldValues[ 0 ],
						oldMax = oldValues[ 1 ];
								
					if ( min !== oldMin ) {
						filter.processMinValue( min, min === max );
						return;			
					}
					if ( max !== oldMax ) {			
						filter.processMaxValue( max, min === max );
						return;							
					}
				}
			};
		}		
	},

	/**
	 * Set the conttol's min value and caption
	 * @param {number} min
	 * @param {boolean} minIsEqualToMax	 
	 */	
	processMinValue: function( min, minIsEqualToMax ) {
		var value = this.getSliderValue( min, true, minIsEqualToMax );
		
		this.setMinValue( value );
		this.setCaptions( value, true );
	},

	/**
	 * Set the conttol's max value and caption
	 * @param {number} max
	 * @param {boolean} minIsEqualToMax
	 */	
	processMaxValue: function( max, minIsEqualToMax ) {
		var value = this.getSliderValue( max, false, minIsEqualToMax );
					
		this.setMaxValue( value );
		this.setCaptions( value, false );	
	},
	
	/**
	 * Set the control's captions	
	 * @param {number} value	
	 * @param {boolean} isLower
	 */		
	setCaptions: function( value, isLower ) {
		var jQmainCaption = isLower ? this.jQmin : this.jQmax,
			caption = this.getCaptionValue( value );	
		
		jQmainCaption.html( caption );	
	},
	
	/**
	 * Replace the obtained slider's extreme value with
	 * the real corresponding database value		
	 * @param {number} value
	 * @param {boolean} isLower
	 * @param {boolean} minIsEqualToMax
	 * @return {number}
	 */
	getSliderValue: function( value, isLower, minIsEqualToMax ) {
		if ( value === this.roundedMin ) {
			return parseFloat( this.minValue );
		}
		
		if ( value === this.roundedMax ) { 
			return parseFloat( this.maxValue )
		}
		
		return value;
	},

	/**	
	 * Get the correct slider's caption	
	 * @param {number} value
	 * @return {number}
	 */
	getCaptionValue: function( value ) {
		if ( this.viewAsCurrency ) {
			return this.getCurrencyFormattedString( value, this.currencySettings );
		}
		
		if ( this.viewAsNumber ) {
			return this.getNumberFormattedString( value, this.numberSettings );
		}
		
		return value;
	},	
	
	/**
	 * Set the min slider control's value
	 * @param {number} minValue
	 */
	setMinValue: function( minValue ) {
		this.ctrlValues[0] = minValue;
	},
	
	/**
	 * Set the max slider control's value
	 * @param {number} maxValue
	 */
	setMaxValue: function( maxValue ) {
		this.ctrlValues[1] = maxValue;
	},
		
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the encoded param is defined and equal to true 
	 * It returns the encoded value
	 * @param {boolean} encoded 
	 * @return string
	 */
	getFilterValue: function( encoded ) {
		var value;
		
		if ( this.ctrlValues[0] === undefined && this.ctrlValues[1] === undefined ) {
			// the slider isn't activated
			return '';
		}
		
		if ( !this.filtered ) {
			this.prepareControlValues();
		}
		
		if ( this.knobsAreOnTheLimits() ) {
			// the knobs are set on the min and max slider's values
			return '';
		}
		
		value = this.getTypeBasedValue();
		return "(" + this.searchController.searchEscape( this.fieldName ) + this.separator + value + ")";
	},
	
	/**
	 * Get the control's value/values to add them 
	 * to the submit-string 
	 * @param {boolean} encoded
	 * @return {string}
	 */
	getTypeBasedValue: function( encoded ) {			
		switch ( this.range ) {
			case 'min':
			return this.getPreparedMaxValue( encoded );

			case 'max':
			return this.getPreparedMinValue( encoded );
				
			default:				
				var valueMin = this.getPreparedMinValue( encoded ),
					valueMax = this.getPreparedMaxValue( encoded );
					
			return valueMin + "~" + valueMax;
		}
	},

	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's min value string
	 * @param {boolean} encoded
	 * @return {string}
	 */		
	getPreparedMinValue: function( encoded ) {
		return this.getPreparedValue( this.ctrlValues[0], encoded );
	},

	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's max value string
	 * @param {boolean} encoded
	 * @return {string}
	 */		
	getPreparedMaxValue: function( encoded ) {
		return this.getPreparedValue( this.ctrlValues[1], encoded );
	},	
	
	/**
	 * Replace undefined filter's values with corresponding
	 * slider's min and max values
	 */	
	prepareControlValues: function() {
		if ( this.ctrlValues[0] === undefined ) {
			this.ctrlValues[0] = this.minValue;
		}
		if ( this.ctrlValues[1] === undefined ) {
			this.ctrlValues[1] = this.maxValue;
		}
	},
	
	/**
	 * Check if the slider's min and max knobs are equal to the
	 * the min and max slider's values respectively
	 * @return {boolean}
	 */
	knobsAreOnTheLimits: function() {
		return this.ctrlValues[0] === this.minValue && this.ctrlValues[1] === this.maxValue;
	},
	
	/**
	 * Get the formmated string representating the number: 
	 * insert the thousand separators,
	 * replace the decimal separator with correct one,
	 * format the number of decimal digits.
	 * If the number is negative the method returns 
	 * the formatted number's absolute value
	 * @param {number} number
	 * @return {string}
	 */		
	getNumberAbsoluteValueFormatted: function( number ) {
		var iDigits = this.commonFormatSettings['decimalDigits'],
			grouping = this.commonFormatSettings["grouping"], 
			ptr, i, outStart, outEnd;
		
		number = number.toFixed( iDigits ); 
		intPart = number >= 0 ? Math.floor( number ) : Math.floor( -number );
		fracPart = number >= 0 ? number - intPart : -number - intPart;
		out = intPart.toFixed(0);
		
		// add sousand separators to the integer part of the number
		if ( grouping.length && parseInt( grouping[0], 10 ) ) {
			ptr = out.toString().length;
			for (i = 0; i < grouping.length; i++) {
				if ( !parseInt( grouping[i], 10 ) ) {
					i--;
				}
				if ( ptr <= grouping[i] ) {
					break;
				}
				ptr = ptr - grouping[i];
				outStart = out.slice( 0, ptr );
				outEnd = out.slice( ptr );
				out = outStart + this.commonFormatSettings["thousandSep"] + outEnd;
			}
		}
		
		// add a decimal separator and the fractional part to the integer part 
		if ( iDigits > 0 ) {
			fracPart = ( fracPart * Math.pow(10, iDigits) ).toFixed(0);
			while ( fracPart.length < iDigits ) {
				fracPart = "0" + fracPart;
			}
			out += this.commonFormatSettings["decimalSep"] + fracPart;
		}
		return out;
	},
	
	/**
	 * Get the correct number format string for a slider's value
	 * @param {number} number
	 * @return {string}
	 */	
	getNumberFormattedString: function( number ) {
		var positiveSign = number >= 0,
			numberSettings = this.formatSettings,
			outString = this.getNumberAbsoluteValueFormatted( number );
		
		// add the positive/negative signs to the formatted number
		if ( positiveSign || parseInt(outString, 10) === 0 ) {
			return numberSettings["LOCALE_SPOSITIVESIGN"] + outString;
		}
		
		switch ( numberSettings["LOCALE_INEGNUMBER"] ) {
			case "0":
				return "(" + outString + ")";
			case "1":
				return "-" + outString;
			case "2":
				return "- " + outString;
			case "3":
				return outString + "-";
			case "4":
				return outString + " -";
			default:
				return outString;
		}
	},	
		
	/**
	 * Get the correct currency format string for a slider's value
	 * @param {number} number
	 * @return {string}
	 */	
	getCurrencyFormattedString: function( number ) {
		var positiveSign = number >= 0,
			currencySettings = this.formatSettings,
			outString = this.getNumberAbsoluteValueFormatted( number );

		if ( positiveSign || parseInt(outString, 10) === 0 ) {
			switch ( currencySettings["LOCALE_ICURRENCY"] ) {
				case "0":
					return currencySettings["LOCALE_SCURRENCY"] + outString;
				case "1":
				case "2":
					return currencySettings["LOCALE_SCURRENCY"] + " " + outString;
				case "3":
					return outString + " " + currencySettings["LOCALE_SCURRENCY"];
				default:
					return outString;			
			}					
		}
		
		switch ( currencySettings["LOCALE_INEGCURR"] ) {
			case "0":
				return "(" + currencySettings["LOCALE_SCURRENCY"] + outString + ")";			
			case "1":
				return "-" + currencySettings["LOCALE_SCURRENCY"] + outString;				
			case "2":
				return currencySettings["LOCALE_SCURRENCY"] + "-" + outString;
			case "3":
				return currencySettings["LOCALE_SCURRENCY"] + outString + "-";
			case "4":
				return "(" + outString + currencySettings["LOCALE_SCURRENCY"] + ")";		
			case "5":
				return "-" + outString + currencySettings["LOCALE_SCURRENCY"];
			case "6":
				return outString + "-" + currencySettings["LOCALE_SCURRENCY"];
			case "7":
				return outString + currencySettings["LOCALE_SCURRENCY"] + "-";
			case "8":
				return "-" + outString + " " + currencySettings["LOCALE_SCURRENCY"];				
			case "9":
				return "-" + currencySettings["LOCALE_SCURRENCY"] + " " + outString;	
			case "10":
				return outString + " " + currencySettings["LOCALE_SCURRENCY"] + "-";
			case "11":
				return currencySettings["LOCALE_SCURRENCY"] + " " + outString + "-";
			case "12":
				return currencySettings["LOCALE_SCURRENCY"] + " -" + outString;
			case "13":
				return outString + "- " + currencySettings["LOCALE_SCURRENCY"];
			case "14":
				return "(" + currencySettings["LOCALE_SCURRENCY"] + " " + outString + ")";	
			case "15":
				return "(" + outString + " " + currencySettings["LOCALE_SCURRENCY"] + ")";
			default:
				return outString;	
		}
	},
	
	/**
	 * Clear the filter control's values
	 */
	clearControl: function() {
		this.ctrlValues = [];
	}
});

/**
 * The Date Slider Filter control class
 */
Runner.controls.DateSliderFilterControl = Runner.extend( Runner.controls.SliderFilterControl, {
	/**
	 * @type {number}
	 */
	stepType: Runner.controls.constants.FILTER_STEP_DAY,

	/**
	 * @type {boolean}
	 */
	isFieldDateType: true,
	
	/**
	 * @type {boolean}
	 */	
	processWrappers: true,
	
	/**
	 * Array of month names
	 * @type {array}
	 */
	monthNames: [
		Runner.lang.constants.TEXT_MONTH_JAN,
		Runner.lang.constants.TEXT_MONTH_FEB,
		Runner.lang.constants.TEXT_MONTH_MAR,
		Runner.lang.constants.TEXT_MONTH_APR,
		Runner.lang.constants.TEXT_MONTH_MAY,
		Runner.lang.constants.TEXT_MONTH_JUN,
		Runner.lang.constants.TEXT_MONTH_JUL,
		Runner.lang.constants.TEXT_MONTH_AUG,
		Runner.lang.constants.TEXT_MONTH_SEP,
		Runner.lang.constants.TEXT_MONTH_OCT,
		Runner.lang.constants.TEXT_MONTH_NOV,
		Runner.lang.constants.TEXT_MONTH_DEC
	],	
	
	
	constructor: function( cfg ) {
		Runner.controls.DateSliderFilterControl.superclass.constructor.call( this, cfg ); 
	},

	/**
	 * Set default filter's values
	 * Elements of the ctrlValues array should have 
	 * the object (Date) or undefined type
	 */
	setDefaultValues: function() {
		var minKnob = this.minKnobValue,
			maxKnob = this.maxKnobValue;

		if ( minKnob ) {
			minKnob = this.parseDateTime( minKnob, this.dateFormat );
		}
		if ( maxKnob ) {
			maxKnob = this.parseDateTime( maxKnob, this.dateFormat );
		}
		this.ctrlValues = [ minKnob, maxKnob ];
	},
	
	/**
	 * Init the date-slider control
	 */
	init: function() {
		var jQsliderValues= $("#slider_values_" + this.gfieldName);
		this.jQcaptPrefix = $(".slider-caption-prefix", jQsliderValues);
		this.jQcaptPostfix = $(".slider-caption-postfix", jQsliderValues);
	
		this.dateFormat = Runner.pages.PageSettings.getGlobalData("locale").dateFormat;	
		this.dateDelimiter = Runner.pages.PageSettings.getGlobalData("locale").dateDelimiter;

		this.minDate = this.parseDateTime( this.minValue, this.dateFormat );
		this.minDateInMs = this.minDate.getTime();
		this.maxDate = this.parseDateTime( this.maxValue, this.dateFormat );
		this.maxDateInMs = this.maxDate.getTime();
		
		if ( this.stepType === Runner.controls.constants.FILTER_STEP_SEC 
			|| this.stepType === Runner.controls.constants.FILTER_STEP_MIN ) {
			
			this.realMaxDate = this.parseDateTime( this.realMaxValue, this.dateFormat );
			this.realMinDate = this.parseDateTime( this.realMinValue, this.dateFormat ); 
		}		
		
		Runner.controls.DateSliderFilterControl.superclass.init.call( this );		
	},
	
	/**
	 * Get date-time formatted string	
	 */
	printDateTime: Runner.controls.DateField.prototype.printDateTime,

	/**
	* Create the Date object from the string representation
	* basing on the date format
	*/
	parseDateTime: Runner.controls.DateField.prototype.parseDateTime,	
			
	/**
	 * Replace the obtained slider's extreme value with
	 * the corresponding corresponding Date object		
	 * @param {number} value
	 * @param {boolean} isLower
	 * @param {boolean} minIsEqualToMax
	 * @return {Date object}
	 */
	getSliderValue: function( value, isLower, minIsEqualToMax ) {
		var prepDate = new Date( this.minDateInMs ),
			year, month, day, unitStep;
		
		switch ( this.stepType ) {
			case Runner.controls.constants.FILTER_STEP_SEC :		
			case Runner.controls.constants.FILTER_STEP_MIN :	
				if ( value === this.roundedMax ) {
					prepDate = this.realMaxDate;
					break;
				}	
				if ( value === this.roundedMin ) {
					prepDate = this.realMinDate;
					break;	
				} 
				prepDate = new Date( this.minDateInMs + value * 1000 );	
			break;	
				
			case Runner.controls.constants.FILTER_STEP_MONTH :				
				month = prepDate.getMonth() + value;			
				prepDate.setMonth( month );
				
				if (!isLower) {
					prepDate.setDate( prepDate.getDate() - 1 );
				}

				if ( minIsEqualToMax ) {
					month = prepDate.getMonth();
					year = prepDate.getFullYear();
					
					month = isLower ? month - 1 : month + 2;					
					day = isLower ? 1 : 0;
					prepDate = new Date(year, month, day);
				}			
			break;			
		
			case Runner.controls.constants.FILTER_STEP_YEAR :				
				month = isLower ? 0 : 11;
				day = isLower ? 1 : 31
				
				if ( value === this.roundedMax ) {
					year = this.maxDate.getFullYear();
				} else {				
					unitStep = parseFloat( this.step ) === 1;
					year = prepDate.getFullYear() + value;
					
					if (!isLower) {
						year = ( minIsEqualToMax || unitStep ) ? year : year - 1;
					} else {
						year = ( minIsEqualToMax && !unitStep ) ? year - 1 : year;
					}
				}
				prepDate = new Date(year, month, day);		
			break;		
		
			default: 
				prepDate = new Date( this.minDateInMs + value * 1000 );	
		}
			
		return prepDate;
	},
	
	/**
	 * Set the control's captions	
	 * @param {Date object} prepDate	
	 * @param {boolean} isLower
	 */		
	setCaptions: function( prepDate, isLower ) {
		Runner.controls.DateSliderFilterControl.superclass.setCaptions.call( this, prepDate, isLower );
		
		if ( this.processWrappers ) {
			this.setWrapperCaption( isLower, prepDate );
		}
	},
	
	/**
	 * Set the captions for the sliders of the
	 * 'month', 'hours', 'minutes' or 'seconds' 
	 * step types basing on which knob was moving 
	 * @param {boolean} isLower
	 * @param {Date object} date
	 */	
	setWrapperCaption: function( isLower, date ) {
		this.setCaptionsVisibility( isLower, date );
		
		if ( !isLower && this.showTime ) {
			this.jQcaptPostfix.html( this.printTime(date) );
			return;
		}
		if ( isLower && this.stepType === Runner.controls.constants.FILTER_STEP_MONTH ) {
			this.jQcaptPrefix.html( this.monthNames[ date.getMonth() ] );
		}
	},
	
	/**
	 * Set the captions vsibility for the sliders of the
	 * 'month', 'hours', 'minutes' or 'seconds' step types 
	 * @param {boolean} isLower
	 * @param {Date object} date 
	 */	
	setCaptionsVisibility: function( isLower, date ) {
		var otherKnobDate = isLower ? ( this.ctrlValues[1] || this.maxDate ) : ( this.ctrlValues[0] || this.minDate ), 
			visible;
		
		if ( this.showTime ) {
			visible = this.checkDatesEqual( otherKnobDate, date );	
			this.jQcaptPostfix.toggle( visible );
		
			this.jQmax.toggle( !visible );
			return;	
		} 

		if ( this.stepType === Runner.controls.constants.FILTER_STEP_MONTH ) {
			visible = otherKnobDate.getFullYear() === date.getFullYear();			
			this.jQcaptPrefix.toggle( visible );
			
			this.jQmin.toggle( !visible );
		}
	},	
	
	/**
	 * Check if two dates passed are equal or not
	 * disregarding the time values
	 * @param {Date object} date1 
	 * @param {Date object} date2 
	 * @param {Boolean}
	 */
	checkDatesEqual: function( date1, date2 ) {
		return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
	},
	
	/**	
	 * Get the correct slider's caption
	 * @param {Date object} date
	 * @return {string}
	 */
	getCaptionValue: function( date ) {
		if ( this.stepType === Runner.controls.constants.FILTER_STEP_YEAR ) {
			return date.getFullYear();
		}
		
		if ( this.stepType === Runner.controls.constants.FILTER_STEP_MONTH ) {
			return this.monthNames[ date.getMonth() ] + " " + date.getFullYear();
		}
		
		return this.printDateTime( date, this.dateFormat, true );
	},	
	
	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's max knob value's string representation
	 * @param {boolean} encoded
	 * @return {string}
	 */
	getPreparedMaxValue: function( encoded ) {
		var date = this.ctrlValues[1], 
			stringValue = this.getStringValueFromDate( date );
			
		return Runner.controls.DateSliderFilterControl.superclass.getPreparedValue( stringValue, encoded );
		
	},
	
	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's min knob value's string representation
	 * @param {boolean} encoded
	 * @return {string}
	 */	
	getPreparedMinValue: function( encoded ) {
		var date = this.ctrlValues[0],
			stringValue = this.getStringValueFromDate( date );
			
		return Runner.controls.DateSliderFilterControl.superclass.getPreparedValue( stringValue, encoded );
	},
	
	/**
	 * Replace undefined filter's values with corresponding
	 * slider's min and max date values
	 */	
	prepareControlValues: function() {
		var date;
		
		if ( this.ctrlValues[0] === undefined || this.ctrlValues[0] === null ) {
			date = this.realMinDate || this.minDate;
			if ( this.stepType === Runner.controls.constants.FILTER_STEP_YEAR ) {
				date = new Date( date.getFullYear(), 0, 1 );
			}			
			this.ctrlValues[0] = date;
		}
		
		if ( this.ctrlValues[1] === undefined || this.ctrlValues[1] === null ) {
			date = this.realMaxDate || this.maxDate;
			if ( this.stepType === Runner.controls.constants.FILTER_STEP_YEAR ) {
				date = new Date( date.getFullYear(), 11, 31 );
			} 				
			this.ctrlValues[1] = this.maxDate;
		}
	},

	/**
	 * Check if the slider's min and max knobs are equal to the
	 * the min and max slider's values respectively
	 * @return {boolean}
	 */
	knobsAreOnTheLimits: function() {
		if ( this.ctrlValues[0].toString() === ( this.realMinDate || this.minDate ).toString() &&
			 this.ctrlValues[1].toString() === ( this.realMaxDate || this.maxDate ).toString() ) {
			 
			return true;
		}
		return false;
	},
	
	/**
	 * Get the db-formatted date/date-time string
	 * @param {Date object} date
	 * @return {string}
	 */
	getStringValueFromDate: function( date ) {
		var dateString,
			day = date.getDate(),
			month = date.getMonth() + 1,
			year = date.getFullYear(),
			hours, minutes, seconds;
		
		dateString = year + '-' + month + '-' + day;
		
		if ( this.showTime ) {
			hours = date.getHours();
			hours = hours < 10 ? '0' + hours : hours;
			minutes = date.getMinutes();
			minutes = minutes < 10 ? '0' + minutes : minutes;
			seconds = date.getSeconds();
			seconds = seconds < 10 ? '0' + seconds : seconds;
			
			dateString += ' ' + hours + ':' + minutes + ':' + seconds;
		}
		
		return dateString;
	},
	
	/**
	 * Get the formated time string
	 * Here is the possible time formatch list:
	 * ("H:mm:ss","HH.mm.ss","HH:mm:ss","HH:mm:ss 'ch'","h::mm::ss tt","h:mm:ss tt","h:mm:ss.tt","hh:mm:ss tt","tt h:mm:ss","tt hh:mm:ss")	
	 *			 
	 * @param {Date object} date
	 * @return {string}
	 */
	printTime: function( date ) {
		var hours = date.getHours(),
			minutes = date.getMinutes(),
			seconds = date.getSeconds(),
			time = this.timeFormat,
			designator;
		
		if ( !this.is24hoursFormat ) {
			designator = hours >= 12 ? this.designators["pm"] : this.designators["am"];
			//designators are no added to 'hours' values greater than 23 
			designator = hours >= 24 ? "" : designator;
			time = time.replace( "tt", designator );
			
			//a correction is not applied to 'hours' values greater than 24 or lesser than 12
			hours = hours > 12 && hours < 24 ? hours - 12 : hours;
			hours = hours === 0 ? 12 : hours;
			
			hours = this.leadingZero && hours < 10 ? '0' + hours : hours;
			time = time.replace( this.leadingZero ? "hh" : "h", hours );
		} else {
			hours = this.leadingZero && hours < 10 ? '0' + hours : hours;
			time = time.replace( this.leadingZero ? "HH" : "H", hours );
		}
		
		time = time.replace( "mm", minutes < 10 ? '0' + minutes : minutes );
		
		if ( this.showSeconds ) {
			time = time.replace( "ss", seconds < 10 ? '0' + seconds : seconds );
		} else {
			time = time.replace( this.timeDelimiter + "ss", "" );
		}		

		return time;
	}
});

/**
 * The Time Slider Filter control class
 */ 
Runner.controls.TimeSliderFilterControl = Runner.extend( Runner.controls.DateSliderFilterControl, {
	/**
	 * @type {number}
	 */
	TimezoneOffsetInHours: 0,

	/**
	 * @type {boolean}
	 */
	isFieldTimeType: true,
	
	/**
	 * @type {number}
	 */
	offsetDaytimeHours: 24,

	/**
	 * @type {boolean}
	 */	
	processWrappers: false,	
	
	
	constructor: function( cfg ) {
		Runner.controls.TimeSliderFilterControl.superclass.constructor.call(this, cfg); 
	},
	
	/**
	 * Init the time-slider control
	 */	
	init: function() {
		this.TimezoneOffsetInHours = new Date().getTimezoneOffset() / 60;
		this.offsetDaytimeHours = 24 + this.TimezoneOffsetInHours;	
		
		Runner.controls.TimeSliderFilterControl.superclass.init.call( this ); 
	},	
	
	/**
	 * Get the real hours value for the date passed
	 * @param {Date object} date
	 * @return {number}
	 */	
	getHoursValue: function( date ) {
		var dateInHours = date.getTime() / 3600000;
		
		// process the case when the hours value could be greater then 24
		if ( dateInHours < this.offsetDaytimeHours ) {	
			return date.getHours();
		}
		return Math.floor( dateInHours - this.TimezoneOffsetInHours );
	},	
	
	/**
	 * Get the db-formatted time string
	 * @param {Date object} date
	 * @return {string}
	 */
	getStringValueFromDate: function( date ) {
		var hours = this.getHoursValue( date ), 
			minutes = date.getMinutes(), 
			seconds = date.getSeconds();

		hours = hours < 10 ? '0' + hours : hours;
		minutes = minutes < 10 ? '0' + minutes : minutes;
		seconds = seconds < 10 ? '0' + seconds : seconds;
		
		return hours + ':' + minutes + ':' + seconds;
	}, 	
	
	/**	
	 * Get the correct slider's caption
	 * @param {Date object} date
	 * @return {string}
	 */
	getCaptionValue: function( date ) {				
		return this.printTime( date );	
	}
});

/**
 * Runner.pages.Defaults
 * Class wich contains default settings (global, tables, fileds, validation)
 * Insert new settings - only in alphabetical order 
 */
Runner.pages.Defaults = function() {
	this.globalSettings = {
		debugMode: false,
		pwdStrong: false,
		isMobile: false,
		webRootPath: "",
		s508: false,
		isFB: false,
		FBappId: "",
		FBLoginUrl: "",
		popupPagesLayoutNames: {},
		loginFormType: 0
	};
	this.tableSettings = {
		ajaxSuggest: true,
		confirmTime: 250,
		copy: false,
		defaultMembership: [],
		defaultRights: [],
		detailTables: {},
		popupPagesLayoutNames: {},
		dpParams: [],
		enableCtrls: true,
		events: {},
		firstTime: 0,
		fieldSettings: {},
		hasEvents: false,
		isEditOwn: false,
		isInlineAdd: false,
		isInlineEdit: false,
		isShowDetails: false,
		isUseAudio: false,
		isUseButtons: false,
		isUseCK: false,
		isUseDP: false,
		simpleSearchActive: false,
		isUseHighlite: false,
		isUsePopUp: false,
		isUseResize: false,
		isUseToolTips: false,
		isUseVideo: false,
		listGridLayout: 0,
		keys: {},
		listFields: [],
		locking: false,
		lockRecIds: [],
		mainMPageType: "",
		masterPageType: "",
		masterTable: "",
		maxPages: 1,
		nextKeys: {},
		pageMode: 0,
		pageNumber: 0,
		pageSkinStyle: "",
		passFieldName: 'password',
		permissions: {},
		prevKeys: {},
		proxy: {},
		recsPerRowList: 1,
		msg_emailError: "",
		msg_passwordError: "",
		msg_userError: "",
		rightsGroups: [],
		rightsTables: [],
		shortTNames: [],
		showAddInPopup: false,
		showEditInPopup: false,
		showRows: false,
		showViewInPopup: false,
		sKeys: "",
		strCaption: "",
		strKey: [],
		totalFields: [],
		usersList: [],
		warnOnLeaving: false,
		view: false,
		scrollGridBody: false,
		searchSaving: false,
		importFieldsLables: {},
		printerPageOrientation: Runner.pages.constants.PORTRAIT_PRINT_ORIENTATION,
		printGridLayout: Runner.pages.constants.HORIZONTAL_LAYOUT,
		reportPrintLayout: Runner.pages.constants.STEPPED_LAYOUT,
		reportType: Runner.pages.constants.REPORT_TYPE_STANDART,
		reportPrintMode: Runner.pages.constants.REPORT_MODE_PRINT_FRIENDLY,
		reportPrintPartitionType: Runner.pages.constants.REPORT_PRINT_PAGE_FIT,
		reportPrintGroupsPerPage: 3,
		lowGroup: 1,
		pageWidth: 700,
		pageHeight: 900,
		createPdf: 0,
		pdfFitToPage: 1,
		exportPdf: 0,
		printerPagePDF: false,
		crossTable: false,
		isRTL: false,
		isDashSearchPage: false
	};
	this.fieldSettings = {
		acceptFileTypes: ".+$",
		autoCompleteFields: [],
		autoUpload: false,
		categoryField: false,
		compatibilityMode: false,
		dateEditType: Runner.controls.constants.EDIT_DATE_SIMPLE,
		depLookups: [],
		dispField: "",
		editFormat: Runner.controls.constants.EDIT_FORMAT_NONE,
		freeInput: false,
		initialYear: 100,
		isDisabled: false,
		isHidden: false,
		isUseTimeStamp: false,
		lastYear: 10,
		lcType: Runner.controls.constants.LCT_DROPDOWN,
		linkField: "",
		lookupTable: "",
		mask: "",
		maxFileSize: undefined,
		maxNumberOfFiles: 1,
		maxTotalFileSize: undefined,
		nHeight: 200,
		nWidth: 100,
		RTEType: "",
		Multiselect: false,
		selectSize: 1,
		showTime: false,
		strName: "",
		timePick: {},
		validation: null,
		viewFormat: Runner.controls.constants.FORMAT_NONE
	};
	
	var self = this, 
		SOURCE_GLOBAL = 'g', 
		SOURCE_TABLE = 't', 
		SOURCE_FIELD = 'f', 
		getSettings = function(source, settingName) {
			var sourceName = source == SOURCE_GLOBAL ? 'globalSettings' 
					: source == SOURCE_TABLE ? 'tableSettings' : 'fieldSettings';
			if ( self[ sourceName ][ settingName ] != undefined ) {
				return self[ sourceName ][ settingName ];
			}
			return null;
		};
		
	this.getGlobalSettings = function(settingName) {
		return getSettings(SOURCE_GLOBAL, settingName);
	};
	
	this.getTableSettings = function(settingName) {
		return getSettings(SOURCE_TABLE, settingName);
	};
	
	this.getFieldSettings = function(settingName) {
		return getSettings(SOURCE_FIELD, settingName);
	};
	
	this.getValidationSettings = function() {
		return { 
			regExp: null, 
			validationArr: [],
			customMessages: []	
		};
	};
};

Runner.pages.Defaults = new Runner.pages.Defaults();
/** 
 * The global page manager object. 
 * Should not be created directly, only one instance per page. 
 * @singleton
 */
Runner.pages.PageManager = function() {
		// table managers collection
	var tables = {}, 
		// window 'onunload' handlers data array
		beforeUnloadPool = [];	
	
	if ( window.onunload ) {
		beforeUnloadPool.push( window.onBeforeUnload, window, [] );
	}
	window.onunload = function() {
		window.Runner.pages.PageManager.callUnload();
	}
	
	return {
		/**
		 * Register a page controller
		 * @param {object} pageController
		 */
		register: function( pageController ) {
			if ( !pageController ) {
				return;
			}
			var pageTable = pageController.tName,
				pageId = pageController.pageId;
			
			// if table not exists, create new one
			tables[ pageTable ] = tables[ pageTable ] || {};		
			tables[ pageTable ][ pageId ] = pageController;
		},
		
		/**
		 * Ge the page's controller by the table name and id.
		 * @param {string} tName
		 * @param {number} pageId 
		 * @return {mixed} return control, array of controls or false
		 */
		getAt: function( tName, pageId ) {
			if ( !tables[ tName ] || !tables[ tName ][ pageId ] ) {
				return false;
			}	
			
			return tables[ tName ][ pageId ];
		},
		
		/**
		 * Ge the page's controller by the table's id.		
		 * @param {number} pageId
		 * @return {mixed}		 
		 */
		getById: function( pageId ) {
			if ( typeof pageId == "undefined" ) {
				return false;
			}
			for (var tName in tables) {
				if ( typeof tables[ tName ][ pageId ] != "undefined" ) {
					return tables[ tName ][ pageId ];
				}
			}
			return false;
		},
		
		/**
		 * Unregister a page controller
		 * @param {string} tName
		 * @param {number} pageId 
		 * @return {boolean} true if success, otherwise false
		 */
		unregister: function( tName, pageId ) {	
			// if no table name passed, return false
			if ( !tables[ tName ] ) {
				return false;
			}	
			// recursively destroy pageObjects
			if (!pageId) {
				for (var id in tables[ tName ]) {
					this.unregister(tName, id);
				}
				
				delete tables[ tName ];
			} else if ( tables[ tName ][ pageId ] ) {
				if ( typeof tables[ tName ][ pageId ].destructor === "function" ) {					
					tables[ tName ][ pageId ].destructor();
				}
				
				Runner.pages.PageControlsMap.removeMap( tName, tables[ tName ][ pageId ].pageType, pageId );
				Runner.pages.PageViewControlsMap.removeMap( tName, tables[ tName ][ pageId ].pageType, pageId );
				delete tables[ tName ][ pageId ];
			}
			
			return true;
		},
		
		/**
		 * Initialize all preloaded pages
		 */
		initPages: function() {
			var controlsMap = Runner.pages.PageControlsMap.getMap(), 
				viewControlsMap = Runner.pages.PageViewControlsMap.getMap(),
				cfg, tName, pageType, pageId;
			
			for (tName in controlsMap) {
				for (pageType in controlsMap[ tName ]) {
					for (pageId in controlsMap[ tName ][ pageType ]) {
						cfg = {
							tName: tName, 
							pageType: pageType, 
							pageId: pageId, 
							controlsMap: controlsMap[ tName ][ pageType ][ pageId ] || {},
							viewControlsMap: viewControlsMap[ tName ][ pageType ][ pageId ] || {},
							pageMode: Runner.pages.PageSettings.getTableData(tName, "pageMode"),
							openMode: Runner.pages.constants.OPENMODE_PRELOADED,
						};
						this.initPage( cfg );
					}
				}
			}
			
			// init only once
			this.initPages = Runner.emptyFn;
			Runner.stopLoading(); //?
		},
		
		/**
		 * Create a page based popup window.		
		 * This function is run as the part of initialization routine.
		 * The context is newly-created Page object
		 */
		createPopup: function() {
			// YUI3 Panel constructor's attrs
			var args = {
				centered: true,
				modal: this.modal,
				bodyContent: this.bodyCont,
				headerContent: this.headerCont,
				footerContent: this.footerCont
			};
			
			// create the page based fly win using YUI3 Panel object
			Runner.pages.PageManager.createFlyWin.call( this, args, true, null, $.proxy( this.afterCloseFlyWinHandler, this ) );		
		},

		/**
		 * This function is run as the part of initialization routine.
		 * The context is newly-created Page object
		 * @param {object} obj
		 */
		putToContainer: function( obj ) {
			obj = obj || this;
			$(this.openContainer).html( obj.bodyCont )
				.prepend( obj.headerCont )
				.append( obj.footerCont );
		},

		/**
		 * This function is run as the part of initialization routine.
		 * The context is newly-created Page object
		 * @param {object} pageObj
		 * @param {jQuery obj} $container	
		 */
		putToDashContainer: function( pageObj, $container ) {
			pageObj = pageObj || this;
			
			var $table = $( "<table class='rnr-dbelemtable'></table>" ),
				$headerCont = $( pageObj.headerCont ),
				$footerCont = $( pageObj.footerCont ),
				$body;
			
			if ( $headerCont.length ) {

			if ( $headerCont.length > 1 ) {
					$headerCont = $("<div></div>").addClass("rnr-dbehcont").append( $headerCont );
				}
				
				$( "<td class='rnr-dbelemheader'></td>" ).append( $headerCont ).appendTo( $("<tr></tr>").appendTo( $table ) );
			}
			
			$body = $( "<td class='rnr-dbelembody'></td>" ).html( pageObj.bodyCont ).appendTo( $("<tr></tr>").appendTo( $table ) );
			
			if ( !Runner.isMobile && this.dashElementSettings.width ) {
				$body.children().first().css("width", this.dashElementSettings.width + "px")
					.css("overflow-x", "auto");
			}
			
			if ( this.dashElementSettings.height ) {
				$body.children().first().css("height", this.dashElementSettings.height + "px")
					.css("overflow-y", "auto");
			}
			
			if ( $footerCont.length ) {
				if ( $footerCont.length > 1 ) {
					$footerCont.css( "display", "inline-block");
				}
				$( "<td class='rnr-dbelemfooter'></td>" ).append( $footerCont ).appendTo( $("<tr></tr>").appendTo( $table ) );
			}
			
			$container = $container || $( this.openContainer );
			$container.html( '' ).append( $table );
			
			pageObj.pageCont = $container.get(0);
		},
		
		/**
		 *	The sequence of the page initialization:
		 *	1. Creating HTML structure - openPopup, putToContainer or other
		 *	2. Loading libraries required for the page initialization - page.loadFiles
		 *	3. Run caller-defined After-Create step: cfg.afterCreateHn
		 *	4. Run page-defined initialization steps: page.init and other
		 *	5. Run caller-defined After-Init step: cfg.afterInitHn
		 *	6. Correct window position
		 *	7. Run user-defined initialization step
		 * @param {object} cfg
		 * @return {object}		
		 */
		initPage: function( cfg ) {
			var page = Runner.pages.PageFactory(cfg), 
				tasksToPrepend = [], 
				tasksToAppend = [],
				_self = this;
			
			//	modify page initialization routine. Add container-related steps to the head of the queue.
			if ( !Runner.isMobile && cfg.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
				tasksToPrepend.push( this.createPopup );
			} else if ( cfg.openMode === Runner.pages.constants.OPENMODE_CONTAINER ) {
				tasksToPrepend.push( this.putToContainer );
			} else if ( cfg.openMode === Runner.pages.constants.OPENMODE_DASHCONTAINER ) {
				tasksToPrepend.push( this.putToDashContainer );
			} else if ( cfg.openMode === Runner.pages.constants.OPENMODE_TABVIEW ) {
				tasksToPrepend.push( this.putToTab );
			}
			
			tasksToPrepend.push( page.loadFiles );

			//	add caller-defined afterCreate step
			if ( cfg.afterCreateHn ) {
				tasksToPrepend.push( cfg.afterCreateHn );
			}
			//	add caller-defined afterInit step
			if ( cfg.afterInitHn ) {
				tasksToAppend.push( cfg.afterInitHn );
			}
			//	update popup position and size
			if ( !Runner.isMobile && cfg.openMode == Runner.pages.constants.OPENMODE_POPUP ) {
				tasksToAppend.push( function() {
					_self.correctYUIWindowSize( page.win, cfg.popupCentered, page );
				});
			}
				
			//	add user-defined initialization
			tasksToAppend.push( function() {
				page.fireEvent('afterPageReady', page, page.proxy, page.id);
			});
		
			page.prependInitTask( tasksToPrepend );
			page.addInitTask( tasksToAppend );
			
			//	proceed with the initialization
			page.goInitQueue();
	
			return page;
		},
			
		/**
		 * For dynamic page opening
		 * @param {object} pageParams
		 * @return {number} 			The page's id
		 * 
		 * All the parameters will be passed to the new page constructor as cfg param.
		 * Besides, some parameters have special meaning. They are:
		 *
		 *	 tName {string} 		- name of the table (chart/report etc). The tName will be used to make the request URL
		 *	 pageType {string} 		- one of the PAGE_ constants, used to make the request URL.
		 *	 baseParams {object} 	- these parameters will be added to the request and will be passed to the server.
		 *	 pageMode {integer} 	- one of the LIST_ or other constants. This parameter is used by PageFactory
		 *								function to select the proper constructor for the page object.
		 *	 multiRecordPage {bool} - the page may use multiple ids (records etc). Increase id counter by 10000;
		 *	 openMode {integer}		- one of the OPENMODE_... constants. Determines whether the page should be displayed in popup, in a container or any other way.
		 *	 openContainer {element}	- used with openMode==OPENMODE_CONTAINER. The HTML element the page should be put into.
		 *	 tabsSettings {object}	- an object containing the following data
		 *		tabControlName {string}	- used with openMode==OPENMODE_TABVIEW. The unique identifier of the tab view control
		 *	 	tabLabel {string}			- the label displayed in the tab.
		 *	 	activeTab {boolean}		- the flag indicating if a tab should be active.
		 *	 	tabIndex {number}			- the tab index within the tabs control
		 *	 	tabId {string}				- the unique identifier of the tab within the single tab control
		 *	 popupCentered {boolean}	- create popup centered or not
		 *	 modal {boolean}			- create modal popup
		 *
		 *	 afterCreateHn	{function}	- the function to be run after the page created but not initialized - before the page.init call.
		 *	 afterInitHn	{function}	- the function to be run after the page created and initialized - right before the after afterPageReady event.
		 *			All the handlers are called with the context of newly created Page object.
		 *		 
		 */
		 openPage: function( pageParams ) {
			var pageManager = this, 
				ajaxRequestUrl = Runner.pages.getUrl( pageParams.tName, pageParams.pageType ),
				reqParams, i;
				
			pageParams.pageId = Runner.genId();
			if ( pageParams.multiRecordPage ) {
				Runner.setIdCounter( pageParams.pageId + 10000 );
			}
		//	TODO! Delete this line:
			pageParams.openMode = pageParams.openMode || Runner.pages.constants.OPENMODE_POPUP;
			
			//	prepare request parameters
			reqParams = {
				id: pageParams.pageId,
				onFly: 1,
				isNeedSettings: true
			};
			
			if ( pageParams.keys ) {
				for (i = 0; i < pageParams.keys.length; i++) {
					reqParams[ (pageParams.keyPref || "editid") + (i + 1) ] = pageParams.keys[ i ];
				}
			}
			
			reqParams = Runner.apply( reqParams, pageParams.baseParams );		
			
			// load layout CSS beforehand to avoid page blinking
			this.loadPageLayoutCss( pageParams.tName, pageParams.pageType );
			
			// make the request
			Runner.runnerAJAX( ajaxRequestUrl, reqParams, function( ctrlsJSON ) {
			// add loaded settings to global storage
				Runner.pages.PageSettings.addSettings('', ctrlsJSON.settings);
			// load additional css files
				Runner.util.ScriptLoader.loadCSS( ctrlsJSON.CSSFiles );
				Runner.util.ScriptLoader.loadCSS( ctrlsJSON.additionalCSS );

			// load additional JS files
				if ( ctrlsJSON.additionalJS ) {
					$.each(ctrlsJSON.additionalJS, function( jsFile, jsFileReq ) {
						Runner.util.ScriptLoader.addJS( [jsFile], jsFileReq );
					});
				}
				
				Runner.util.ScriptLoader.onFilesLoaded( function() {
					// add map
					Runner.pages.PageControlsMap.addMap( pageParams.tName, pageParams.pageType, pageParams.pageId, ctrlsJSON.controlsMap );
					Runner.pages.PageViewControlsMap.addMap( pageParams.tName, pageParams.pageType, pageParams.pageId, ctrlsJSON.viewControlsMap );
					
					// callback analyze request data and call initPage of this class with cfg as param
					var cfg = {
						submitUrl: ajaxRequestUrl,						
						editType: pageParams.editType || pageParams.baseParams.editType,
						controlsMap: ctrlsJSON.controlsMap[ pageParams.tName ][ pageParams.pageType ][ pageParams.pageId ], 
						viewControlsMap: ctrlsJSON.viewControlsMap[ pageParams.tName ][ pageParams.pageType ][ pageParams.pageId ],
						headerCont: ctrlsJSON.headerCont || "",
						bodyCont: pageManager.wrapPageBody( ctrlsJSON.html, pageParams.tName, pageParams.pageType ),
						footerCont: ctrlsJSON.footerCont || ""
					};
					Runner.apply( cfg, pageParams );
					
					Runner.setIdCounter( ctrlsJSON.idStartFrom );	
					pageManager.initPage( cfg )
				
				}, pageManager );				
				
				Runner.util.ScriptLoader.load(); 
			});
			
			return pageParams.pageId;
		},
		
		/**
		 * @param {string} body
		 * @param {string} tName
		 * @param {string} pageType
		 * @return {string}
		 */
		wrapPageBody: function( body, tName, pageType ) {
			if ( !body ) {
				return '&nbsp;';
			}
			return '<div class="rnr-pagewrapper ' + Runner.pages.PageSettings.getTableData( tName, "pageSkinStyle" )[ pageType ] + '">' + body + '</div>';
		},

		/**
		 * Add add page content to the tabs controller
		 * The context is newly-created Page object		 
		 * @param {object} obj		The page's data object
		 */
		putToTab: function( obj ) {
			var $contentContainer = $("<div/>"),
				tabId = "tab" + this.tabSettings.tabControlName + "_" + this.tabSettings.tabId;
				
			obj = obj || this;
			
			if ( !this.tabControl || !this.tabControl.length ) {
				this.tabControl = Runner.pages.PageManager.createTabsControl( this.openContainer, this.tabSettings.tabControlName );
			}
			
			Runner.pages.PageManager.putToDashContainer.call( this, obj, $contentContainer );	
			Runner.pages.PageManager.setTabWithinTabsControl( this.tabControl, $contentContainer, tabId, this.tabSettings.tabLabel, this.tabSettings.activeTab, this.tabSettings.tabIndex, this.tabSettings.hideTabsContent );
		},
		
		/**
		 * Initialize jQuery UI tabs controller within the $container elem passed
		 * @param {jQuery object} $container
		 * @param {string} name
		 */
		createTabsControl: function( $container, name ) {
			var $tabsControl = $("#tabs-" + name, $container);
			
			if ( $tabsControl.length && $tabsControl.data('ui-tabs') ) {
				return $tabsControl;
			}
			
			return $('<div id="tabs-' + name + '"><ul></ul></div>')
				.appendTo( $container )
				.tabs();
		},
		
		/**
		 * Get a dash element tabs control by elements name
		 * @param {string} dashElementName
		 * @param {string} dashId
		 * @return {jQuery UI object}
		 */
		getDashElementTabControl: function( dashElementName, dashId ) {
			return $( "#tabs-" + dashElementName, $('#dashelement_' + dashElementName + dashId).get(0) );
		},
		
		/**
		 * Add a new tab to the jQuery UI tabs controller ($tabsControl)
		 * or reload the content of existing one
		 * @param {jQuery object} $tabControl
		 * @param {jQuery object} $tabContents
		 * @param {string} tabElementId
		 * @param {string} tabLabel
		 * @param {boolean} activeTab		 
		 * @param {number} rnrTabIndex
		 * @param {boolean} hideTabsContent
		 */
		setTabWithinTabsControl: function( $tabsControl, $tabContents, tabElementId, tabLabel, activeTab, rnrTabIndex, hideTabsContent ) {
			if ( !$tabsControl.length || !$tabsControl.data('ui-tabs') ) {
				return;
			}
			
			var $tab = $("#" + tabElementId, $tabsControl);
				
			if ( $tab.length ) {
				$tab.html( '' ).append( $tabContents );
				return;
			}
			
			this.addTabToTabsControl( $tabsControl, $tabContents, tabElementId, tabLabel, activeTab, rnrTabIndex, hideTabsContent );
		},
		
		/**
		 * Add a new tab to the jQuery UI tabs controller ($tabsControl)
		 * @param {jQuery object} $tabControl
		 * @param {jQuery object} $tabContents
		 * @param {string} tabElementId
		 * @param {string} tabLabel
		 * @param {boolean} activeTab
		 * @param {number} rnrTabIndex		 
		 * @param {boolean} hideTabsContent		 
		 */
		addTabToTabsControl: function( $tabsControl, $tabContents, tabElementId, tabLabel, activeTab, rnrTabIdx, hideTabsContent ) {
			if ( !$tabsControl.length || !$tabsControl.data('ui-tabs') ) {
				return;
			}
			
			var dataAttr = '',
				added = false, 
				newTabIndex = 0,
				$navigation = $tabsControl.find('.ui-tabs-nav');
				
			if ( typeof rnrTabIdx === 'number' ) {
				dataAttr = 'data-rnrtabidx="' + rnrTabIdx + '"';
				
				$('li', $navigation).each( function( idx, li ) {
					var $li = $(li),
						rnrCurrentTabIdx = $li.data('rnrtabidx'),
						$corrTab;
					
					if ( rnrCurrentTabIdx === undefined || rnrCurrentTabIdx > rnrTabIdx ) {
						$li.before('<li ' + dataAttr + '><a href="#' + tabElementId + '">' + tabLabel + '</a></li>');
						
						$corrTab = $( $li.find('a').attr('href') , $tabsControl );
						$('<div id="' + tabElementId + '"/>').append( $tabContents )
							.insertBefore( $corrTab );
						
						newTabIndex = idx;		
						added = true;
						return false;
					}
				});					
			} 
			
			if ( !added ) {
				newTabIndex = $('li', $navigation).length;
				$navigation.append( '<li ' + dataAttr + '><a href="#' + tabElementId + '">' + tabLabel + '</a></li>' );
					
				$('<div id="' + tabElementId + '"/>').append( $tabContents )
					.appendTo( $tabsControl );
			}
			
			$tabsControl.tabs('refresh');
			
			if ( activeTab ) {
				$tabsControl.tabs( 'option', 'active', newTabIndex );
			} else if ( $('li', $navigation).length === 1 ) {
				// activate the first created tab
				$tabsControl.tabs( 'option', 'active', 0 );
			}
			
			if ( hideTabsContent ) {
				$tabContents.hide();
			}
		},
		
		/**
		 * Load the popup page's basic css file
		 * @param {string} tName
		 * @param {string} pageType
		 */
		loadPageLayoutCss: function( tName, pageType ) {
			var tableBased = tName !== Runner.pages.constants.NOT_TABLE_BASED_TNAME && pageType !== Runner.pages.constants.PAGE_REGISTER,
				layoutName;
			
			if ( tableBased ) {
				layoutName = Runner.pages.PageSettings.getTableData( tName, "popupPagesLayoutNames" )[ pageType ];
			} else {
				layoutName = Runner.pages.PageSettings.getGlobalData( "popupPagesLayoutNames" )[ pageType ];
			}
			
			if ( layoutName ) {
				Runner.util.ScriptLoader.loadCSS( settings.global["webRootPath"] + "pagestyles/" + layoutName + ".css" );
			}
		},
		
		/**
		 * Create a popup window based on the YUI3 Panel object
		 * @param {object} args							 	specific yui arguments
		 * @param {boolean} pageBased	 					if fly window is based on RunnerPage or other event-capable object
		 * @param {Callback function} afterCreateHandler
		 * @param {Callback function} afterCloseHandler
		 * @intellisense
		 */
		createFlyWin: function( args, pageBased, afterCreateHandler, afterCloseHandler ) {
			var createHn,
				self = this,
				pageCont = document.createElement("DIV"),
				winAttrs = {
					srcNode: pageCont,
					zIndex: Runner.genZIndexMax(),
					visible: false,
					resize: true, // not a YUI3 param
					render: true, // set to true it establishes the initial DOM for the widget
					modal: !!Runner.tabletDevice, // It's true by default for any of table devices
					headerContent: "&nbsp;",
					bodyContent: "&nbsp;",
					footerContent: "&nbsp;"
				};
				
			if ( pageBased ) {
				this.pageCont = pageCont;	
			}
			
			if ( typeof this.addEvents === "function" ) {
				this.addEvents("windowSizeCorrected");
			}

			// merge winAttrs and args, some of winAttrs props (resize, bodyContent) could be replaced
			winAttrs = Runner.apply( winAttrs, args );
						
			// load listed YUI3 modules dinamically, invoke the callback passed when they all are loaded
			createHn = function( Y ) {
				var drag, resize, xy,
					win = new Y.Panel( winAttrs ),
					widgetBox = win.get('boundingBox').getDOMNode(),
					$pageWrapper = $( win.bodyNode.getDOMNode() ).css("overflow", "auto");
									
				if ( pageBased ) {
					self.win = win;				
				}
				
				$pageWrapper.on('scroll', function(e) {
					$("#shiny_box").hide();
					$(".rnr-datepicker").hide();
					$(".search_suggest").css('visibility', 'hidden');
					
					if ( typeof self.hideSearchControllerContainers === "function" ) {
						self.hideSearchControllerContainers();
					}
				});				
				
				//allow dragability
				drag = new Y.DD.Drag({
						node: widgetBox,
						// add drag handle only for panel header	
						handles: ['.' + win.headerNode.getAttribute("class")]
					})
					.plug( Y.Plugin.DDWinScroll )
					// add constrained to panel
					.plug( Y.Plugin.DDConstrained, {
						constrain: {'top': 0, 'left': 0}
					})					
									
				drag.on("drag:drag", function() {
					$('#shiny_box').hide();
					$(".rnr-datepicker").hide();
					$(".search_suggest").css('visibility', 'hidden');

					if ( typeof self.hideSearchControllerContainers === "function" ) {				
						self.hideSearchControllerContainers();
					}
				});
				
				if ( winAttrs.resize ) {
					// redefine the handle template
					Y.Resize.prototype.HANDLE_TEMPLATE = '<div class="' + Y.ClassNameManager.getClassName('resize', 'handle') + ' ' 
						+ Y.ClassNameManager.getClassName('resize', 'handle', '{handle}') + '">&nbsp;</div>';	
					//allow resizability
					resize = new Y.Resize({
							node: widgetBox
						})
						.plug( Y.Plugin.ResizeConstrained, {
							minWidth: 100,
							minHeight: 100,
							preserveRatio: false
						});
					
					resize.on('resize:resize', function() {
						//self could be replaced with not a PageManager instance reference
						Runner.pages.PageManager.adjustedYUIWindowBodyHeight( win );
						
						$(".rnr-datepicker").hide();
						
						if ( typeof self.hideSearchControllerContainers === "function" ) {	
							self.hideSearchControllerContainers();
						}
					});
				}	
				
				// add the YUI 'click' event handler to the Panel's "close" button that by defauld hides the Panel
				// the corresponding DOM element has the 'yui3-button-close' class
				win.getButton("close").on('click', function(e) {
					win.destroy( true );	
				});
				
				win.on('destroy', function() {
					$('#shiny_box').not("._hintBox").hide();
					
					if ( typeof self.hideSearchControllerContainers === "function" ) {
						self.hideSearchControllerContainers();
					}
					if ( afterCloseHandler ) {
						afterCloseHandler( win );
					}
				});
				
				// fire event after all yui files loaded and the fly win is created
				if ( afterCreateHandler ) {
					afterCreateHandler( win );
				} 
								
				if ( Runner.isDirRTL() ) { 
					Y.DD.DDM._pg.setStyles({ //change the Shim position
						left: 'auto',
						right: '0'
					});
				
					drag.con.get('constrain').left = $(window).width()- $(document).width();
	
					drag.on("drag:start", function() { //change the Shim position
						Y.DD.DDM._pg.setStyles({
							left: 'auto',
							right: '0'
						});
					});					
				}	
			}
			
			Runner.Y.use('panel', 'dd-constrain', 'dd-scroll', 'resize-constrain', pageBased ? this.asyncInitCall( createHn ) : createHn );
		},
		
		/**
		 * Adjust the height value of the YUI3 panel body node 
		 * (corresponding to the popup window page's content) 
		 * so it fits the panel's bounding box. 
		 * It's critical for the resizable panel.
		 * @param {YUI3 Panel object}
		 */
		adjustedYUIWindowBodyHeight: function( win ) {
			var $bodyNode = $( win.bodyNode.getDOMNode() ),
				$contentBox = $( win.get("contentBox").getDOMNode() ),
				headerHeight = $( win.headerNode.getDOMNode() ).outerHeight(),
				footerHeight = $( win.footerNode.getDOMNode() ).outerHeight(),
				extraHeight = $bodyNode.outerHeight( true ) - $bodyNode.height();
						
			$bodyNode.height( $contentBox.height() - headerHeight - footerHeight - extraHeight ) ;
		},
		
		/**
		 * correctYUIWindowSize
		 * Try to resize YUI window after CSS-loading
		 * @param {string} current page table name
		 * @param {string} current page ID
		 * @param {boolean} centered window or not
		 * @param {YUI3 Panel object} win 
		 */
		correctYUIWindowSize: function( win, centered, pageObj) {
			var self = this,
				scrollY = $(window).scrollTop(), 
				scrollX = $(window).scrollLeft(),
				winDim = Runner.getWindowDimensions(),
				halfWinWidth = Math.floor( 3 * winDim.width / 4 ), 	//three-quarter of a screen width 
				halfWinHeight = Math.floor( 4 * winDim.height / 5 ), //four-fifths of a screen height
				newWidth, fullWidth, newHeight, bodyNode, widgetBox, fullHeight;
			
			if ( pageObj ) {
				if ( pageObj.winIsAutomaticallyCorrected ) {
					pageObj.fireEvent("windowSizeCorrected");
					return;
				}
			}

			bodyNode = win.bodyNode.getDOMNode();
			widgetBox = win.get("boundingBox").getDOMNode();
			
			// correct win width size
			newWidth = win.get('width') || widgetBox.offsetWidth;
			fullWidth = widgetBox.offsetLeft + ( !centered && Runner.isDirRTL() ? -newWidth : newWidth );
			
			if ( fullWidth > winDim.width + scrollX ) {
				newWidth = newWidth - ( fullWidth - winDim.width ) + scrollX - 30;
			}
			newWidth = newWidth + 18;
			if ( newWidth < 100 ) {
				newWidth = 118;
			} else if ( newWidth > halfWinWidth ) {
				newWidth = halfWinWidth;
			}
			win.set("width", newWidth);
			if (centered) {
				win.set("x", Math.floor( ( winDim.width - newWidth ) / 2 ) + scrollX);
			}
			
			// correct win height size
			newHeight = win.get('height') || widgetBox.offsetHeight ;
			fullHeight = widgetBox.offsetTop + newHeight;
			
			if ( fullHeight > winDim.height + scrollY ) {
				newHeight = newHeight - ( fullHeight - winDim.height ) + scrollY - 30;
			}
			if ( newHeight < 100 ) {
				newHeight = 100;
			} else if ( newHeight > halfWinHeight ) {
				newHeight = halfWinHeight;
			}
			win.set("height", newHeight);
			if (centered) {
				win.set("y", Math.floor( ( winDim.height - newHeight ) / 2 ) + scrollY);
			}
			
			this.adjustedYUIWindowBodyHeight( win );
			
			win.show();
			if ( pageObj ) {
				pageObj.fireEvent("windowSizeCorrected");
			}
		},

		/**
		 * Open a 'popup' window in 'full screen' mode 	 #8912
		 * @param {object} pageCont
		 * @param {object} winContent
		 * @param {string} brickToSet		Teh name of the brick where to popup window content
		 * @param {function} afterCreateHandler
		 * @param {function} afterCloseHandler
		 */	
		createFullScreenWin: function( pageCont, winContent, brickToSet, afterCreateHandler, afterCloseHandler ) {
			var allPageBricks = Runner.bricks.Brick.prototype.getBrickObjs('', pageCont, true),
				$popupWin;
			
			// hide all page's visible bricks
			for (var i = allPageBricks.length; i--; ) {
				if ( allPageBricks[i].visible() ) {
					this.hideBrick( allPageBricks[i].name );
				}
			}
			
			if ( brickToSet ) {
				this.showBrick( brickToSet );
				this.replaceBrickContentHTMLWith( brickToSet, winContent );
				return;
			}
			
			/*afterCreateHandler();*/
			
			$popupWin = $('<div></div>').addClass("fullScreenContainer").html( winContent ).appendTo('body');
			/*window.location.hash = "";
			$( window ).on('hashchange', function() {
				$popupWin.remove();
				afterCloseHandler();
			});*/
		},
		
		/**
		 * Add a window 'onunload' event handler
		 * @param {function} hn
		 * @param {object} scope
		 * @param {object} args
		 */
		addUnloadHn: function( hn, scope, args ) {
			if ( typeof hn !== 'function' ) {
				return;
			}
			// beforeUnloadPool is a scope variable
			beforeUnloadPool.push({
				hn: hn, 
				scope: scope || window,
				args: args || []
			});
		},
		
		/**
		 * The window 'onunload' event handler
		 * unregistering the loaded pages
		 */
		callUnload: function() {
			// beforeUnloadPool and tables are scope variables
			var i, handlerData, tName;
			
			for (i = 0; i < beforeUnloadPool.length; i++) {
				handlerData = beforeUnloadPool[i];
				handlerData.hn.apply( handlerData.scope, handlerData.args );
			}
			
			for ( tName in tables ) {
				this.unregister( tName );
			}
		}
	}
}();

// Create namespace
Runner.namespace('Runner.pages');


// Assign extra Runner object's properties
(function() {
	if ( !window.settings || !window.settings.global || typeof window.settings.global !== 'object' ) {
		return;
	}
	
	Runner.debugMode = window.settings.global.debugMode;
	Runner.isMobile = window.settings.global.isMobile;
	Runner.mobileDeviceDetected = window.settings.global.mobileDeteced;


	Runner.setIdCounter( window.settings.global.idStartFrom );
	Runner.charSet = window.settings.global.charSet;	
	// Is Active Directory authentication used
	Runner.isAD = window.settings.global.isAD;
})();


Runner.pages.PageControlsMap = function() {
	window.controlsMap = window.controlsMap || {};
	
	return {	
		addMap: function(tName, pageType, pageId, map) {
			if (!tName || !pageType || typeof pageId == 'undefined') {
				return false;
			}
			if (!controlsMap[tName]) {
				controlsMap[tName] = {};
			}
			if (!controlsMap[tName][pageType]) {
				controlsMap[tName][pageType] = {};
			}
			controlsMap[tName][pageType][pageId] = map[tName][pageType][pageId];
		},
		
		getMap: function(tName, pageType, pageId) {
			if (!tName) {
				return controlsMap;
			}
			if (!pageType) {
				return controlsMap[tName];
			}
			if (typeof pageId == 'undefined') {
				return controlsMap[tName][pageType];
			}
			return controlsMap[tName][pageType][pageId];
		},
		
		removeMap: function(tName, pageType, pageId) {
			if (!tName || !pageType || typeof pageId == "undefined") {
				return false;
			}
			if (!controlsMap[tName]) {
				return false;
			}
			if (!controlsMap[tName][pageType]) {
				return false;
			}
			delete controlsMap[tName][pageType][pageId];
			return true;
		}
	};
}();

Runner.pages.PageViewControlsMap = function() {
	window.viewControlsMap = window.viewControlsMap || {};
	
	return {		
		addMap: function(tName, pageType, pageId, map) {
			if (!tName || !pageType || typeof pageId == 'undefined') {
				return false;
			}
			if (!viewControlsMap[tName]) {
				viewControlsMap[tName] = {};
			}
			if (!viewControlsMap[tName][pageType]) {
				viewControlsMap[tName][pageType] = {};
			}
			viewControlsMap[tName][pageType][pageId] = map[tName][pageType][pageId];
		},
		
		getMap: function(tName, pageType, pageId) {
			if (!tName) {
				return viewControlsMap;
			}
			if (!pageType) {
				return viewControlsMap[tName];
			}
			if (typeof pageId == 'undefined') {
				return viewControlsMap[tName][pageType];
			}
			return viewControlsMap[tName][pageType][pageId];
		},
		
		removeMap: function(tName, pageType, pageId) {
			if (!tName || !pageType || typeof pageId == "undefined") {
				return false;
			}
			if (!viewControlsMap[tName]) {
				return false;
			}
			if (!viewControlsMap[tName][pageType]) {
				return false;
			}
			delete viewControlsMap[tName][pageType][pageId];
			return true;
		}
	};
}();

/**
 * Page settings store base constructor
 * It gets page's settings from the window.settings object
 * @singletone
 */
Runner.pages.PageSettings = Runner.extend( Runner.emptyFn, {
	/**
	 * Get the page's settings	
	 * @param {string} tName	 The table's name
	 * @param {string} fName 	 The field's name
	 * @param {string} pageType	 The page's type (list, add, edit etc.)
	 */
	getSettings: function( tName, fName, pageType ) {
		if ( !tName ) {
			return settings;
		}
		
		if ( !fName ) {
			return settings.tableSettings[ tName ];
		}
		
		return settings.tableSettings[ tName ][ "fieldSettings" ][ fName ][ pageType ];
	},	
	
	/**
	 * Checks setting if they are already exists
	 * @param {string} tName
	 * @param {string} fName 
	 * @param {string} pageType
	 * @return {boolean}
	 */
	checkSettings: function( tName, fName, pageType ) {
		return !!this.getSettings( tName, fName, pageType );
	},
	
	/**
	 * 
	 */
	fieldSettingsExist: function( tName, fName, key, pageType ) {
		if ( typeof settings.tableSettings[ tName ] !== 'undefined' &&
			 typeof settings.tableSettings[ tName ][ "fieldSettings" ][ fName ] !== 'undefined' &&
			 typeof settings.tableSettings[ tName ][ "fieldSettings" ][ fName ][ pageType ] !== 'undefined' &&
			 typeof settings.tableSettings[ tName ][ "fieldSettings" ][ fName ][ pageType ][ key ] !== 'undefined' ) {
			
			return true;
		}	
		return false;
	},
	
	/**
	 * Add the page's events ("afterPageReady", "afterInit")
	 * @param {string} tName
	 * @param {string} pType
	 * @param {string} evName
	 * @param {function} evHn
	 */
	addPageEvent: function( tName, pType, evName, evHn ) {
		if ( !settings.tableSettings[ tName ] ) {
			settings.tableSettings[ tName ] = {};
		}
		if ( !settings.tableSettings[ tName ]["events"] ) {
			settings.tableSettings[ tName ]["events"] = {};
		}
		if ( !settings.tableSettings[ tName ]["events"][ pType ] ) {
			settings.tableSettings[ tName ]["events"][ pType ] = {};
		}
		if ( !settings.tableSettings[ tName ]["events"][ pType ][ evName ] ) {
			settings.tableSettings[ tName ]["events"][ pType ][ evName ] = [];
		}
		settings.tableSettings[ tName ]["events"][ pType ][ evName ].push( {hn: evHn} );
	},
	
	/**
	 * Add settings from data
	 * @param {string} tName
	 * @param {object} addSettings
	 * @param {boolean} forceRewrite
	 */
	addSettings: function( tName, addSettings, forceRewrite ) {
		if ( !addSettings ) {
			return;
		}
		
		var settings = this.getSettings();
		//Runner.setIdCounter( settings.global.idStartFrom );
		// add short table names
		Runner.apply( settings.global.shortTNames, addSettings.global.shortTNames );

		if ( forceRewrite === true ) {
			// just replace
			settings.tableSettings[ tName ] = addSettings.tableSettings[ tName ];
			return;
		}
				
		// recursively apply if settings
		if ( !tName ) {
			Runner.deepCopy( settings.tableSettings, addSettings.tableSettings );
		} else {
			settings.tableSettings[ tName ] = settings.tableSettings[ tName ] || {};
			Runner.deepCopy( settings.tableSettings[ tName ], addSettings.tableSettings[ tName ] );
		}				
	},
	
	getViewType: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "viewFormat", pageType);
	},
	
	getEditFormat: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "editFormat", pageType);
	},
	
	getShortTName: function( tName ) {
		if ( !tName ) {
			return "";
		}
		return settings.global.shortTNames[ tName ] || settings.tableSettings[ tName ].shortTName || "";
	},
	
	getValidations: function( tName, fName, pageType ) {
		if ( this.fieldSettingsExist(tName, fName, "validation", pageType) ) {
			return this.getFieldData(tName, fName, "validation", pageType);
		}
		return  Runner.pages.Defaults.getValidationSettings();	 
	},
	
	getCategoryField: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "categoryField", pageType);
	},
	
	getLookupTable: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "lookupTable", pageType);
	},
	
	getLookupSize: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "selectSize", pageType);
	},
	
	getLCT: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "lcType", pageType);
	},
	
	getShowListOfThumbnailsStatus: function( tName, fName, pageType ) {
		return this.getFieldData(tName, fName, "showListOfThumbnails", pageType);
	},
	
	getImageWidth: function( tName, fName, pageType ) {
		var nReturn = this.getFieldData(tName, fName, "imageWidth", pageType);
		return nReturn || null;
	},
	
	getImageHeight: function( tName, fName, pageType ) {
		var nReturn = this.getFieldData(tName, fName, "imageHeight", pageType);
		return nReturn || null;
	},

	/**
	 * Get the table's events data
	 * @param {string} tName
	 * @param {string} pageType
	 * @return {object}
	 */
	getTableEventsData: function( tName, pageType ) {
		var events = this.getTableData(tName, "events");
		return events[ pageType ] || {};	
	},
	
	/**
	 * Get the table's settings by the key value
	 * @param {string} tName
	 * @param {string} fName
	 * @return {mixed}
	 */
	getTableData: function( tName, key ) {
		if (typeof settings.tableSettings[ tName ] != 'undefined' && typeof settings.tableSettings[ tName ][ key ] != 'undefined') {
			return this.returnData( settings.tableSettings[ tName ][ key ] );
		}
		return this.returnData( Runner.pages.Defaults.getTableSettings( key ) );
	},
	
	/**
	 * Get the field's settings by the key value
	 * @param {string} tName
	 * @param {string} fName
	 * @param {string} key
	 * @param {string} pageType
	 * @return {mixed}
	 */
	getFieldData: function( tName, fName, key, pageType ) {
		if ( this.fieldSettingsExist(tName, fName, key, pageType) ) {
			return this.returnData( settings.tableSettings[ tName ]["fieldSettings"][ fName ][ pageType ][ key ] );
		}
		return  this.returnData( Runner.pages.Defaults.getFieldSettings( key ) );
	},
	
	/**
	 * Get the global settings by the key value
	 * @param {string} key
	 * @return {mixed}
	 */
	getGlobalData: function( key ) {
		if ( settings.global[key] != undefined ) {
			return this.returnData( settings.global[key] );
		}
		return this.returnData( Runner.pages.Defaults.getGlobalSettings( key ) );
	},
	
	/**
	 * It returns the variable itself or a corresponding 
	 * object-copy basing on the type of the variable passed
	 * @param {mixed} data
	 */
	returnData: function( data ) {
		if ( Runner.isArray( data ) ) {
			// return the array's shallow copy
			return data.slice(0);
		}
		if ( data && typeof data === "object" ) {
			// return the new empty object with all 'data' object properties 
			// accessible through the prototype chain
			var F = function() {};
			F.prototype = data;
			return new F();
		}
		return data;
	}
});

Runner.pages.PageSettings = new Runner.pages.PageSettings();
		
/**
 * @ignore
 * @param {object} baseCfg
 * @return {object}
 */
Runner.pages.PageFactory = function( baseCfg ) {
	var cfg = Runner.apply( {}, baseCfg );
	
	switch ( cfg.pageType ) {
		case Runner.pages.constants.PAGE_LIST:
			if ( cfg.pageMode === Runner.pages.constants.RIGHTS_PAGE ) {
				if ( Runner.isAD ) {
					// Active Directory
					return new Runner.pages.RightsPageAD(cfg);						
				}
				return new Runner.pages.RightsPage(cfg);						
			}
			if ( cfg.pageMode === Runner.pages.constants.MEMBERS_PAGE ) {
				return Runner.isAD ? new Runner.pages.MembersPageAD(cfg) : new Runner.pages.MembersPage(cfg);
			}
			if ( cfg.pageMode === Runner.pages.constants.LIST_DASHBOARD || cfg.pageMode === Runner.pages.constants.LIST_DASHDETAILS ) {
				return new Runner.pages.ListPageDash(cfg);
			}
			if ( cfg.pageMode === Runner.pages.constants.MODE_LIST_DETAILS ) {
				if ( Runner.isMobile ) {
					return new Runner.pages.ListPageMobileDP(cfg);
				}
				return new Runner.pages.ListPageDP(cfg);
			}
			if ( Runner.isMobile ) {
				if ( cfg.openMode === Runner.pages.constants.OPENMODE_POPUP	 ) {		
					return new Runner.pages.ListPageFly(cfg);
				}
				return new Runner.pages.ListPageMobile(cfg);
			}
			if ( cfg.openMode === Runner.pages.constants.OPENMODE_POPUP	) {				
				return new Runner.pages.ListPageFly(cfg);
			}
			if ( cfg.pageMode === Runner.pages.constants.LIST_AJAX ) {
				return new Runner.pages.ListPageAjax(cfg);	
			}
			return new Runner.pages.ListPage(cfg);			
			
		case Runner.pages.constants.PAGE_ADD:
			if ( cfg.editType === Runner.pages.constants.ADD_ONTHEFLY ) {
				return new Runner.pages.AddPageFly(cfg);
			}
			if ( cfg.pageMode === Runner.pages.constants.EDIT_DASHBOARD ) { //TODO: change the dash add page's mode constant
				return new Runner.pages.AddPageDash(cfg);
			}			
			return new Runner.pages.AddPage(cfg);	
			
		case Runner.pages.constants.PAGE_EDIT:
			if ( cfg.pageMode === Runner.pages.constants.EDIT_DASHBOARD ) {
				return new Runner.pages.EditPageDash(cfg);
			}
			return new Runner.pages.EditPage(cfg);

		case Runner.pages.constants.PAGE_LOGIN:
			return new Runner.pages.LoginPage(cfg);
		
		case Runner.pages.constants.PAGE_REMIND:
			return new Runner.pages.RemindPage(cfg);
			
		case Runner.pages.constants.PAGE_VIEW:
			return new Runner.pages.ViewPage(cfg);

		case Runner.pages.constants.PAGE_SEARCH:
			return new Runner.pages.SearchPage(cfg);
			
		case Runner.pages.constants.PAGE_REPORT:
			if ( cfg.pageMode === Runner.pages.constants.MODE_LIST_DETAILS ) {
				if ( Runner.isMobile ) {
					return new Runner.pages.ReportPageMobileDP(cfg);
				} else {
					return new Runner.pages.ReportPageDP(cfg);
				}
			}
			if ( Runner.isMobile ) {
				return new Runner.pages.ReportPageMobile(cfg);
			}
			return new Runner.pages.ReportPage(cfg);
			
		case Runner.pages.constants.PAGE_CHART:
			if ( cfg.pageMode === Runner.pages.constants.MODE_LIST_DETAILS ) {	
				if ( Runner.isMobile ) {
					return new Runner.pages.ChartPageMobileDP(cfg);
				} else {
					return new Runner.pages.ChartPageDP(cfg);
				}
			}
			if ( Runner.isMobile ) {
				return new Runner.pages.ChartPageMobile(cfg);
			}
			if ( cfg.openMode === Runner.pages.constants.OPENMODE_DASHCONTAINER ) {	
				return new Runner.pages.ChartPageDash(cfg);
			}
			return new Runner.pages.ChartPage(cfg);
			
		case Runner.pages.constants.PAGE_REGISTER:
			return new Runner.pages.RegisterPage(cfg);
		
		case Runner.pages.constants.PAGE_CHANGEPASS:
			return new Runner.pages.ChangePwdPage(cfg);
			
		case Runner.pages.constants.PAGE_EXPORT:
			return new Runner.pages.ExportPage(cfg);
			
		case Runner.pages.constants.PAGE_IMPORT:
			return new Runner.pages.ImportPage(cfg);

		case Runner.pages.constants.PAGE_PRINT:
			return new Runner.pages.PrintPage(cfg);
			
		case Runner.pages.constants.PAGE_REPORT_PRINT:
			return new Runner.pages.ReportPrintPage(cfg);
			
		case Runner.pages.constants.PAGE_DASHBOARD:
			if ( Runner.isMobile ) {
				return new Runner.pages.DashboardPageMobile(cfg);
			}
			return new Runner.pages.DashboardPage(cfg);
			
		default:
			cfg.createAsDefault = true;
			return new Runner.pages.RunnerPage(cfg);
	}	
};

/**
 * Get the generated page's url
 * @param {string} tName
 * @param {string} pageType
 * @param {array} keys
 * @param {string} keyPref
 * @return {string}
 */ 
Runner.pages.getUrl = function( tName, pageType, keys, keyPref ) {
	var tableBased = tName !== Runner.pages.constants.NOT_TABLE_BASED_TNAME && pageType !== Runner.pages.constants.PAGE_REGISTER,
		url = tableBased ? Runner.getPageUrl( Runner.pages.PageSettings.getShortTName( tName ), pageType ) : Runner.getPageUrl( pageType ),
		keyParams = [], i;
		
	keys = keys || [];
	if ( !keys.length ) {
		return url
	}
	
	keyPref = keyPref || "editid";	
	for (i = 0; i < keys.length; i++) {
		keyParams.push( keyPref + (i + 1) + "=" + encodeURIComponent( keys[i] ) )
	}

	return url + "?" + keyParams.join("&")
};

/**
 * Base abstract class for all pages
 * @abstract
 * @class Runner.pages.RunnerPage
 * @base Runner.util.Observable
 * @intellisense
 */
Runner.pages.RunnerPage = Runner.extend( Runner.util.Observable, {
	/** 
	 * Table name 
	 * @intellisense
	 */
	tName: '',
	
	/**
	 * Page Type
	 * @intellisense
	 */
	pageType: '',
		
	/**
	 * 
	 */
	modal: false,
	
	/**
	 * Page id
	 * @intellisense
	 */
	pageId: -1,
	
	controlsMap: null,
	
	viewControlsMap: null,
	
	/**
	 * Not a preloaded page's html header content
	 * @intellisense
	 */
	headerCont: "",
	
	/**
	 * Not a preloaded page's html body content 
	 * @intellisense
	 */
	bodyCont: "",
	
	/**
	 * Not a preloaded page's html footer content
	 * @intellisense
	 */
	footerCont: "",
	
	/**
	 * The 'fly' page's popup window object
	 * @type {YUI3 Panel object}
	 * @intellisense
	 */
	win: null,
	
	/**
	 * The flag showing if the popup window's
	 * position and size don't need the correction
	 * @type {boolean}
	 */
	winIsAutomaticallyCorrected: false,
	
	/**
	 * Page container DOM element
	 *
	 * For simple page - body
	 * For details - td or div
	 * For fly page - div (use it instead of winDiv)
	 * @intellisense
	 */
	pageCont: null,
	
	/**
	 * The list of bricks, which must be reloaded after ajax
	 * @intellisense
	 */
	bricksForReload: [],
	
	proxy: {},
	
	createAsDefault: false,
	
	useAsGlobal: false,
	
	shortTName: "",
	
	useLocking: false,
	
	useAudio: false,
	
	useResize: false,
	
	bricksForMobileFly: [],
	
	useButtons: false,
	
	buttonNames: [],
	
	buttonEventBefore: {},
	
	buttonEventAfter: {},
	
	validateTimer: null,
	
	pageModified: false,
	
	oldLayout: false,
	
	layoutName: "",
	
	/**
	 * The flaf indicating if there are some Tabs on the page
	 * @type {boolean}
	 */
	tabsPresented: false,
	
	/**
	 * The flag indicating if ajax search suggests should be used
	 * @type {boolean}
	 */
	useSearchSuggests: false,
	
	/**
	 * The flag indicating if to warn the user 
	 * on leaving the pages with unsaved data 
	 * @type {boolean}
	 */
	warnOnLeaving: false,
	
	/**
	 * The array of functions need to be run in order to initialize the page.
	 * Use addInitTask() to and runInitQueue() to add and run tasks.
	 * @type {array}
	 */
	initTaskQueue: null,
	
	/** 
	 * Index of the current running task from the initTaskQueue array
	 * @type {number}
	 */
	currentInitTaskIndex: -1,

	/** 
	 * The variable is used to keep track of any asynchronous calls made during the current task execution.
	 * @type {number}
	 */
	initSubtasksCreated: 0,
	initSubtasksFinished: 0,
	
	/**
	 * @type {number}
	 */
	openMode: null,
	
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.apply(this, cfg);
		Runner.pages.PageManager.register(this);
		
		this.addEvents('beforeInit', 'afterInit', 'afterClose');
		
		this.id = this.pageId;
		this.proxy = Runner.pages.PageSettings.getTableData(this.tName, "proxy");
		this.useAudio = Runner.pages.PageSettings.getTableData(this.tName, "isUseAudio");
		this.useResize = Runner.pages.PageSettings.getTableData(this.tName, "isUseResize");
		this.useLocking = Runner.pages.PageSettings.getTableData(this.tName, "locking");
		this.useButtons = Runner.pages.PageSettings.getTableData(this.tName, "isUseButtons");
		this.warnOnLeaving = Runner.pages.PageSettings.getTableData(this.tName, "warnOnLeaving");
		this.shortTName = Runner.pages.PageSettings.getShortTName(this.tName);
		
		this.oldLayout = cfg.controlsMap.oldLayout;
		this.layoutName = cfg.controlsMap.layoutName;
		this.tabsPresented = this.isUseTabs();
		// set default page container
		this.pageCont = document.body;
		
		if ( this.afterInit ) {
			this.on( {'afterInit': this.afterInit} );
		}
		
		// preapre initialization queue
		this.initTaskQueue = [];
		this.addInitTask( this.init );
		
		this.initYUI();
	},

	/**
	 * Create a new YUI instance.
	 *
	 * Configuring YUI
	 * The default path for the YUI library is the minified version of the files (e.g., event-min.js)
	 * Use propertie 'filter' for modify the default path for all modules:
	 * 	DEBUG - Selects the debug versions of the library (e.g., event-debug.js)
	 * 	RAW - Selects the non-minified version of the library (e.g., event.js)
	 * Example: filter: 'debug'
	 *
	 * A complete list of configuration options is available on: yuilibrary.com/yui/docs/api/classes/config.html
	 * @intellisense
	*/	
	initYUI: function() {
		if ( typeof Runner.Y == 'undefined' ) {
			var YUIparams = {
					base: settings.global['webRootPath'] + 'include/yui/'
				};
				
			if ( Runner.debugMode ) {
				YUIparams.filter = 'raw';
			} else	{
				YUIparams.comboBase = Runner.getPageUrl('combo') + '?';
				YUIparams.combine = true;
			}
			
			Runner.Y = YUI( YUIparams );
		}
		this.Y = Runner.Y;
		
		// set body styles to display YUI modal popups correctly
		$('body').addClass('yui3-skin-sam');
		
		// close fly window page on ESC button keydown event 
		$( document ).unbind('keydown').bind('keydown', function(e) {
			if ( e.which == 27 ) {	
				$('.yui3-button-close').click();
				return false;
			}
		});		
	},
	
	/**
	 * The page's destructor
	 */
	destructor: function() {
		// unregister page Object, clean memory
		this.destroyWin();
		
		if ( !this.win && Runner.isMobile && this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.destructorMobile();
		}
		
		this.purgeListeners();
		Runner.controls.ControlManager.unregister( this.tName, this.pageId );
	},
	
	/**
	 * The mobile page's destructor
	 */	
	destructorMobile: function() {
		this.replaceBrickHTMLWith('flypanel_mobile', '');
		
		for (var i = 0; i < this.bricksForMobileFly.length; i++) {
			if ( this.bricksForMobileFly[i].name !== 'message' ) {
				this.showBrick( this.bricksForMobileFly[i].name );
			}
		}
		
		this.hideBrick('flypanel_mobile');
	},

	/**
	 * Add a function(s) to the tail of the page initialization queue.
	 * @param {function|array} task	- the function or an array of functions to add
	 * The task will be called with this context. 
	 * Asynchronous calls within tasks should be made to this.asyncInitCall( func ) instead of just func.
	 * 
	 * Example:	 
	 * addInitTask( function() {
	 *		if (this.noAjaxNeeded) {
	 *			return;
	 *		}
	 *		$.post(page, params, this.asyncInitCall( function( response ) {
	 *			if ( response.finished ) {
	 *				return;
	 *			}
	 *			$.post(page, otherparams, this.asyncInitCall( function( response ) {
	 *			}
	 *		})
	 *	});
	 */	
	addInitTask: function( task ) {
		if ( Runner.isArray( task ) ) { 
			this.initTaskQueue = this.initTaskQueue.concat( task );
		} else {
			this.initTaskQueue.push( task );
		}
	},

	/**
	 * Add a function(s) to the head of the page initialization queue.
	 * @param {function|array} task	- the function or an array of functions to add
	 * See addInitTask
	 */
	prependInitTask: function( task ) {
		if ( Runner.isArray( task ) ) {
			this.initTaskQueue = task.concat( this.initTaskQueue );
		} else {
			this.initTaskQueue.splice(0, 0, task);
		}
	},
	
	/**
	 * Auxiliary function for the initialization routine. 
	 * See the addInitTask function.
	 * @param {function} func
 	 */
	asyncInitCall: function( func ) {
		var pageObj = this;
		
		++this.initSubtasksCreated;	
		return function() {
			if ( typeof func === "function" ) {
				func.apply( pageObj, arguments );
			}
			
			++pageObj.initSubtasksFinished;

			//	the task has been finished
			if ( pageObj.initSubtasksFinished == pageObj.initSubtasksCreated ) {
				pageObj.goInitQueue();
			}
		}
	},
	
	/**
	 * Run or continue the initialization queue. 
 	 */
	goInitQueue: function() {		
		// run tasks while there are any
		while ( ++this.currentInitTaskIndex < this.initTaskQueue.length ) {
			this.initSubtasksFinished = 0;
			this.initSubtasksCreated = 1;
			
			this.initTaskQueue[ this.currentInitTaskIndex ].call( this );
			++this.initSubtasksFinished;

			if ( this.initSubtasksFinished !== this.initSubtasksCreated ) {
				// do nothing for now. Continue with initialization when the async subtask is finished
				return;
			}
			// task finished, do the next task
		}
	},
	
	/**
	 * Initialize the page's basic functionality
	 */	
	init: function() {
		var pageObj = this;
		
		this.fireEvent('beforeInit', this);
		
		if ( Runner.isMobile && this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.initFlyMobile()		
		}
		
		this.initMenu();
		this.initEvents();
		this.initRunnerButtons();
		this.initLoginButtons();
		this.hideFieldsHiddenByUser();
		
		//	initTabs must be called before initForTabs
		this.initTabs();
		this.initForTabs();
		
		this.initSearch();
		this.initDependentElementsOnDashboard();
		
		if ( !this.useResize ) {
			this.initForGrid();
		}
		
		if ( this.warnOnLeaving && !Runner.isMobile && this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			//warn users about leaving the page with changes unsaved
			$(window).on('beforeunload', function() { 
				return pageObj.beforeUnloadHn(); 
			});
		}
	},
	
	/**
	 * init dependent elements on dashboard 
	 */
	initDependentElementsOnDashboard: function() {
		if ( this.dashboard && this.dashElementSettings ) {
			var type = this.dashElementSettings.type;
			
			if ( type == Runner.pages.constants.DASHBOARD_DETAILS ) {
				this.dashboard.setDetailLoadState( this.dashElementSettings.elementName, this.tName, this.pageType, true );
			}
			if ( type == Runner.pages.constants.DASHBOARD_RECORD || type == Runner.pages.constants.DASHBOARD_DETAILS ) {
				this.dashboard.toggleDependentElement( this.dashElementSettings );
			}
		}
	},
	
	/**
	 * Hide rows if user already hide any field
	 * Set 'hiddenByField' to true for the corresponding controls
	 */
	hideFieldsHiddenByUser: function() {
		var pageObj = this;

		$('.' + this.makeClassName('hiddenfield')).each( function( idx, elem ) { 	
			if ( pageObj.oldLayout ) { 
				pageObj.toggleParentRow( elem );
			}
	
			var fieldName = $( elem ).data('fieldname'),
				ctrl = Runner.getControl( pageObj.pageId, fieldName );
			
			if ( ctrl ) {
				ctrl.hiddenByField = true;
			}
		});	
	},

	/**
	 * Toggle parent row display setting for element 
	 * @param {DOMElement} element
	 * @intellisense
	 */
	toggleParentRow: function( element ) {
		if ( !this.oldLayout ) {
			return;
		}
		
		$(element).parents().each( function() {
			var $row = $(this);
			
			if ( $row.hasClass('runner-toprow') || $row.hasClass('runner-bottomrow') ) {
				return false;
			}
			if ( $row.hasClass('runner-row') ) {
				$row.addClass('runner-hiddenfield');
				return false;
			}
		});
	},
	
	/**
	 * Initialize the page's functionality that need initializing after tabs are loaded.
	 * If there are no tabs on the page it's invoked from the page's init method 
	 * otherwise from the initTabs method
	 * @intellisense
	 */
	initForTabs: function() {
		this.initControls();
		this.initViewControls();
		this.initLookups();
		this.initChangeCtrlEvents();
	},
	
	/**
	 * Init functionality for grid
	 * @intellisense
	 */
	initForGrid: function() {
		if ( this.createAsDefault ) {
			this.fireEvent('afterInit', this, this.proxy, this.id);
		}
	},
	
	/**
	 * The PageSettings.getSettings method's wrapper
	 * @param {string} tName
	 * @param {string} fName
	 * @intellisense
	 */
	getSettings: function( tName, fName ) {
		return Runner.pages.PageSettings.getSettings( tName, fName, this.pageType );
	},
	
	/**
	 * The PageSettings.checkSettings method's wrapper
	 * @param {string} tName
	 * @param {string} fName	 
	 * @intellisense
	 */
	checkSettings: function( tNave, fName ) {
		return Runner.pages.PageSettings.checkSettings( tName, fName, this.pageType );
	},
	
	/**
	 * Show invalid captcha message
	 * @param {boolean} - is captcha valid 
	 * @intellisense
	 */
	showCaptchaErrMessage: function( valid ) {
		var captchaErrDiv = $('#edit' + this.id + '_captcha_0').find( 'div.' + this.makeClassName('error') );
		
		if ( valid !== false ) {
			// remove captcha error
			captchaErrDiv.empty();
			return;
		}
		
		if ( captchaErrDiv.length ) {
			captchaErrDiv.empty().html( Runner.lang.constants.TEXT_INVALID_CAPTCHA_CODE );
		} else {
			$('#edit' + this.id + '_captcha_0').append('<div class="' + this.makeClassName('error') + '">' + Runner.lang.constants.TEXT_INVALID_CAPTCHA_CODE + '</div>');
		}
	},
		
	/**
	 * Reset the inline display style in order to 
	 * ':hover' display css rules will be applied 
	 * @param {jQuery object} $buttonGroup
	 */
	resetButtonGroupDisplayStyle: function( $buttonGroup ) {
		setTimeout( function() {
			$buttonGroup.css('display', '');
		}, 500);
	},
	
	/**
	 * Update runner buttons 'disabled' status
	 * @intellisense
	 */
	initRunnerButtons: function() {
		$( "." + this.makeClassName('button') ).each( function() {
			if ( $(this).attr('type') === 'disabled' ) {
				Runner.addDisabledClass(this);
			} 
		});
		
		$( "." + this.makeClassName('button-img') ).each( function() {
			if ( $(this).attr('type') === 'disabled' ) {
				Runner.addDisabledClass(this);
			}
		});		
	},
	
	/**
	 * Initialize the page's 'login' buttons
	 */
	initLoginButtons: function() {
		var $loginButton,
			pageObj = this,
			loginFormType = Runner.pages.PageSettings.getGlobalData( "loginFormType" );
							
		$loginButton = $("a[id=loginButton" + this.id + "]").on("click", function(e) {		
			if ( loginFormType === Runner.pages.constants.LOGIN_POPUP ) {
				pageObj.openLoginPage();
			} else if ( loginFormType === Runner.pages.constants.LOGIN_EMBEDED ) {
				pageObj.submitLoginForm();	
			} else if ( loginFormType === Runner.pages.constants.LOGIN_SEPARATE ) { 
				window.location.href = Runner.pages.getUrl( Runner.pages.constants.NOT_TABLE_BASED_TNAME, "login" ) + "?return=true";
			}
			return false;
		});		
		
		$('input[name="password"]', "#login_block" + this.id).on("keydown", function(e) {
			if ( e.keyCode == 13 ) {
				$loginButton.trigger("click"); 
				return false;
			}
		});
		
		$("a[id=logoutButton" + this.id + "]").on("click", function(e) {		
			window.location.href = Runner.pages.getUrl( pageObj.tName, pageObj.pageType ) + "?a=logout";
			return false;
		});

		$("a[id=loginButtonContinue" + this.id + "]").on("click", function(e) {
			pageObj.openLoginPage( '', '', false, true );
			return false;
		});		
	},
	
	/**
	 * Submit the login form's data
	 */
	submitLoginForm: function() {
		var pageObj = this,
			$loginBlock = $("#login_block" + this.id),
			ajaxParams = {
				parId: this.id,
				id: Runner.genId(),
				onFly: 2,
				btnSubmit: 'Login',
				password: $('input[name="password"]', $loginBlock).val(),
				username: $('input[name="username"]', $loginBlock).val(),
				remember_password: $('input[name="remember_password"]', $loginBlock).val()
			};

		Runner.runnerAJAX( Runner.getPageUrl("login"), ajaxParams, function( respObj ) {
			if ( respObj.redirect ) {
				window.location.href = Runner.pages.getUrl( pageObj.tName, pageObj.pageType ) + "?a=login";
			}
			if ( respObj.message ) {
				window.location.href = Runner.getPageUrl("login") + "?message=invalidlogin";
			}				
		});	
	},

	/**
	 * Open the login page in a popup window
	 * @param {string} user
	 * @param {string} pass
	 * @param {funtion} afterCreateHn
	 * @param {boolean} notRedirect
	 * @param {object} hostPage
	 */	
	openLoginPage: function( user, pass, afterCreateHn, notRedirect, hostPage ) {
		var pageParams = {
				pageType: Runner.pages.constants.PAGE_LOGIN,
				tName: Runner.pages.constants.NOT_TABLE_BASED_TNAME,
				pageId: -1,
				modal: true,
				userval: user,
				passval: pass,
				hostPageObj: hostPage || this,
				baseParams: {
					parId: this.id,
					notRedirect: notRedirect,
					'return' : true
				}
			};
		
		if ( typeof afterCreateHn === "function" ) {
			pageParams.afterCreateHn = afterCreateHn;
		}		
		
		Runner.pages.PageManager.openPage( pageParams );
	},	
		
	/**
	 * Initialize the page's tooltips
	 * @param {object} toolTips
	 * @param {string} tName
	 */
	initToolTips: function( toolTips, tName ) {
		var div, ctrls, i;
		
		tName = tName || this.tName;
		
		if ( !Runner.pages.PageSettings.getTableData(this.tName, "isUseToolTips") ) {
			return;
		}
		
		if ( !$('#shiny_box').length ) {
			div = $('<div id="shiny_box"></div>').css('display', 'none').addClass('shiny_box').addClass('_hintBox').appendTo( document.body );
			$('<div></div>').addClass('shiny_box_body').addClass( this.makeClassName('panel') ).addClass( this.makeClassName('list') ).appendTo( div );
		}
		
		toolTips = toolTips || this.controlsMap.toolTips || [];
		
		ctrls = Runner.controls.ControlManager.getAt(tName);
		for (i = 0; i < ctrls.length; i++) {
			if ( ctrls[i] && typeof toolTips[ ctrls[i].fieldName ] === 'string' ) {
				ctrls[i].initToolTip( toolTips[ ctrls[i].fieldName ], this );
			}
		}
	},
	
	/**
	 * Initialize the page's menu blocks
	 */
	initMenu: function() {
		// init horizontal menu
		if ($(".runner-hmenu").length && !$(".runner-hmenu:first").prop("initialized")) {
			Runner.menu.Horizontal.prototype.init();
		}
		// init simple vertical menu
		if ($(".runner-vmenu.simple").length && !$(".runner-vmenu.simple:first").prop("initialized")) {
			Runner.menu.SimpleVmenu.prototype.init();
		}
		// init tree-like vertical menu
		if ($(".runner-vmenu.tree").length && !$(".runner-vmenu.tree:first").prop("initialized")) {
			Runner.menu.TreeLikeVmenu.prototype.init();
		}
		// init quick jump menu
		if ($(".runner-quickjump").length && !$(".runner-quickjump:first").prop("initialized")) {
			Runner.menu.QuickJump.prototype.init();
		}
	
	
		//the new horizontal menu's initialization
		$('div:first-child.rnr-b-hmenu:not(.initialized)').each( function( index, elem ) {
			var $firstChild = $(elem),
				//there are no criteria to get the menu's container element
				//so It's obtained from its first child element
				$menuContainer = $firstChild.parent(),
				horizontalMenu = new Runner.menu.HorizontalNew();
			
			horizontalMenu.init( $menuContainer );
			$firstChild.addClass('initialized');
		}); 
		
		// the new simple vertical menu's initialization
		$(".rnr-b-vmenu.simple:not(.initialized)").each( function( index, elem ) {
			var $menuElem = $(elem),
				simpleVertivalMenu = new Runner.menu.SimpleVmenuNew();
			
			simpleVertivalMenu.init( $menuElem );
			$menuElem.addClass('initialized');
		});
		
		// Safari + IOS fix #9045
		if ( $(".rnr-b-vmenu.simple.initialized").length || $('div:first-child.rnr-b-hmenu.initialized').length ) {
			$('body').on('click', function(e) {
				if ( $(e.target).closest('.touchHover').length == 0 ) {
					$('.touchHover').removeClass('touchHover');
				}
			});
		}
		
		//the new tree-like vertical menu's initialization
		$(".rnr-b-vmenu.tree:not(.initialized)").each( function( index, elem ) {
			var $menuElem = $(elem),
				treeLikeMenu = new Runner.menu.TreeLikeVmenuNew();
			
			treeLikeMenu.init( $menuElem );
			$menuElem.addClass('initialized');
		});
		
		// the new quick jump menu initialization
		if ( $(".rnr-quickjump").length && !$(".rnr-quickjump:first").prop("initialized") ) {
			Runner.menu.QuickJumpNew.prototype.init();
		}
	},
	
	/**
	 * 
	 */
	destroyVideo: function() {
		if ( typeof projekktor === "undefined" ) {
			return;
		}		
		
		var hasMasterList = Runner.pages.PageSettings.getTableData(this.tName, "hasMasterList"),
			pageObj = this;
			
		$('.projekktor', this.pageCont).each( function() {
			if ( !hasMasterList || !$(this).parents( '.'+ pageObj.makeClassName('c-master') ).length ) {
				projekktor( this.id ).setStop().selfDestruct();
			}
		});
	},
		
	/**
	 * Load extra files
	 */
	loadFiles: function() {	
		var yuiFiles = [];
		
		if ( Runner.pages.PageSettings.getTableData(this.tName, "isUseCK") ) {
			Runner.util.ScriptLoader.addJS( [settings.global["webRootPath"] + 'plugins/ckeditor/ckeditor.js' ] );
		}
				
		if ( Runner.pages.PageSettings.getTableData(this.tName, "isUseResize") ) {
			Runner.util.ScriptLoader.addJS( [ settings.global["webRootPath"] + 'include/runnerJS/RunnerResizeGrid.js' ] );
		}
		
		if (Runner.pages.PageSettings.getTableData(this.tName, "isUseGoogleMap")) {
			Runner.util.ScriptLoader.addJS( [ settings.global["webRootPath"] + 'include/runnerJS/gmap.js' ] );
		}
		
		if ( Runner.pages.PageSettings.getTableData(this.tName, "isUseToolTips") ) {
			Runner.util.ScriptLoader.addJS( [ settings.global["webRootPath"] + "include/jquery.inputhintbox.js" ] );
		}
		
		var fSett = Runner.pages.PageSettings.getTableData(this.tName, "fieldSettings"),
			fName;
			
		for (fName in fSett) {
			if ( fSett[fName].timePick ) {
				Runner.util.ScriptLoader.addJS( [settings.global["webRootPath"] + "include/timepickr_jquery.timepickr.js" ] );
			}
			
			if (Runner.debugMode && fSett[fName].editFormat == Runner.controls.constants.EDIT_FORMAT_DATE
				&& (fSett[fName].dateEditType == Runner.controls.constants.EDIT_DATE_SIMPLE_DP || fSett[fName].dateEditType == Runner.controls.constants.EDIT_DATE_DD_DP) ) {
					
				Runner.util.ScriptLoader.addJS( [ settings.global["webRootPath"] + "include/yui/calendar.js" ], "include/yui/container.js", "include/yui/event.js" );
			}
		}		
		
		Runner.util.ScriptLoader.onFilesLoaded( this.asyncInitCall() );
		Runner.util.ScriptLoader.load();
		
		//	load YUI files
		if ( this.tabsPresented ) {
			yuiFiles.push('tabview');
		}
		// TODO: move to the ListPage
		if ( this.useResize && this.pageType==Runner.pages.constants.PAGE_LIST && !Runner.isMobile ) {
			yuiFiles = yuiFiles.concat( ['cookie', 'json-parse', 'json-stringify', 'datatable-base', 'resize'] );
		}
		if ( yuiFiles.length ) {
			Runner.Y.use( yuiFiles, this.asyncInitCall() );
		}
	},

	/**
	 * Initialize a kind of 'fly' page for the mobile template's page
	 */		
	initFlyMobile: function() {
		if ( !Runner.isMobile || this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			return;
		}
	
		var bricksForMobileFly = this.getBrickObjs('', false, true),
			pageObj = this,
			i, l;
		
		for (i = 0, l = bricksForMobileFly.length; i < l; i++) {
			if ( bricksForMobileFly[i].visible() ) {
				this.bricksForMobileFly.push( bricksForMobileFly[i] );
				this.hideBrick( bricksForMobileFly[i].name );
			}
		}
		
		this.showBrick( "flypanel_mobile" );
		this.replaceBrickContentHTMLWith("flypanel_mobile", this.headerCont || '' + this.bodyCont + this.footerCont || '' );
		
		$('#closefly').bind('click', function(e) {				
			Runner.pages.PageManager.unregister( pageObj.tName, pageObj.pageId );
		});
		
	},

	/**
	 * The callback 'afterCloseHandler' function for the Runner.pages.PageManager.createFlyWin method
	 * It's invoked on YUI3 Panel object 'destroy' event
	 * @param {YUI3 Panel object} win
	 */	
	afterCloseFlyWinHandler: function( win ) {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP || !this.win ) {
			return;
		}
		
		this.destroyVideo();
		this.fireEvent('afterClose'); //?
		
		this.unregisterDetails();
		Runner.pages.PageManager.unregister( this.tName, this.pageId );
	},
	
	/**
	 * Unregister details pages
	 */
	unregisterDetails: function() {
		if ( !this.dpObjs ) {
			return;
		}
		
		var tName, detailsPageObj;
		
		for ( tName in this.dpObjs ) {
			detailsPageObj = this.dpObjs[ tName ].detailsPageObj;
			if ( detailsPageObj ) {
				Runner.pages.PageManager.unregister( detailsPageObj.tName, detailsPageObj.pageId );
			}
		}
	},
	
	/**
	 * Resize and move the popup window basing on
	 * the old popup window params.
	 * @param {object} oldWin 	YUI3 Panel object
	 * @param {boolean} adjustHeight
	 */
	resizeAndMoveWindow: function( oldWin, adjustHeight ) {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP || !this.win || !oldWin ) {
			return;
		}
		
		var extraHeight = 0,
			widget = oldWin.get("boundingBox"),
			$widgetNode = $( widget.getDOMNode() ),
			$oldBodyNode, $bodyNode, contentHeight, oldContentHeight;
		
		oldWin.syncXY();
		this.win.show();

		if ( adjustHeight ) {
			$bodyNode = $( this.win.bodyNode.getDOMNode() );
			contentHeight = $bodyNode.children("div.rnr-pagewrapper").outerHeight( true );
		
			$oldBodyNode = $( oldWin.bodyNode.getDOMNode() );
			oldContentHeight = $oldBodyNode.children("div.rnr-pagewrapper").outerHeight( true );
			
			extraHeight = contentHeight - oldContentHeight;
			extraHeight = extraHeight > 0 ? extraHeight : 0;
			extraHeight = contentHeight > $oldBodyNode.height() ? extraHeight : 0;
		}
		
		this.setWindowPositionAndSize( $widgetNode.outerWidth(), $widgetNode.outerHeight() + extraHeight, oldWin.get("xy") );
		
		this.winIsAutomaticallyCorrected = true;
	},
	
	/**
	 * Set the popup window's size and position
	 * @param {number} width
	 * @param {number} height
	 * @param {Array} xy
	 */ 
	setWindowPositionAndSize: function( width, height, xy ) {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP || !this.win ) {
			return;
		}
		this.win.set('width', width);
		this.win.set('height', height);
		this.win.set('xy', xy);	
	},
	
	/**
	 * Set the popup window height so the all its content will be dispalyed
	 * @type {string} contentDivClass
	 */
	adjustPopWindowHeightByContent: function( contentDivClass ) {
		if ( !this.win ) {
			return;
		}
		
		contentDivClass = contentDivClass || "rnr-pagewrapper";
		
		var $bodyNode = $( this.win.bodyNode.getDOMNode() ),
			$widgetNode = $( this.win.get("boundingBox").getDOMNode() ),
			defaultMaxWinHeight = Math.floor( 4 * $(window).height() / 5 ),
			maxWinHeight = $(window).height() - $widgetNode.offset().top - 20,
			widgetHeightWithoutContent = $widgetNode.height() - $bodyNode.height(),
			contentHeight = $bodyNode.children("div." + contentDivClass).outerHeight( true );

		this.win.set("height", Math.min( contentHeight + widgetHeightWithoutContent, defaultMaxWinHeight, maxWinHeight ) );
	},
	
	/**
	 * Destroy fly win panel
	 * @param {object} fly win
	 * @intellisense
	 */
	destroyWin: function( win ) {
		win = win || this.win;
		if ( !win ) {
			return;	
		}
		
		var pageObj = this;
		setTimeout( function() {
			win.destroy( true );
			pageObj.win = null;
		}, 5);	
	},
	
	/**
	 * Destroy the 'mobile' page
	 */
	destroyMobileWin: function() {
		if ( this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.destructorMobile();
		}	
	},
	
	/**
	 * Close the page
	 * @intellisense
	 */	
	close: function() {
		Runner.isMobile ? this.destroyMobileWin() : this.destroyWin();
	},
	
	/** 
	 * Dummy for function which setting flag for popup editing.
	 * This dummy overrides in EditPage.
	 */
	setRecountFlagForPopup: Runner.emptyFn, //?
	
	/**
	 * Subscribe handlers for default events (eg "afterPageReady")
	 */
	initEvents: function() {
		var tName = this.createAsDefault && this.pageType != Runner.pages.constants.PAGE_PRINT ? 'global' : this.tName,
			events = Runner.pages.PageSettings.getTableEventsData( tName, this.pageType ),
			eventHnArr, evName, i;
		
		for (evName in events) {
			eventHnArr = events[ evName ];
			for (i = 0; i < eventHnArr.length; i++) {
				this.on( evName, eventHnArr[i].hn, eventHnArr[i].scope || this );
			}
		}
	},
	
	/**
	 * Controls Class fabric with lazy initialization
	 * may be should be a function in Runner.controls.FileControl and just used here
	 * @intellisense
	 */
	initControls: function() {
		var ctrl, i;
		
		this.controlsMap.controls = this.controlsMap.controls || [];
		for (i = 0; i < this.controlsMap.controls.length; i++) {
			this.controlsMap.controls[i].table = this.tName;
			ctrl = Runner.controls.ControlFabric(this.controlsMap.controls[i], this.pageType);
		}
	},

	/**
	 * View controls Class fabric with lazy initialization
	 * @intellisense
	 */
	initViewControls: function() {
		if ( !this.viewControlsMap || typeof this.viewControlsMap !== "object" ) {
			return;
		}
		
		var i, ctrl, masterVCM;

		if ( this.viewControlsMap.controls ) {
			for (i = 0; i < this.viewControlsMap.controls.length; i++) {
				this.viewControlsMap.controls[i].table = this.tName;
				ctrl = Runner.viewControls.ViewControlFabric( this.viewControlsMap.controls[i], this.pageType, this.pageCont, this );
				ctrl.init();
			}
		}
	
		if ( Runner.pages.PageSettings.getTableData(this.tName, "hasMasterList") && this.viewControlsMap.mViewControlsMap !== undefined
				&& this.viewControlsMap.mViewControlsMap.controls !== undefined ) {		
			masterVCM = this.viewControlsMap.mViewControlsMap;
			
			for ( i = 0; i < masterVCM.controls.length; i++) {
				masterVCM.controls[i].table = this.tName;
				ctrl = Runner.viewControls.ViewControlFabric( masterVCM.controls[i], this.pageType, $('.rnr-b-mastergridfields'), this );
				ctrl.init();
			}
		}	
	},

	/**
	 * 
	 */
	initLookups: function() {
		var pageCtrls = Runner.controls.ControlManager.getAt( this.tName, this.pageId ),
			parentCtrl, i;
		
		for (i = 0; i < pageCtrls.length; i++) {
			if ( !pageCtrls[i].isLookupWizard || !pageCtrls[i].parentFieldName || pageCtrls[i].skipDependencies === true ) {
				continue;
			}

			parentCtrl = Runner.controls.ControlManager.getAt( this.tName, this.pageId, pageCtrls[i].parentFieldName );
			
			// init dependeces and preload
			pageCtrls[i].setParentCtrl( parentCtrl ); 
			if ( parentCtrl && parentCtrl.isLookupWizard ) {
				parentCtrl.addDependentCtrls( [ pageCtrls[i] ] );
			}
		}
	},
	
	/**
	 * Check if there are tabs on the page
	 * If there are no tabs controlsMap.tabs is an empty array
	 * otherwise controlsMap.tabs is an object.
	 * @return {boolean}
	 * @intellisense
	 */
	isUseTabs: function() {
		return typeof this.controlsMap.tabs === "object" && !Runner.isArray( this.controlsMap.tabs );
	},
	
	/**
	 * Initialize the Tabs and Sections
	 * @intellisense
	 */
	initTabs: function() {		
		if ( this.tabsPresented ) {
			this.tabs = {};
			
			var pageObj = this;
			
			this.Y.use('tabview', function(Y) {
				var tabs = pageObj.controlsMap.tabs,
					tabGroup, tabView;
					
				for (tabGroup in tabs) {
					tabView = new Y.TabView({
						srcNode:'#' + tabGroup + pageObj.id
					}).render();
					
					$( '.rnr-tab-navigation', tabView.get('listNode').getDOMNode() ).removeClass('rnr-tab-navigation');
					$( '.rnr-hidden-tab-panel', tabView.get('panelNode').getDOMNode() ).removeClass('rnr-hidden-tab-panel');
					
					tabView.on('selectionChange', function(e) {
						if ( e.prevVal ) {
							$( e.prevVal.get("srcNode").getDOMNode() ).closest('li').removeClass('selected')
						}
						
						if ( e.newVal ) {
							$( e.newVal.get("srcNode").getDOMNode() ).closest('li').addClass('selected');
						}
						
						if ( pageObj.mapManager ) {
							Y.later(0, null, function() {
								pageObj.mapManager.updateLittleMaps();	
							});		
						}						
					});
					
					pageObj.tabs[ tabGroup ] = tabView;
				}
				pageObj.fireEvent( "tabsInitialized" );				
			});
		}
		
		this.initSections();
	},
	
	/**
	 * Check if there are sections on the page
	 * If there are not controlsMap.sections is an empty array
	 * otherwise controlsMap.sections is an object.
	 * @return {boolean}
	 */
	checkIfSectionPresented: function() {
		return typeof this.controlsMap.sections === "object" && !Runner.isArray( this.controlsMap.sections );
	},
	
	/**
	 * Initilize the page's sections
	 */
	initSections: function() {
		if ( !this.checkIfSectionPresented() ) {
			return;
		}
		
		for ( var secId in this.controlsMap.sections ) {
			$("#" + secId + this.id + "Butt").bind("click", { secId: secId, pageObj: this }, this.toggleSection);
		}		
	},
	
	/**
	 * The sections 'click' handler that toggles the section,
	 * and change the section button's appearance	
	 * @param {jQuery Event object} e
	 */
	toggleSection: function(e) {
		if (!e) {
			return;
		}
		
		var secId = e.data.secId,
			pageObj = e.data.pageObj,
			$button = $(this),
			$section = $("#" + secId + pageObj.id ),
			toggler = $button.attr("src") === Runner.pages.constants.PLUS_GIF;
						
		$section.toggle( toggler );
		$button.attr("src", toggler ? Runner.pages.constants.MINUS_GIF : Runner.pages.constants.PLUS_GIF);
		
		if ( pageObj.mapManager ) {		
			pageObj.mapManager.updateLittleMaps();
		}
	},
	
	/**
	 * Set focus to the first visible control
	 * Used when need set focus to the first invalid visible control
	 * @param {number} pageId 				the page's id
	 * @param {object} ctrls (optional)		invalid controls
	 * @intellisense
	 */
	setFirstFocus: function( pageId, ctrls ) {
		ctrls = ctrls || Runner.controls.ControlManager.getAt( this.tName );
		if ( !ctrls || !ctrls.length ) {
			return false;
		}
		
		var indx, i, 
			that = this, 
			spanContIds = [];
		
		for ( i = 0; i < ctrls.length; i++) {
			if ( ctrls[i] && ctrls[i].isFocusAllowed() ) {
				spanContIds[i] = ctrls[i].spanContId;
			}
		}
		
		$("span[id^='edit" + (pageId || this.id) + "_']:visible").each( function() {	
			indx = $.inArray(this.id, spanContIds);
			if ( indx > -1 ) {
				ctrls[ indx ].setFocus();
				return false;
			}
		});
		
		return true;
	},
	
	/**
	 * Check if a control passed is the first page's invalid control
	 * @param {object} ctrl
	 * @return {boolean}
	 */
	isFirstInvalidControl: function( ctrl ) {
		return ctrl.spanContId === $("span[id^='edit" + ctrl.id + "_']:visible:has(div.rnr-error-text:visible):first").attr("id");
	},
	
	/**
	 * Check validation for controls
	 * @param {object} ctrls (optional)
	 * @return {object} invalid controls
	 * @intellisense
	 */	
	getInvalidControls: function( ctrls ) {
		ctrls = ctrls || Runner.controls.ControlManager.getAt( this.tName );
		if ( !ctrls || !ctrls.length ) {
			return [];
		}		
		
		var indx, i, 
			invalidCtrls = [];	
		
		for (i = 0; i < ctrls.length; i++) {
			if ( !ctrls[i].validate().result ) {
				invalidCtrls.push(ctrls[i]);
			}
		}
		return 	invalidCtrls;
	},
	
	
	/**
	 * Show field by name on current page
	 * @param {string} name of field
	 * @intellisense
	 */
	showField: function( fieldName ) {
		var ctrl = Runner.getControl( this.pageId, fieldName );
			
		$("[data-fieldname=" + fieldName + "]").toggleClass( this.makeClassName('hiddenfield'), false);
		if ( ctrl ) {
			ctrl.hiddenByField = false;
		}		
	},
		
	/**
	 * Hide field by name on current page
	 * @param {string} name of field
	 * @intellisense
	 */
	hideField: function( fieldName ) {
		var ctrl = Runner.getControl( this.pageId, fieldName );
			
		$("[data-fieldname=" + fieldName + "]").toggleClass( this.makeClassName('hiddenfield'), true);
		if ( ctrl ) {
			ctrl.hiddenByField = true;
		}		
	},
	
	/**
	 * Hide array of bricks by name on current page
	 * @param {array} names of bricks (without runner-b-)
	 * @intellisense
	 */
	hideBricks: function( arrOfNames ) {
		for (var i = arrOfNames.length; i--; ) {
			this.hideBrick( arrOfNames[i] );
		}
	},
	
	/**
	 * Hide bricks by name on current page
	 * @param {string} name of brick (without runner-b-)
	 * @intellisense
	 */
	hideBrick: function( name ) {
		var brickObjs = this.getBrickObjs( name ), i;
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].hide();
		}
	},
	
	/**
	 * Show array of bricks by name on current page
	 * @param {array} names of bricks (without runner-b-)
	 * @intellisense
	 */
	showBricks: function( arrOfNames ) {
		for (var i = arrOfNames.length; i--; ) {
			this.showBrick( arrOfNames[i] );
		}
	},
	
	/**
	 * Show bricks by name on current page
	 * @param {string} name of brick (without runner-b-)
	 * @intellisense
	 */
	showBrick: function( name ) {
		var brickObjs = this.getBrickObjs( name ), i;
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].show();
		}
	},
	
	/**
	 * Toggle the current page's bricks with a particular name
	 * @param {string} name
	 * @param {boolean} toggler
	 */
	toggleBrick: function( name, toggler ) {
		toggler ? this.showBrick( name ) : this.hideBrick( name );
	},
	
	/**
	 * Show bricks by name on current page for Mobile version
	 * @param {string} name of brick (without runner-b-)
	 * @param {string} name of container (without runner-c-)
	 * @intellisense
	 */
	showBrickMobile: function( name, contName ) {
		var brickObjs = this.getBrickObjs( name, contName ), i;
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].show();
		}
	},
	
	/**
	 * Get objects for array of bricks by name on current page
	 * @param {array} names of bricks (without runner-b-)
	 * @intellisense
	 */
	getBricksObjs: function( arrOfNames ) {
		var bricksObjs = {}, i;
		
		for (i = 0; i < arrOfNames.length; i++) {
			bricksObjs[ arrOfNames[i] ] = this.getBrickObjs( arrOfNames[i] );
		}
		return bricksObjs;
	},
	
	/**
	 * Get all brick objects by name on current page
	 * @param {string} name of brick (without runner-b-)
	 * @param {object} page container (if need another) 
	 * @param {boolean} get all bricks objs in pageCont or not 
	 *
	 * @return {array} of brick objects
	 * @intellisense
	 */
	getBrickObjs: function( name, pageCont, all ) {		
		return Runner.bricks.Brick.prototype.getBrickObjs( name || '', pageCont || this.pageCont, all );
	},
	
	/**
	 * Get first founded brick elem by name on current page
	 * @param {string} name of brick (without runner-b-)
	 * @return {mixed} jQuery object or false
	 * @intellisense
	 */
	getBrickElem: function( name ) {
		var bricksArr = this.getBrickObjs( name );
		if ( !bricksArr.length ) {
			return false;
		}
		return bricksArr[0].elem	
	},
	
	/**
	 * Get brick grid elem on current page
	 * @return {mixed} jQuery object or false
	 * @intellisense
	 */
	getBrickGridElem: function() {
		var bricksArr = this.getBrickObjs('grid'), i;
		
		for (i = 0; i < bricksArr.length; i++) {
			if ( !bricksArr[i].elem.closest('.rnr-b-masterinfo').length ) {
				return bricksArr[i].elem;
			}
		}
		return false;
	},
	
	/**
	 * Get brick contents elem by name on current page
	 * @param {string} name of brick (without runner-b-)
	 * @return {mixed} jQuery object or false
	 * @intellisense
	 */
	getBrickContentsElem: function( name ) {
		var bricksArr = this.getBrickObjs( name );
		
		if ( !bricksArr.length ) {
			return false;
		}
		return bricksArr[0].contentElem;	
	},
	
	/**
	 * Get bricks html from current page container
	 * @param {mixed} pageCont (optional)			 A string or an object page container
	 * @param {array} bricksForReload (optional)	 The names of bricks for which the method gets html
	 * @return {object} {'brick name': 'brick html'}
	 * @intellisense
	 */
	getBricksHtml: function( pageCont, bricksForReload ) {
		var bricksHtml = {},
			i, $brick;

		pageCont = pageCont || this.pageCont;
		bricksForReload = Runner.isArray( bricksForReload ) ? bricksForReload : this.bricksForReload;
	
		for (i = bricksForReload.length; i--; ) {
			$brick = $('.'+ this.makeClassName('b-' + bricksForReload[i]), pageCont);
			
			bricksHtml[ bricksForReload[i] ] = { 
				html: $brick.html(), 
				isHidden: $brick.parent('div').hasClass( this.makeClassName("hiddencontainer") ) || $brick.hasClass( this.makeClassName("hiddenbrick") )
			};
		}
		
		return bricksHtml;
	},
	
	/**
	 * Replace bricks elements 
	 * @param {object} {brick name : new brick}
	 * @intellisense
	 */
	replaceBricksWith: function( newBricks ) {
		for (var name in newBricks) {
			this.replaceBrickWith( name, newBricks[name] );
		}
	},
	
	/**
	 * Replace brick element
	 * @param {string} brick name 
	 * @param {string} new brick 
	 * @intellisense
	 */
	replaceBrickWith: function( name, newBrick ) {
		var brickObjs = this.getBrickObjs( name ), i;
		
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].replaceWith( newBrick );
		}
	},
	
	/**
	 * Replace bricks HTML
	 * @param {object} {brick name : new brick html}
	 * @param {object} object page container
	 * @intellisense
	 */
	replaceBricksHTMLWith: function( newBricksHTML, pageCont ) {
		for (var name in newBricksHTML) {
			this.replaceBrickHTMLWith( name, newBricksHTML[ name ], pageCont );
		}
	},
	
	/**
	 * Replace brick HTML
	 * @param {string} brick name 
	 * @param {string} new brick html
	 * @param {object} pageCont
	 * @intellisense
	 */
	replaceBrickHTMLWith: function( name, newHTML, pageCont ) {
		var brickObjs = this.getBrickObjs(name, pageCont), i;
		
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].replaceHTMLWith( newHTML );
		}
	},
	
	
	/**
	 * Replace bricks contents elements
	 * @param {object} {brick name : new brick content}
	 * @intellisense
	 */
	replaceBricksContentsWith: function( newBricksContents ) {
		for (var name in newBricksContents) {
			this.replaceBrickContentWith( name, newBricksContents[ name ] );
		}
	},
	
	/**
	 * Replace brick content element 
	 * @param {string} brick name 
	 * @param {string} new brick content
	 * @intellisense
	 */
	replaceBrickContentWith: function( name, newContent ) {
		var brickObjs = this.getBrickObjs( name ), i;
		
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].replaceContentWith( newContent );
		}
	},
	
	/**
	 * Replace bricks contents HTML
	 * @param {object} {brick name : new brick content html}
	 * @intellisense
	 */
	replaceBricksContentsHTMLWith: function( newContentsHTML ) {
		for (var name in newContentsHTML) {
			this.replaceBrickContentHTMLWith( name, newContentsHTML[ name ] );
		}
	},
	
	/**
	 * Replace HTML for content of brick
	 * @param {string} brick name 
	 * @param {string} new brick content html
	 * @intellisense
	 */
	replaceBrickContentHTMLWith: function( name, newHTML ) {
		var brickObjs = this.getBrickObjs( name ), i;
			
		for (i = brickObjs.length; i--; ) {
			brickObjs[i].replaceContentHTMLWith( newHTML );
		}
	},

	/**
	 * Display a message
	 * @param {string} text
	 * @param {boolean} styled 		apply message style
	 * @param {boolean} error 		apply error style
	 * @intellisense
	 */
	displayMessage: function( text, styled, error ) {
		var messageText = text;
		if ( styled ) {
			messageText = this.getMessageText(text, error);
		}
		this.replaceBrickContentHTMLWith('message', messageText);
	},

	/**
	 * Hide displayed message
	 * @intellisense
	 */
	hideMessage: function() {
		this.hideBrick( 'message' );
	},

	/**
	 * Display half of prepared message to show
	 * @param {string} text
	 * @intellisense
	 */
	displayHalfPreparedMessage: function( text ) {
		this.replaceBrickContentHTMLWith('message', this.getMessageText( text ));
	},
	
	/**
	 * Get prepared message text
	 * @param {string} text
	 * @intellisense
	 */
	getMessageText: function( text, error ) {
		return "<div class='rnr-message " + (error ? "error" : "") + "'>" + text + "</div>";
	},
	
	/**
	 * Get search controller object (Help, JavaScrit API)
	 * @return {object}
	 * @intellisense
	 */
	getSearchController: function() {
		return this.searchController;
	},
	
	/** 
	 * Initialize the Search controller functionality on the page
	 */
	initSearch: function() {
		if ( !this.controlsMap.searchPanelActivated || !this.controlsMap.search || !this.controlsMap.search.searchBlocks ) {
			return false;
		}
		
		this.useSearchSuggests = Runner.pages.PageSettings.getTableData(this.tName, "ajaxSuggest");
		
		this.searchController = new Runner.search.SearchController({
			id: this.pageId,
			tName: this.tName,
			pageType: this.pageType,
			useSuggest: this.useSearchSuggests,
			usedSrch: this.controlsMap.search.usedSrch,
			fNamesArr: this.controlsMap.search.allSearchFields,
			searchFieldsLabels: this.controlsMap.search.allSearchFieldsLabels,	
			searchTableName: this.controlsMap.search.searchTableName, 
			shortTName: this.controlsMap.search.shortSearchTableName,
			panelSearchFields: this.controlsMap.search.panelSearchFields,
			isSearchPanelInflexible: this.controlsMap.search.inflexSearchPanel,
			isSearchRequired: this.controlsMap.search.isSearchRequired,
			requiredSearchFields: this.controlsMap.search.requiredSearchFields
		});
		
		this.searchController.init( this.controlsMap.search.searchBlocks );
	},
	
	/**
	 * Hide search suggests containers
	 */
	hideSearchControllerContainers: function() {	
		if ( this.useSearchSuggests || this.searchController && this.searchController.useSuggest ) {
			DestroySuggestDiv();
		}
	},
	
	/**
	 * Add the 'changePageHn' method as a handler to the each control's 'editing' event
	 */
	initChangeCtrlEvents: function() {
		var ctrls = Runner.controls.ControlManager.getAt( this.tName, this.pageId ),
			i;
		
		if ( !ctrls ) {
			return;
		}
		
		for (i = 0; i < ctrls.length; i++) {
			ctrls[i].on('editing', this.changePageHn, {}, this);
		}
	},

	/**
	 * The handler for the controls' 'editing' custom event on the add/edit/register pages.
	 * It allows to track controls's values changes on the page.
	 * @param {object} e			It could be both an Event object and null (if the event is triggered with "fireEvent")
	 * @param {object} updContext	If the event is triggered with "fireEvent" it conains an update context
	 */
	changePageHn: function( e, updContext ) {
		if ( e && (e.type == 'keyup' || e.type == 'keypress' || e.type == 'keydown') && !Runner.isAcceptableKeyCode(e) ) {
			// skip arrows, tab keys
			return;
		}
		
		updContext = updContext || {};
		
		if ( !updContext.resetHappend ) {
			this.setPageModified( true );
		}
	},
	
	/**
	 * Check if the page is modified
	 * @return {boolean}
	 */
	isPageModified: function() {
		return this.pageModified;
	},
	
	/**
	 * Update the page modification state
	 * @param {boolean}
	 */
	setPageModified: function( state ) {
		this.pageModified = state;
	},
	
	/**
	 * Handler onbeforeunload for window object.
	 * @return {string}
	 */
	beforeUnloadHn: function() {
		if ( this.isPageModified() ) {
			return Runner.lang.constants.TEXT_QUESTION_UNSAVED_CHANGES;
		}
	},
	
	/**
	 * Get the class name
	 * @param {string} name
	 * @return {string}
	 */
	makeClassName: function( name ) {
		return ( this.oldLayout ? "runner-" : "rnr-" ) + name;
	},

	/**
	 * Reload the page.
	 * @param {object} baseParams - page parameters to be sent to the server
	 * @param {object} reloadParams
	 */
	reload: function( baseParams, reloadParams ) {
		var form, 
			pageObj = this;
		
		if ( this.openMode == Runner.pages.constants.OPENMODE_PRELOADED ) {
			form = new Runner.form.BasicForm({
				addRndVal: false,
				initImmediately: true,
				submitUrl: Runner.pages.getUrl( this.tName, this.pageType ),
				standardSubmit: true,
				baseParams: baseParams,
				method: "GET"
			});
			form.submit();
			return;
		}
		
		if ( this.containerBased() ) {
			this.preparePageForReloading( this.openContainer );
			
			baseParams = Runner.apply( this.baseParams, baseParams );			
			baseParams.id = this.id;
			
			if ( this.multiRecordPage ) {
				baseParams.recordId = Runner.genId();
				Runner.setIdCounter( this.id + 10000 );
			}
			
			Runner.runnerAJAX( Runner.pages.getUrl( this.tName, this.pageType ), baseParams, function( respObj ) {
				pageObj.pageReloadHn( respObj, reloadParams || {} );
			} );
		}
	},

	/**
	 * 
	 */
	cleanupBeforeReload: function() {
		this.destroyVideo();
	},
	
	/**
	 * A stub
	 */
	preparePageForReloading: function() {
	},
	
	/**
	 * @param {object} respObj
	 */
	pageReloadHn: function( respObj ) {
		if ( this.containerBased() ) {
			Runner.stopLoading( this.openContainer );
			if ( !respObj.success ) {
				$("#message_block" + this.id).html("Submit failed!");	
			}
			this.cleanupBeforeReload();
			
			Runner.setIdCounter( respObj.idStartFrom );
			
			respObj.bodyCont = Runner.pages.PageManager.wrapPageBody( respObj.html, this.tName, this.pageType );
			respObj.headerCont = respObj.headerCont || "";
			respObj.footerCont = respObj.footerCont || "";
			
			if ( this.openMode == Runner.pages.constants.OPENMODE_CONTAINER ) {
				Runner.pages.PageManager.putToContainer.call( this, respObj );
			} else if ( this.openMode == Runner.pages.constants.OPENMODE_DASHCONTAINER ) {
				Runner.pages.PageManager.putToDashContainer.call( this, respObj );
			} else if ( this.openMode == Runner.pages.constants.OPENMODE_TABVIEW ) {
				Runner.pages.PageManager.putToTab.call( this, respObj );
			}
			$( this.openContainer ).children(".rnr-pagewrapper").first().html( respObj.html );
			
			// set controlsMap
			this.controlsMap = respObj["controlsMap"][ this.tName ][ this.pageType ][ this.id ];
			
			if ( this.openMode === Runner.pages.constants.OPENMODE_TABVIEW ) {
				this.pageCont = $(this.openContainer);
			}
			
			//	reinit page
			this.init();
		}
	},
	
	/**
	 * Tells if the page open mode is container-based
	 * @return {boolean}
	 */
	containerBased: function() {
		return this.openMode == Runner.pages.constants.OPENMODE_CONTAINER 
			|| this.openMode == Runner.pages.constants.OPENMODE_DASHCONTAINER 
			|| this.openMode == Runner.pages.constants.OPENMODE_TABVIEW;
	},
	
	/**
	 * Set AnyChart library type
	 */
	setAnyChartLibraryType: function() {
		if ( !this.controlsMap.useFlashChartLibrary ) {
			var	svgSupported = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;
			AnyChart.renderingType = svgSupported ? anychart.RenderingType.SVG_PREFERRED : anychart.RenderingType.FLASH_PREFERRED;
		} else {
			AnyChart.renderingType = anychart.RenderingType.FLASH_PREFERRED;
		}
	},
	
	/**
	 * Initialize a detail chart
	 */
	initDPChart: function() {
		if ( !this.pageParams ) {
			return;
		}
		
		this.setAnyChartLibraryType();
		
		var xmlFile,
			chart = new AnyChart(settings.global["webRootPath"] + 'libs/swf/AnyChart.swf', settings.global["webRootPath"] + 'libs/swf/Preloader.swf'),
			chartDiv = $('div#' + this.pageParams.chartname + this.pageParams.id);

		chart.width = chartDiv.width();
		chart.height = chartDiv.height();
		chart.wMode = 'opaque';
		chart.id = 'chart_' + this.pageParams.chartname;
		
		xmlFile = Runner.getPageUrl('dchartdata') + '?chartname=' + this.pageParams.chartname + '&ctype=' + this.pageParams.ctype + '&hasFlash=' + AnyChart.platform.hasRequiredVersion + "&rndVal=" + Math.random();
		chart.setXMLFile( xmlFile );
		
		chart.write( this.pageParams.chartname + this.pageParams.id );
	}
});

/**
 * Advanced Search page class
 */
Runner.pages.SearchPage = Runner.extend( Runner.pages.RunnerPage, {
	/**
	 * The dashboard page object
	 */
	dashboard: null,
	
	/**
	 * If this: true - all dashboard search, false - element dashboard search
	 */
	isDashSearchPage: false,
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function(cfg) {
		Runner.pages.SearchPage.superclass.constructor.call(this, cfg);	
		
		this.isDashSearchPage = Runner.pages.PageSettings.getTableData(this.tName, "isDashSearchPage");
	},
	
	init: function() {
		Runner.pages.SearchPage.superclass.init.call(this);
		this.initButtons();
		
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	/**
	 * Initialize the 'Advanced search' page's buttons
	 */
	initButtons: function() {
		var pageObj = this;

		$("a#searchButton" + this.pageId).on("click", function(e) {
			if ( !Runner.isDisabledButton( this ) ) {
				pageObj.submitAdvancedSearch();
			}
			return false;			
		});
		
		$("a#resetButton" + this.pageId).on("click", function(e) {
			pageObj.searchController.clearCtrls();
			pageObj.searchController.initSearchButtonStatus();
			return false;
		});
		
		$("a#backButton" + this.pageId).on("click", function(e) {
			pageObj.searchController.returnSubmit();
			return false;
		});	
	},

	/**
	 * Ininitialize the page's search functionality
	 */	
	initSearch: function() {
		var pageType,
			tName = this.tName;
		
		if ( this.isDashSearchPage ) {
			pageType = this.dashboard.pageType;
			tName = this.dashboard.tName;
		} else if ( this.pageMode === Runner.pages.constants.SEARCH_DASHBOARD ) {
			pageType = this.pageType;
		} else {
			pageType = this.controlsMap.search.submitPageType;
		}
		
		this.searchController = new Runner.search.SearchForm({
			id: this.pageId,
			tName: tName,
			searchType: 'advanced',
			usedSrch: this.controlsMap.search.usedSrch,
			fNamesArr: this.controlsMap.search.allSearchFields,
			isSearchRequired: this.controlsMap.search.isSearchRequired,
			shortTName: Runner.pages.PageSettings.getShortTName( this.tName ),
			requiredSearchFields: this.controlsMap.search.requiredSearchFields,
			ajaxSubmit: this.pageMode === Runner.pages.constants.SEARCH_DASHBOARD && !this.isDashSearchPage,
			baseParams: this.controlsMap.search.baseParams || this.baseParams || {},
			useSuggest: Runner.pages.PageSettings.getTableData(this.tName, "ajaxSuggest"),
			pageType: pageType
		});
		
		this.searchController.init( this.controlsMap.search.searchBlocks );
	},
	
	/**
	 * Reload pages connected with the dashboard search page
	 * @param {boolean} showAllMode
	 */
	reloadDashDependantPages: function( showAllMode ) {
		if ( this.pageMode !== Runner.pages.constants.SEARCH_DASHBOARD ) {
			return;
		}
		
		var dashGridTypes = [ Runner.pages.constants.DASHBOARD_LIST, Runner.pages.constants.DASHBOARD_CHART, Runner.pages.constants.DASHBOARD_REPORT ], 
			dependentElems = this.dashboard.getDashElements( this.tName, dashGridTypes ), 
			searchParams = this.searchController.getDashSearchParams( showAllMode ), i;		
		
		if ( !dependentElems.length ) {
			// there is no 'grid-like' dependent element, try to reload all dependent 'single record' elements
			dependentElems = this.dashboard.getDashElements( this.tName, [ Runner.pages.constants.DASHBOARD_RECORD ] );
		}
		
		if ( showAllMode ) {
			this.searchController.prepareForShowAllSubmit();
		} else {
			this.searchController.prepareForSearchSubmit();
		}				
		
		for ( i = 0; i < dependentElems.length; i++ ) {
			if ( dependentElems[i].type == Runner.pages.constants.DASHBOARD_RECORD ) {
				// hide 'single' record edit, view tabs
				this.dashboard.toggleTabsSingleRecord( dependentElems[i], false );
					
				// unregister current 'single record' edit, view pages
				this.dashboard.unregisterDashPage( this.tName, Runner.pages.constants.PAGE_EDIT, dependentElems[i].elementName );
				this.dashboard.unregisterDashPage( this.tName, Runner.pages.constants.PAGE_VIEW, dependentElems[i].elementName );
				
				this.dashboard.loadSingleRecord( dependentElems[i], [ Runner.pages.constants.PAGE_EDIT, Runner.pages.constants.PAGE_VIEW ], { baseParams: searchParams }  );				
				continue;
			}
			
			//unregister the current 'grid-like' page object
			this.dashboard.unregisterDashPage( dependentElems[i].tName, this.dashboard.getElementPageType( dependentElems[i].type ), dependentElems[i].elementName );
		
			this.dashboard.loadPage( dependentElems[i], { baseParams: searchParams } );				
		}	
	},
	
	/**
	 * Submit the page's search form
	 */
	submitAdvancedSearch: function() {
		var showAllMode = this.searchController.usedSrch && !this.searchController.hasNotEmptyControl();
	
		if ( this.pageMode === Runner.pages.constants.SEARCH_DASHBOARD && !this.isDashSearchPage ) {
			this.reloadDashDependantPages( showAllMode );
			return;
		}		
	
		if ( showAllMode ) {
			this.searchController.showAllSubmit();
			return;
		}
		
		this.searchController.submitSearch();
	}	
});
Runner.pages.ViewPage = Runner.extend( Runner.pages.RunnerPage, {	
	keys: null,
	
	keyFields: null,
	
	prevKeys: null,
	
	nextKeys: null,
	
	pageType: Runner.pages.constants.PAGE_VIEW,
	
	/**
	 * The jQuery object representing the 'Next record' button
	 * @type {jQuery object}
	 */ 
	nextButton: null,
	
	/**
	 * The jQuery object representing the 'Previous record' button	
	 * @type {jQuery object}
	 */ 	
	prevButton: null,
	
	/**
	 * The jQuery object representing the 'Edit page' button	
	 * @type {jQuery object}
	 */ 	
	editPageButton: null,
	
	/**
	 * The object supplying the popup mode view page
	 * with list page's inline object data
	 */
	inlineObjectParams: null,
	
	/** 
	 *
	 */
	isShowDetails: false,
	
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.ViewPage.superclass.constructor.call(this, cfg);
		
		this.keys = cfg.keys || Runner.pages.PageSettings.getTableData(this.tName, 'keys');
		this.keyFields = cfg.keyFields || Runner.pages.PageSettings.getTableData(this.tName, 'keyFields');
		this.prevKeys = Runner.pages.PageSettings.getTableData(this.tName, 'prevKeys');
		this.nextKeys = Runner.pages.PageSettings.getTableData(this.tName, 'nextKeys');
		
		this.isShowDetails = this.openMode !== Runner.pages.constants.OPENMODE_TABVIEW && Runner.pages.PageSettings.getTableData(this.tName, "isShowDetails");
	},
	
	init: function() {
		Runner.pages.ViewPage.superclass.init.call(this);
		this.initButtons();
		
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	/**
	 * Initialize the page's functionality that need initializing after tabs are loaded.
	 * If there are no tabs on the page it's invoked from the page's init method 
	 * otherwise from the initTabs method
	 */	
	initForTabs: function() {
		Runner.pages.ViewPage.superclass.initForTabs.call( this );
		this.initMap();
		this.initDetails();
	},
	
	/**
	 * Initialize the view page's buttons
	 */
	initButtons: function() {
		var pageObj = this;
		
		$( "a#backButton" + this.id ).bind("click", function(e) {
			window.location.href = Runner.pages.getUrl( pageObj.tName, Runner.pages.constants.PAGE_LIST ) + "?a=return";
			return false;
		});
	
		$( "a#backToMenuButton" + this.id ).bind("click", function(e) {
			window.location.href = Runner.getPageUrl("menu");
			return false;
		});				
		
		$( "a#closeButton" + this.id ).bind("click", function(e) {
			pageObj.win.destroy( true );
			return false;
		});
		
		this.initNavigationButtons();
	},
	
	/**
	 * Initialize navigation (the 'prev/next' buttons) to the previous and next records.
	 * Initialize the 'Edit' buttons
	 */
	initNavigationButtons: function() {
		var pageObj = this;
		
		this.nextButton = $( "a#nextButton" + this.id ).bind("click", function(e) {
			if ( !Runner.isDisabledButton( this ) ) {
				pageObj.openPrevNextRecordPage( pageObj.nextKeys, 1 );	
			}
			return false;	
		});
		
		this.prevButton = $( "a#prevButton" + this.id ).bind("click", function(e) {
			if ( !Runner.isDisabledButton( this ) ) {
				pageObj.openPrevNextRecordPage( pageObj.prevKeys, -1 );	
			}
			return false;	
		});

		this.editPageButton = $( "a#editPageButton" + this.id ).on("click", function(e) {
			if ( !Runner.isDisabledButton( this ) ) {
				pageObj.openEditPage();
			}
			return false;
		})
		.attr("href", Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_EDIT, this.keys ));
	},
	
	/**
	 * Open the page corresponding to the next/previous record
	 * @param {Array} keys
	 * @param {Number} step
	 */
	openPrevNextRecordPage: function( keys, step ) {
		var	pageParams, i;

		if ( this.openMode === Runner.pages.constants.OPENMODE_PRELOADED ) {
			window.location.href = Runner.pages.getUrl( this.tName, this.pageType, keys );
			return;
		} 

		if ( this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			pageParams = this.getOpenPageParams( keys, this.inlineObjectParams.rowId + step );		
			this.disablePageButtons();			
			Runner.pages.PageManager.openPage( pageParams );
			return;	
		} 
		
		if ( this.openMode === Runner.pages.constants.OPENMODE_TABVIEW ) {
			if ( this.parentGrid ) {
				this.parentGrid.moveNextPrev( step > 0 );
			} else {
				pageParams = { 
					baseParams:{} 
				};
				
				for ( i = 0; i < keys.length; ++i ) {
					pageParams.baseParams[ 'editid' + (i + 1) ] = keys[i];	
				}
				
				// unregister current edit, view pages
				Runner.pages.PageManager.unregister( this.tName, this.pageId );
				this.dashboard.unregisterDashPage( this.tName, Runner.pages.constants.PAGE_EDIT, this.dashElement );
				this.dashboard.loadSingleRecord( this.dashboard.getElementByName( this.dashElement ), [ Runner.pages.constants.PAGE_EDIT, Runner.pages.constants.PAGE_VIEW ], pageParams );		
			}
		}
	},
	
	/**
	 * Open the corresponding edit page
	 */
	openEditPage: function() {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			window.location.href = Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_EDIT, this.keys );
			return;
		}

		var	pageParams = Runner.pages.EditPage.prototype.getOpenPageParams.call( this, this.keys, this.inlineObjectParams.rowId );
		
		this.disablePageButtons();
		Runner.pages.PageManager.openPage( pageParams );
	},
	
	/**
	 * Disable the 'Next record', 'Prev record' and 'Edit page' 
	 * navigation buttons
	 */
	disablePageButtons: function() {
		Runner.addDisabledClass( this.nextButton );
		Runner.addDisabledClass( this.prevButton );
		Runner.addDisabledClass( this.editPageButton );
	},
	
	/**
	 * Get an object containing params for the Runner page's openPage method
	 * @param {Array} keys
	 * @param {Number} rowId
	 * @return {Object}
	 */
	getOpenPageParams: function( keys, rowId ) {
		var pageObj = this, 
			inlineObj = this.inlineObjectParams.getInlineObject(),
			previousRowId = this.inlineObjectParams.rowId,
			params = {
				tName: this.tName, 
				pageType: Runner.pages.constants.PAGE_VIEW, 
				keys: keys,
				keyFields: this.keyFields,
				modal: true,
				baseParams: {
					parId: inlineObj.id,
					table: escape( inlineObj.tName )
				},
				inlineObjectParams: {
					getInlineObject: this.inlineObjectParams.getInlineObject,
					rowId: rowId
				},
				afterCreateHn: function() {
					this.resizeAndMoveWindow( pageObj.win );
					pageObj.win.destroy( true );
					
					if ( inlineObj.dashGridBased && inlineObj.pageObj && rowId !== previousRowId ) {
						inlineObj.pageObj.moveNextPrev( rowId > previousRowId );
					}				
				}
			}
		if( inlineObj.dashGridBased && inlineObj.pageObj ) {
			params.baseParams.dashTName = inlineObj.pageObj.dashboard.tName;
		}
		return params;
			
	},
	
	/**
	 * Init the Google maps functionality using the Runner.GmapLoader instance
	 */
	initMap: function() {
		if ( !this.controlsMap.gMaps || !this.controlsMap.gMaps.isUseGoogleMap || !Runner.globalGmapLoader ) {
			return;
		}
				
		Runner.globalGmapLoader.onLoad( function() {		
			this.mapManager = new Runner.controls.MapManager( this.controlsMap.gMaps );
			this.mapManager.init();
		}, this );	
	},
	
	/**
	 * Initialize details list page
	 */
	initDetails: function() {
		if ( !this.isShowDetails || !this.controlsMap.dpTablesParams ) {
			return;
		}
		
		var dpTablesParams = this.controlsMap.dpTablesParams,
			dtName, dParams, i;
		
		this.dpObjs = {};

		for (i = 0; i < dpTablesParams.length; i++) {
			dtName = dpTablesParams[i].tName;
			
			dParams = {
				tName: dtName,
				parId: this.id,
				masterTName:this.tName,
				id : dpTablesParams[i].id,
				pType: dpTablesParams[i].pType,
				pParam: dpTablesParams[i].pParam,
				controlsMap: this.controlsMap.dControlsMap[ dtName ],
				viewControlsMap: this.viewControlsMap.dViewControlsMap[ dtName ]
			};
			
			this.dpObjs[ dtName ] = new Runner.util.details.ViewDP( dParams );
			this.dpObjs[ dtName ].init();
		}
	}
});
/**
 * Base abstract class for all pages with editing content, add, edit etc.
 */
Runner.pages.EditorPage = Runner.extend(Runner.pages.RunnerPage, {
	
	tabs: null,
	
	form: null,
	
	submitUrl: '',
	
	baseParams: null,
	
	isShowDetails: false,
	
	/**
	 * Indicator whether an error happend during files upload 
	 * @type {boolean}	 
	 */
	upploadErrorHappened: false, 
	
	/**
	 * Count of FileFields with multiple uploads which need to be saved.
	 * Dynamic value. Do not edit manualy. 
	 */
	fileFieldsCount: 0,
	
	/**
	* The jQuery object representing the save button
	* @type {object}
	*/
	saveButton: null,

	/**
	* The Indicator showing if it's necessary 
	* to keep the locking for the locked record
	* @type {boolean}
	*/	
	keepLocking: false,
	
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.EditorPage.superclass.constructor.call(this, cfg);
		
		this.submitUrl = Runner.getPageUrl( Runner.pages.PageSettings.getShortTName(this.tName), this.pageType );
		this.submitUrl += "?submit=1&";
		if ( this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.submitUrl += "fly=1&";
		}	

		this.isShowDetails = this.checkIfShowDetails();
		
		this.setBaseParams();
		
		this.addEvents("beforeSave", "afterSave");	
	},
	
	/**
	 * @return {boolean}
	 */
	checkIfShowDetails: function() {
		return Runner.pages.PageSettings.getTableData(this.tName, "isShowDetails");
	},
	
	/**
	 * Set 'baseParams' property
	 */
	setBaseParams: function() {
		this.baseParams = this.baseParams || {};
		
		this.baseParams["id"] = this.id;
		this.baseParams["editType"] = this.baseParams["editType"] || this.editType;
		
		if ( this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.baseParams["onFly"] = 1;
		}		
	},	
	
	/**
	 * @destructor
	 */
	destructor: function() {
		Runner.pages.EditorPage.superclass.destructor.call(this);
		if ( this.form ) {
			this.form.destructor();
			this.form = null;
		}
	},
	
	init: function() {
		Runner.pages.EditorPage.superclass.init.call(this);	

		if ( this.beforeSave ) {
			this.on( {'beforeSave': this.beforeSave} );
		}
		if ( this.afterSave ) {
			this.on( {'afterSave': this.afterSave} );
		}

		this.initButtons();
	},
	
	/**
	 * Init login link on message "Your session has expired. Login to save data."
	 */
	initLoginLink: function() {
		var loginLink = $( "a[id=loginButtonContinue" + this.id + "]", this.pageCont ),
			pageObj = this;
		
		loginLink.bind("click", function(e) {
			pageObj.openLoginPage( '', '', false, true );
			return false;
		});
	},
	
	/**
	 * Initialize the page's functionality that need initializing after tabs are loaded.
	 * If there are no tabs on the page it's invoked from the page's init method 
	 * otherwise from the initTabs method
	 */
	initForTabs: function() {
		Runner.pages.EditorPage.superclass.initForTabs.call( this );
		this.initToolTips();
		
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			this.setFirstFocus();
			return;
		} 
		
		this.on('windowSizeCorrected', this.setFirstFocus);
	},
	
	/**
	 * Init the 'Save' and the popup window's 'close' buttons
	 */	 
	initButtons: function() {
		var pageObj = this;		

		$( "a#backToMenuButton" + this.id ).on("click", function(e) {
			window.location.href = Runner.getPageUrl("menu");
			return false;
		});			
		
		this.saveButton = $("a[id=saveButton" + this.id + "]").bind("click", function() {
			if ( Runner.isDisabledButton( this ) ) {
				return false;
			}
			
			var $button = $(this),
				controls, i;
			
			pageObj.disablePageButtonsWhileSaving();
			
			pageObj.fileFieldsCount = 0;
			pageObj.upploadErrorHappened = false;

			controls = Runner.controls.ControlManager.getAt(pageObj.tName, pageObj.pageId);
			for (i = 0; i < controls.length; i++) {
				if (controls[i].editFormat == Runner.controls.constants.EDIT_FORMAT_FILE && controls[i].filesToUploadCount > 0) {						
					controls[i].errorHappened = false;
					pageObj.fileFieldsCount++;
					
					controls[i].uploadForm.bind('fileuploadstopped', { ctrl: controls[i] }, function(e) {
						pageObj.fileFieldsCount--;
						$button.unbind('fileuploadstopped');
						if (e.data.ctrl.errorHappened) {
							pageObj.upploadErrorHappened = true;
							pageObj.errorHn();
						} else {
							pageObj.callSaveHn();
						}
					});
					$(".btn-primary.start", controls[i].uploadForm).click();
				} 
			}
			if (pageObj.fileFieldsCount < 1) {
				pageObj.saveHn();
			}
			return false;
		});
		 	
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP || !this.win ) {
			return;
		}
		
		// add the YUI3 Panel on destroy handler
		this.win.on("destroy", function() {
			if (pageObj.locking && !pageObj.keepLocking) {
				pageObj.locking.UnlockRecordInline(pageObj.sKeys);
			}
		});
	},
	
	/**
	 * @param {Object} row
	 */
	errorHn:function( row ) {
		if ( this.fileFieldsCount < 1 ) {
			this.enablePageButtonsAfterSaving();
		}
	},
	
	/**
	 * Call the page's data-save handler
	 */
	callSaveHn: function() {
		if ( this.fileFieldsCount < 1 && !this.upploadErrorHappened ) {
			this.saveHn();
		}
	},
	
	/**
	 * Assign the 'form' property with the new 
	 * Runner.form.BasicForm object reference.
	 */
	getForm: function() {
		this.form = new Runner.form.BasicForm({
			submitUrl: this.submitUrl,	
			standardSubmit: this.isSubmitStandard(),
			isFileUpload: true,
			method: 'POST',
			id: this.pageId,
			baseParams: this.baseParams,
			fieldControls: Runner.controls.ControlManager.getVisibleAt( this.tName, this.pageId ),
			useMultipart: true,
			submitFailed: {
				fn: function( response, formObj, fieldControls ) {
					if ( response === -1 ) { //#4511 ? 
						formObj.clearForm();
						this.showError("<< " + Runner.lang.constants.TEXT_INLINE_ERROR + " >>");
					}
					
					this.fireEvent("afterSave", {success: false, html: response}, formObj, fieldControls, this);
					
					this.enablePageButtonsAfterSaving();
				},
				scope: this
			},
			beforeSubmit: {
				fn: function( formObj ) {
					return this.fireEvent("beforeSave", formObj, formObj.fieldControls, this);
				},
				scope: this
			},
			validationFailed: {
				fn: function( formObj, fieldControls, failedControlsArr ) {
					var fNamesArr = [], i;
					
					for (i = 0; i < failedControlsArr.length; i++) {
						fNamesArr.push( failedControlsArr[i].fieldName );
					}
					
					this.openFieldTabsSections( fNamesArr );
					
					// scroll to the firt field, failed its validation, to make it visible once tab/sec is open
					failedControlsArr[0].setFocus();
					
					this.enablePageButtonsAfterSaving();
					return false;
				},
				scope: this
			}
		});
	},

	/**
	 * Check if the page's form must use the standard submit process
	 * @return Boolean
	 */
	isSubmitStandard: function() {
		return this.openMode === Runner.pages.constants.OPENMODE_PRELOADED;
	},
	
	/**
	 * The page's data-save handler
	 */
	saveHn: function() {
		this.getForm();
		this.setPageModified( false );
		this.form.submit();	
	},
	
	/**
	 * @param {Array} fNamesArr
	 */
	openFieldTabsSections: function( fNamesArr ) {
		// open sections
		if ( !Runner.isArray(this.controlsMap.sections) ) {
			var sections = this.controlsMap.sections,
				secId, i;
			for ( secId in sections ) {
				for (i = 0; i < fNamesArr.length; i++) {
					if ( $.inArray( fNamesArr[i], sections[secId] ) !== -1 ) {
						$("#" + secId).show();
						$("#" + secId + "Butt").attr("src", Runner.pages.constants.MINUS_GIF);
						break;
					}
				}
			}
		}
		if ( !Runner.isArray(this.controlsMap.tabs) ) {
			// open tabs
			var tabs = this.controlsMap.tabs,
				tabInd = 0,
				selected = false,
				tabGroup, tab, i;
			
			for ( tabGroup in tabs ) {
				tabInd = 0;
				selected = false;
				for ( tab in tabs[tabGroup] ) {
					for (i = 0; i < fNamesArr.length; i++) {
						if ( $.inArray( fNamesArr[i], tabs[tabGroup][tab] ) !== -1 ) {
							this.tabs[tabGroup].selectChild( tabInd );
							selected = true;
							break;
						}
					}
					if ( selected ) {
						break;
					}
					tabInd++;
				}
			}
		}
	},
	
	/**
	 * Show the error messages
	 * @param {string | array} txt
	 * @param {boolean} isArr
	 */
	showError: function(txt, isArr) {
		if ( !txt.length ) {
			return;
		}
		
		if ( !isArr ) {
			this.displayHalfPreparedMessage( txt );
		} else {
			this.getBrickContentsElem('message').empty();
			for (var i = 0; i < txt.length; i++) {
				this.getBrickContentsElem('message').append( this.getMessageText( txt[i] ) + ( i < txt.length - 1 ? '<br>' : '' ) );
			}
		}
		
		this.showBrick('message');
	},
	
	/**
	 * Disable some page's buttons along with the 'Save' button
	 */
	disablePageButtonsWhileSaving: function() {
		Runner.addDisabledClass( this.saveButton );
	},
	
	/**
	 * Enable some page's buttons along with the 'Save' button
	 */
	enablePageButtonsAfterSaving: function() {
		Runner.delDisabledClass( this.saveButton );
	},
	
	/**
	 *
	 */
	cleanupBeforeReload: function() {
		Runner.pages.EditorPage.superclass.cleanupBeforeReload.call( this );
		
		Runner.controls.ControlManager.unregister( this.tName, this.pageId );
		
		this.form = null;
		this.upploadErrorHappened = false;
	}
});
Runner.pages.AddPageFly = Runner.extend( Runner.pages.EditorPage, {
	
	pageType: Runner.pages.constants.PAGE_ADD,
	
	editType: Runner.pages.constants.ADD_ONTHEFLY,
	
	/**
	 * The main lookup control
	 * @type {object}
	 */
	lookupCtrl: null,
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		Runner.pages.AddPageFly.superclass.constructor.call(this, cfg);
	},	

	/**
	 * Set 'baseParams' property
	 */
	setBaseParams: function() {
		Runner.pages.AddPage.superclass.setBaseParams.call( this );

		this.baseParams['a'] = "added";		
	},
	
	init: function() {
		Runner.pages.AddPageFly.superclass.init.call( this );
		this.fireEvent("afterInit", this, this.proxy, this.id);
	}, 
	
	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		Runner.pages.AddPage.superclass.initButtons.call( this );	
		
		var pageObj = this;
		
		$("a[id='cancelButton" + this.id + "']").on("click", function(e) {
			pageObj.close();
			return false;
		});
	},
	
	/**
	 * Assign the "form" property with the new 
	 * Runner.form.BasicForm object reference.
	 * Add the form's "successSubmit" event handler	 
	 */	
	getForm: function() {
		if ( this.form ) {
			return this.form;
		}
		
		Runner.pages.AddPageFly.superclass.getForm.call( this );
		
		this.form.on("successSubmit", function( respObj, basicForm, fieldControls ) {
			var evRes = this.fireEvent("afterSave", respObj, basicForm, fieldControls, this);
			
			if ( evRes !== false ) {
				this.close();
			}
		}, this);
	}
});
Runner.pages.AddPage = Runner.extend( Runner.pages.EditorPage, {
	
	pageType: Runner.pages.constants.PAGE_ADD,

	masterSaved: false,
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		Runner.pages.AddPage.superclass.constructor.call(this, cfg);
	},

	/**
	 * Set 'baseParams' property
	 */
	setBaseParams: function() {
		Runner.pages.AddPage.superclass.setBaseParams.call( this );

		this.baseParams["a"] = "added";
		if ( this.isShowDetails ) {
			this.baseParams["editType"] = this.openMode === Runner.pages.constants.OPENMODE_POPUP ? Runner.pages.constants.ADD_MASTER_POPUP : Runner.pages.constants.ADD_MASTER;
		}			
	},
	
	/**
	 * Initialize the page
	 */
	init: function() {
		Runner.pages.AddPage.superclass.init.call( this );
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},

	/**
	 * Initialize the page's functionality that need initializing after tabs are loaded.
	 * If there are no tabs on the page it's invoked from the page's init method 
	 * otherwise from the initTabs method
	 */	
	initForTabs: function() {
		Runner.pages.AddPage.superclass.initForTabs.call( this );
		
		this.initDetails();
	},

	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		Runner.pages.AddPage.superclass.initButtons.call( this );	
		
		var pageObj = this;
		
		$( "a[id=backButton" + this.id + "], #extraBackButton" + this.id ).on("click", function(e) {
			window.location.href = Runner.getPageUrl( Runner.pages.PageSettings.getShortTName( pageObj.tName ), Runner.pages.constants.PAGE_LIST, 'a=return' );
			return false;			
		});
		
		$( "a[id=cancelButton" + this.id + "]" ).on("click", function(e) {
			pageObj.close();
			return false;
		});			
	},
	
	/**
	 *
	 * @param {String} tName
	 * @return {Boolean}
	 */
	isInlineAddContentChanged: function( tName ) {
		if ( !this.dpObjs || !this.dpObjs[ tName ] ) {
			return false;
		}
		
		var inlineObj = this.dpObjs[ tName ].detailsPageObj.inlineAdd;
		return inlineObj && inlineObj.inlineAddChangeContent;
	},
	
	/**
	 * Initialize details list page
	 */
	initDetails: function() {
		if ( !this.isShowDetails || !this.controlsMap.dpTablesParams ) {
			return;
		}
		
		var dpTablesParams = this.controlsMap.dpTablesParams,
			dtName, dParams, i;
			
		this.dpObjs = {};
		
		for (i = 0; i < dpTablesParams.length; i++) {
			dtName = dpTablesParams[i].tName;
			
			dParams = {
				tName: dtName,
				parId: this.id,							
				masterTName:this.tName,
				id : dpTablesParams[i].id,
				pType: dpTablesParams[i].pType,
				pParam: dpTablesParams[i].pParam,
				controlsMap: this.controlsMap.dControlsMap[ dtName ],
				useChildCount: this.openMode === Runner.pages.constants.OPENMODE_POPUP,
				saveFailed: {
					fn: this.onDetailsSavingFailed,
					scope: this	
				},
				detailsSaved: {
					fn: this.onDetailsSaved,
					scope: this
				}
			};
				
			this.dpObjs[ dtName ] = new Runner.util.details.AddDP( dParams );
			this.dpObjs[ dtName ].init();
		}
	},
	
	/**
	 * The 'detailsSaved' event's handler
	 * @param {object} detObj
	 * @param {array} allVals
	 * @param {array} fields
	 * @param {array} allKeys
	 * @param {array} allRowIds
	 */
	onDetailsSaved: function( detObj, allVals, fields, allKeys, allRowIds ) {
		var detailsSaved = true,
			tName, rUrl;
			
		for (tName in this.dpObjs) {
			if ( this.isInlineAddContentChanged( tName ) 
				&& this.dpObjs[tName].detailsPageObj.inlineAdd
				&& ( !this.dpObjs[tName].submitMade || !this.dpObjs[tName].submitSucceded ) ) {
				detailsSaved = false;
			} else {
				$("#_" + this.dpObjs[ tName ].id).parent().remove();
			}
		}
		
		if ( !detailsSaved ) {
			return;
		}
		
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			rUrl = Runner.pages.getUrl( this.tName, this.pageType );
			
			if ( this.afterAddId ) {
				window.location.href = rUrl + (rUrl.indexOf('?') == -1 ? "?" : "&") + 'afteradd=' + this.afterAddId;
				return;
			} 
			window.location.href = rUrl;
			return;
		} 
		
		this.close();		
	},
	
	/**
	 * The detail 'saveFailed' event's handler
	 * @param {object} detObj	 
	 * @param {object} respObj	 
	 * @param {object} formObj	 
	 */
	onDetailsSavingFailed: function( detObj, respObj, formObj ) {
		var messArr = [],
			pageObj = this,
			tName, msg, txt,
			$messageBlock;
		
		for (tName in this.dpObjs) {
			if ( this.isInlineAddContentChanged( tName ) ) {
				if ( this.dpObjs[ tName ].submitMade && !this.dpObjs[ tName ].submitSucceded ) {
					msg = Runner.lang.constants.TEXT_DETAIL_NOT_SAVED.replace('%s', tName); 
					
					txt = "<div id='_" + this.dpObjs[ tName ].id + "' class='message mes_not'><<< " + msg + " >>> <br>"
							+ "<a class='goToDetails' href='#' data-dpid='" + this.dpObjs[ tName ].id + "'>" + Runner.lang.constants.TEXT_DETAIL_GOTO + " " + tName + "</a>"
						+ "</div>";
						
					messArr.push( txt );									
				} else if ( !this.dpObjs[ tName ].submitMade ) {
					return;
				}
			}
		}
		
		//make saved master's fields readonly
		this.form.makeReadonly();
		
		$messageBlock = this.getBrickContentsElem('message');		
		if ( !$(".goToDetails", $messageBlock).length ) {
			$messageBlock.on( "click", ".goToDetails", function(e) {
				var dpId = $(this).data("dpid"),
					$detailsGridPosition = $( "#detailPreview" + dpId ).position();
				
				if ( pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
					$( pageObj.win.bodyNode.getDOMNode() ).animate( {scrollTop: $detailsGridPosition.top} );
				} else {
					$(window).scrollTop( $detailsGridPosition.top );
				}
				return false;
			});
		}

		this.showError( messArr, true );	
		Runner.delDisabledClass( this.saveButton );		
	},
	
	/**
	 * Assign the 'form' property with the new Runner.form.BasicForm object 
	 * reference. Add the form's 'beforeSubmit', 'successSubmit', 'submitFailed'
	 * events handlers basing on the page's type and settings
	 */	
	getForm: function() {
		if ( this.form ) {
			return;
		}
		
		Runner.pages.AddPage.superclass.getForm.call( this );
		
		if ( this.isShowDetails ) {		
			this.form.on( 'beforeSubmit', function( basicForm ) {
				var valRes, tName;
					
				for (tName in this.dpObjs) {
					if ( this.isInlineAddContentChanged( tName ) && !this.dpObjs[ tName ].validate() ) {
						valRes = false;
					}
				}
				
				if ( !valRes ) {
					basicForm.validate();
					this.enablePageButtonsAfterSaving();
				}
				
				return valRes;	
			}, this );
			
			this.form.on( 'successSubmit', function( respObj, basicForm, fieldControls ) {
				if ( respObj.success ) {
					this.masterSaved = true;
					this.mKeys = respObj.mKeys;
					this.afterAddId = respObj.afterAddId ? respObj.afterAddId : null;
					
					for (var tName in this.dpObjs) {
						this.dpObjs[ tName ].saveDetails( respObj.mKeys[ tName ] );
					}
				} 
			}, this );
		}
		
		this.form.on( 'successSubmit', function( respObj, basicForm, fieldControls ) {
			var evRes;
			
			if ( respObj.hideCaptcha ) {
				$('.captcha_block').remove();
			}
			
			if ( !respObj.success ) {
				this.showCaptchaErrMessage( respObj.captcha );
				
				if ( respObj.message ) {
					this.displayHalfPreparedMessage( respObj.message );
					this.showBrick('message');
				} 				
			}
			
			evRes = this.fireEvent("afterSave", respObj, basicForm, fieldControls, this);
			
			if ( evRes !== false && ( !this.isShowDetails ) ) {
				this.close();
				return;
			}
			
			this.initLoginLink();
			this.enablePageButtonsAfterSaving();
		}, this );
	},
	
	/**
	 * Check if the page's form must use the standard submit process
	 * @return Boolean
	 */
	isSubmitStandard: function() {
		return !this.isShowDetails && this.openMode !== Runner.pages.constants.OPENMODE_POPUP || Runner.isMobile;
	},
	
	/**
	 * The page's 'save data' handler
	 */
	saveHn: function() {
		if ( !this.masterSaved ) {
			Runner.pages.AddPage.superclass.saveHn.call( this );
			return;
		}
		
		if ( !this.isShowDetails ) {
			return;
		}
		
		for (var tName in this.dpObjs) {
			this.dpObjs[ tName ].saveDetails( this.mKeys[ tName ] );
		}
	}	
});

Runner.pages.EditPage = Runner.extend( Runner.pages.EditorPage, {
	
	keys: null,
	
	keyFields: null,
	
	prevKeys: null,
	
	nextKeys: null,
	
	pageType: Runner.pages.constants.PAGE_EDIT,
	
	details: null,
	
	/**
	 * The jQuery object representing the 'Previous record' button
	 * @typs {jQuery object}
	 */ 
	prevButton: {},
	
	/**
	 * The jQuery object representing the 'Next record' button
	 * @typs {jQuery object}
	 */ 
	nextButton: {},
	
	/**
	 * The jQuery object representing the 'View page' button	
	 * @type {jQuery object}
	 */ 	
	viewPageButton: null,
	
	/**
	 * The object supplying the popup mode edit page
	 * with list page's inline object data
	 */
	inlineObjectParams: null,
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		Runner.pages.EditPage.superclass.constructor.call(this, cfg);
		
		this.keys = cfg.keys || Runner.pages.PageSettings.getTableData(this.tName, 'keys');
		this.keyFields = cfg.keyFields || Runner.pages.PageSettings.getTableData(this.tName, 'keyFields');
		//	sKeys - keys of current record use for locking
		this.sKeys = Runner.pages.PageSettings.getTableData(this.tName, "sKeys", "");
		this.prevKeys = Runner.pages.PageSettings.getTableData(this.tName, 'prevKeys');
		this.nextKeys = Runner.pages.PageSettings.getTableData(this.tName, 'nextKeys');
		
		this.moveNext = this.prevKeys.length || this.nextKeys.length;
		this.shortTName = Runner.pages.PageSettings.getShortTName(this.tName);
		
		this.submitUrl += this.getKeysUrlParams();		
	},

	/**
	 * Set 'baseParams' property
	 */
	setBaseParams: function() {
		Runner.pages.EditPage.superclass.setBaseParams.call( this );

		this.baseParams["a"] = "edited";	
	},
	
	/**
	 * Initialize the page
	 */	
	init: function() {
		Runner.pages.EditPage.superclass.init.call(this);
		this.initLocking();
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},

	/**
	 * Initialize the page's functionality that need initializing after tabs are loaded.
	 * If there are no tabs on the page it's invoked from the page's init method 
	 * otherwise from the initTabs method
	 */	
	initForTabs: function() {
		Runner.pages.EditPage.superclass.initForTabs.call( this );

		this.initDetails();
	},
	
	/**
	 * Inin the edit page's buttons
	 */
	initButtons: function() {
		Runner.pages.EditPage.superclass.initButtons.call( this );
		
		var pageObj = this;
		
		$( "a#resetButton" + this.id ).on("click", function(e) {		
			Runner.controls.ControlManager.resetControlsForTable( pageObj.tName, pageObj.pageType );
			clearTimeout( pageObj.validateTimer );			
			
			pageObj.setPageModified( false );
			pageObj.enablePageButtons();	
			return false; 
		});

		$( "a#backButton" + this.id + ", #extraBackButton" + this.id ).on("click", function(e) {			
			pageObj.unlockPage( function() {
				pageObj.backButtonHref()
			});
			return false;	
		});			
		
		$( "a#closeButton" + this.id ).on("click", function(e) {			
			pageObj.hideSearchControllerContainers();
			pageObj.unlockPage( function() {
				pageObj.close();
			});
			return false;
		});

		this.initNavigationButtons();	
	},

	/**
	 * Initialize navigation (the 'prev/next' buttons) to the previous and next records.
	 * Initialize the 'View' buttons
	 */
	initNavigationButtons: function() {
		var pageObj = this;
		
		this.nextButton = $( "a#nextButton" + this.id ).on("click", function(e) {
			if ( Runner.isDisabledButton( this ) ) {	
				return false;
			}
			
			pageObj.disablePageButtons();			
			pageObj.unlockPage( function() {
				pageObj.openPrevNextRecordPage( pageObj.nextKeys, 1 );
			});
			return false;			
		});	
		
		this.prevButton = $( "a#prevButton" + this.id ).on("click", function(e) {
			if ( Runner.isDisabledButton( this ) ) {
				return false;
			}
			
			pageObj.disablePageButtons();
			pageObj.unlockPage( function() {
				pageObj.openPrevNextRecordPage( pageObj.prevKeys, -1 ); 
			});
			return false;
		});	

		this.viewPageButton	= $( "a#viewPageButton" + this.id ).on("click", function(e) {
			if ( Runner.isDisabledButton( this ) ) {	
				return false;
			}
			
			pageObj.disablePageButtons();
			pageObj.unlockPage( function() {
				pageObj.openViewPage();
			});
			return false;
		})
		.attr("href", Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_VIEW, this.keys ));		
	},
	
	/**
	 * Run the handler immediately or unlock the page's records 
	 * basing on the 'useLocking' property value. In the second case 
	 * the handler is passed as a callback to the 'UnlockRecord' method 
	 * 
	 * @param {Function} handler
	 */
	unlockPage: function( handler ) {
		if ( this.useLocking ) {
			this.locking.UnlockRecord( this.sKeys, '', handler );
			return;
		} 
		handler();
	},
	
	/**
	 * Disable the 'Next record', 'Prev record' 
	 * and 'View page' navigation buttons
	 */
	disablePageButtons: function() {
		Runner.addDisabledClass( this.nextButton );
		Runner.addDisabledClass( this.prevButton );
		Runner.addDisabledClass( this.viewPageButton );
	},
	
	/**
	 * Enable the 'Next record', 'Prev record' 
	 * and 'View page' navigation buttons
	 */	
	enablePageButtons: function() {
		Runner.delDisabledClass( this.nextButton );
		Runner.delDisabledClass( this.prevButton );
		Runner.delDisabledClass( this.viewPageButton );		
	},
	
	/**
	 * Open the corresponding view page
	 */
	openViewPage: function() {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			window.location.href = Runner.pages.getUrl( this.tName, Runner.pages.constants.PAGE_VIEW, this.keys );
			return;
		}

		var pageParams = Runner.pages.ViewPage.prototype.getOpenPageParams.call( this, this.keys, this.baseParams.rowId );
		Runner.pages.PageManager.openPage( pageParams );	
	},
	
	
	/**
	 * Open the page corresponding to the next/previous record
	 * @param {Array} keys
	 * @param {Number} step
	 */
	openPrevNextRecordPage: function( keys, step ) {
		if ( this.openMode == Runner.pages.constants.OPENMODE_PRELOADED ) {
			window.location.href = Runner.pages.getUrl( this.tName, this.pageType, keys );
			return;	
		}
		
		var pageParams = this.getOpenPageParams( keys, this.baseParams.rowId + step )			
		Runner.pages.PageManager.openPage( pageParams );
	},
	
	/**
	 * Get an object containing params for the Runner page's openPage method
	 * @param {Array} keys
	 * @param {Number} rowId
	 * @param {String} message (optional)
	 * @return {Object}
	 */	
	getOpenPageParams: function( keys, rowId, message ) {
		var inlineObj = this.inlineObjectParams.getInlineObject(),
			row = inlineObj.getRowById( rowId ),
			previousRowId = this.inlineObjectParams.rowId,
			pageObj = this,
			params = {			
				tName: inlineObj.tName,
				openMode: this.openMode,
				openContainer: this.openContainer,
				pageType: Runner.pages.constants.PAGE_EDIT, 
				keys: keys,
				keyFields: this.keyFields,
				modal: true,
				baseParams: {
					parId: inlineObj.id,
					rowId: rowId,
					table: escape( inlineObj.tName ),
					editType: Runner.pages.constants.EDIT_POPUP
				},
				inlineObjectParams: {
					getInlineObject: this.inlineObjectParams.getInlineObject,
					rowId: rowId
				},
				afterSave: {
					fn: function( respObj, formObj, fieldControls, editPageObj ) {
						if ( respObj.success && row ) {
							this.afterSubmit( row, respObj, editPageObj );
							return true;
						}
						if ( respObj.success ) {
							return true;
						}					
						if ( respObj.lockMessage ) {
							$('.rnr-locking').html( respObj.lockMessage ).css('display', 'block');
							return false;
						}
						if ( respObj.hideCaptcha ) {
							$('.captcha_block').remove();
						}
						//show invalid captcha message
						editPageObj.showCaptchaErrMessage( respObj.captcha );
						editPageObj.displayHalfPreparedMessage( respObj.message || "" );
						editPageObj.showBrick('message');
						
						editPageObj.adjustPopWindowHeightByContent();
						$( editPageObj.win.bodyNode.getDOMNode() ).animate( {scrollTop: 0} );
						return false;			
					},
					scope: inlineObj
				},
				afterCreateHn: function() {				
					if ( message ) {
						this.displayHalfPreparedMessage( message );
						this.showBrick('message');
					}
					
					this.resizeAndMoveWindow( pageObj.win, true );			
					pageObj.keepLocking = true;	
					pageObj.win.destroy( true );
					
					if ( inlineObj.dashGridBased && inlineObj.pageObj && rowId !== previousRowId ) {
						inlineObj.pageObj.moveNextPrev( rowId > previousRowId );
					}				
				}		
			};
		if( inlineObj.dashGridBased && inlineObj.pageObj ) {
			params.baseParams.dashTName = inlineObj.pageObj.dashboard.tName;
		}
		return params;
	},
	
	/**
	 * Open the corresponding list page
	 */
	backButtonHref: function() {
		window.location.href = Runner.getPageUrl(this.shortTName, Runner.pages.constants.PAGE_LIST, 'a=return');
	},
	
	/**
	 * The change page's data handler
	 */
	changePageHn: function() {
		Runner.pages.EditPage.superclass.changePageHn.apply(this, arguments);
		if ( this.isPageModified() ) {
			this.disablePageButtons( );
		}
	},
	
	/**
	 * Init the page's locking object
	 */
	initLocking: function() {
		if ( !this.useLocking ) {
			return;
		}
		var pageObj = this;

		this.locking = new Runner.Locking({
			tName: this.tName,
			pageId: this.id,
			pageType: this.pageType
		});

		this.on("afterClose", function(e) {	
			pageObj.locking.UnlockDetails();
			pageObj.locking.UnlockRecord(pageObj.sKeys, '', '');
		}, this);
		
		pageObj.locking.StartLocking( pageObj, pageObj.id,pageObj.sKeys, Runner.pages.PageSettings.getTableData(pageObj.tName, "confirmTime") );
	},
	
	/**
	 * Initialize details list page
	 */	
	initDetails: function() {
		if ( !this.isShowDetails || !this.controlsMap.dpTablesParams ) {
			return;
		}
		
		var dpTablesParams = this.controlsMap.dpTablesParams, 
			dtName, dParams, i;
		
		this.dpObjs = {};		
		
		for (i = 0; i < dpTablesParams.length; i++) {
			dtName = dpTablesParams[i].tName;
			
			dParams = {
				tName: dtName,
				childRecNum: 0,				
				parId: this.id,
				masterTName: this.tName,
				id : dpTablesParams[i].id,
				pType: dpTablesParams[i].pType,
				pParam: dpTablesParams[i].pParam,		
				controlsMap: this.controlsMap.dControlsMap[ dtName ],
				useChildCount: this.openMode === Runner.pages.constants.OPENMODE_POPUP,
				viewControlsMap: this.viewControlsMap && this.viewControlsMap.dViewControlsMap ? this.viewControlsMap.dViewControlsMap[ dtName ] : null,
				saveFailed: {
					fn: this.onDetailsSavingFailed,
					scope: this
				},
				detailsSaved: {
					fn: this.onDetailsSaved,
					scope: this
				},
				afterDeleteDetails: {
					fn: this.onDetailsDeleted,
					scope: this				
				},
				// a handler for a details row's form 'validationFailed' event
				validationFailed: $.proxy( function( formObj, fieldControls ) {
						this.enablePageButtonsAfterSaving();
					}, this )
			};
			
			this.dpObjs[ dtName ] = new Runner.util.details.EditDP( dParams );
			this.dpObjs[ dtName ].init();
		}		
	},
	
	/**
	 * Update relative dash elements if the page has one
	 */
	updateRelativeDashElements: function() {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP ) {
			this.updateRelativeDashElements = Runner.emptyFn;
			return;
		}
		
		var inlineObj = this.inlineObjectParams.getInlineObject();
		if ( inlineObj.dashGridBased && inlineObj.pageObj ) {
			inlineObj.pageObj.loadDependencies( inlineObj.getRowById( this.inlineObjectParams.rowId ) );
			return;
		}

		this.updateRelativeDashElements = Runner.emptyFn;		
	},
	
	/**
	 * The 'detailsSaved' event's handler
	 * @param {object} detObj
	 * @param {array} allVals
	 * @param {array} fields
	 * @param {array} allKeys
	 * @param {array} allRowIds
	 */
	onDetailsSaved: function( detObj, allVals, fields, allKeys, allRowIds ) {
		if ( !this.form || !Runner.isDisabledButton( this.saveButton ) ) {
			// the details submit wasn't initiated by the save button of the main record
			this.updateRelativeDashElements();
			return;
		}
		
		var detailsSaved = true,
			tName;
		
		for (tName in this.dpObjs) {
			if ( this.dpObjs[ tName ].submitMade !== undefined 
				&& ( this.dpObjs[tName].detailsPageObj.inlineAdd || this.dpObjs[tName].detailsPageObj.inlineEdit )
				&& (!this.dpObjs[ tName ].submitMade || !this.dpObjs[ tName ].submitSucceded) ) {
				detailsSaved = false;
			} else {
				$("#_" + this.dpObjs[tName].id).parent().remove();
			}
		}
		
		if ( !detailsSaved || this.formAlreadySubmitted ) {
			return;
		}
		
		this.formAlreadySubmitted = true;
		Runner.pages.EditPage.superclass.saveHn.call(this);	
	},

	/**
	 * The detail 'saveFailed' event's handler
	 * @param {object} detObj	 
	 * @param {object} respObj	 
	 * @param {object} formObj	 
	 */
	onDetailsSavingFailed: function( detObj, respObj, formObj ) {			
		var messArr = [],
			pageObj = this,
			tName, msg, txt,
			$messageBlock;			
			
		for (tName in this.dpObjs) {
			if ( this.dpObjs[ tName ].submitMade && !this.dpObjs[ tName ].submitSucceded ) {				
				msg = Runner.lang.constants.TEXT_DETAIL_NOT_SAVED.replace('%s', tName); 
				
				txt = "<div id='_" + this.dpObjs[ tName ].id + "' class='message mes_not'><<< " + msg + " >>> <br>"
						+ "<a class='goToDetails' href='#' data-dpid='" + this.dpObjs[ tName ].id + "' >" + Runner.lang.constants.TEXT_DETAIL_GOTO + " " + tName + "</a>"
					+ "</div>";
					
				messArr.push( txt );				
			} else if ( !this.dpObjs[ tName ].submitMade ) {
				return;
			}
		}

		$messageBlock = this.getBrickContentsElem('message');		
		if ( !$(".goToDetails", $messageBlock).length ) {
			$messageBlock.on( "click", ".goToDetails", function(e) {
				var dpId = $(this).data("dpid"),
					$detailsGridPosition = $( "#detailPreview" + dpId ).position();
				
				if ( pageObj.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
					$( pageObj.win.bodyNode.getDOMNode() ).animate( {scrollTop: $detailsGridPosition.top} );
				} else {
					$(window).scrollTop( $detailsGridPosition.top );
				}
				return false;
			});
		}
		
		this.showError( messArr, true );
		this.enablePageButtonsAfterSaving(); 		
	},

	/**
	 * The detail 'afterDeleteDetails' event's handler
	 */
	onDetailsDeleted: function() {
		this.updateRelativeDashElements();
	},
	
	/**
	 * Assign the 'form' property with the new Runner.form.BasicForm object 
	 * reference. Add the form's 'validationFailed', 'successSubmit' events 
	 * handlers basing on the page's type and settings
	 */
	getForm: function() {
		if ( this.form ) {
			return;
		}
		
		Runner.pages.EditPage.superclass.getForm.call( this );
		
		// the following event could be fired if the form has the falsy 'standardSubmit' property  
		this.form.on('successSubmit', function( respObj, basicForm, fieldControls ) {
			var pageParams,
				evRes = this.fireEvent("afterSave", respObj, basicForm, fieldControls, this);
			
			if ( evRes === false ) {
				// the record wasn't saved
				this.initLoginLink();
				this.enablePageButtonsAfterSaving(); 
				return;
			}
				
			if ( !this.moveNext ) {
				this.close();
				return;
			}

			// reopen the page
			pageParams = this.getOpenPageParams( respObj.keys, this.baseParams.rowId, respObj.message );
			Runner.pages.PageManager.openPage( pageParams );	
		}, this);		
	},
	
	/**
	 * The page's 'save data' handler
	 */
	saveHn: function() {
		if ( !this.isShowDetails ) {
			Runner.pages.EditPage.superclass.saveHn.call(this);
			return;
		}

		this.getForm();
		
		// validate master and if ok save details		
		if ( !this.form.validate() ) {
			return;
		}
	
		this.formAlreadySubmitted = false;

		var saveDpInlines = false,
			tName, sDp;

		for ( tName in this.dpObjs ) {
			sDp = this.dpObjs[ tName ].saveDetails();
			saveDpInlines = saveDpInlines || sDp;
		}
		
		if ( !saveDpInlines ) {
			Runner.pages.EditPage.superclass.saveHn.call(this);
		}	
	},
	
	setRecountFlagForPopup: function() {
		if ( this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.needToRecountChildAfterPopup = true;
		}
	},

	/**
	* Get the keys URL params string
	* @return {string}
	*/	
	getKeysUrlParams: function() {
		var keysString = "", i;
		
		for (i = 0; i < this.keys.length; i++) {
			this.baseParams["editid" + (i + 1)] = this.keys[i];
			keysString += "editid" + (i + 1) + "=" + this.keys[i] + '&';
		}
		return keysString;
	},
	
	/**
	 * Recalculate details in the following setup:
	 * 1. Edit page is opened in popup
	 * 2. The table has details tables on both List and Edit pages
	 * 3. Changes were made to the details list on the Edit page
	 * 4. The main edited record itself was not saved, window was simply closed instead.
	 */
	initDetailsRecalculation: function() {
		if ( this.openMode !== Runner.pages.constants.OPENMODE_POPUP || !this.baseParams.parId ) {
			return;
		}
		
		var parentPage = Runner.pages.PageManager.getById( this.baseParams.parId );
		
		if ( !parentPage ) {
			return;
		}
		// we need to recount children if popup closed by cross-button (didn't saved) and details count changed 
		this.on('afterClose', function() { 
			var tName, masterKeys;
			
			if ( !pageObj.needToRecountChildAfterPopup ) {
				return;
			}
			for (tName in parentPage.dpObjs) {
				masterKeys = parentPage.dpObjs[ tName ].getRowById( pageObj.baseParams.rowId ).masterKeys;
				parentPage.dpObjs[ tName ].updateChildRecNum( masterKeys, pageObj.baseParams.rowId );
			}
		});		
		
		if ( parentPage.pageType == Runner.pages.constants.PAGE_LIST ) {
			for (tName in parentPage.dpObjs) {
				parentPage.dpObjs[ dpObj ].closeDetails( parentPage.dpObjs[ dpObj ].getRowById( this.baseParams.rowId ) );
			}
		}
	},
	
	/**
	 * Disable some page's buttons along with the 'Save' button
	 */
	disablePageButtonsWhileSaving: function() {
		Runner.pages.EditPage.superclass.disablePageButtonsWhileSaving.call( this );
		
		Runner.addDisabledClass( this.closeButton );
		this.disablePageButtons();
	},

	/**
	 * Enable some page's buttons along with the 'Save' button
	 */
	enablePageButtonsAfterSaving: function() {
		Runner.pages.EditPage.superclass.enablePageButtonsAfterSaving.call( this );
		
		Runner.delDisabledClass( this.closeButton );
		if ( !this.isPageModified() ) {
			this.enablePageButtons();
		}
	}
});

Runner.pages.LoginPage = Runner.extend( Runner.pages.RunnerPage, {
	/**
	 * Is login page open in popup window
	 * @type {boolean}
	 */
	isPopUp: false,
	
	/**
	 * User name value
	 * @type {Object}
	 */
	userval: null,
	
	/**
	 * Password value
	 * @type {Object}
	 */
	passval: null,
	
	/**
	 * Captcha input element
	 * @type {Object}
	 */
	captcha: null,
	
	/**
	 * User name input element
	 * @type {Object}
	 */
	userName: null,
	
	/**
	 * Password input element
	 * @type {Object}
	 */
	password: null,
	
	/**
	 * The host page object for a popup login page
	 * @type {Object}
	 */
	hostPageObj: null,
	
	/**
	 * Not redirect
	 * @type {boolean}
	 */
	notRedirect: false,
	
	/**
	 * Remember password input element
	 * @type {Object}
	 */
	rememberPassword: null,

	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.LoginPage.superclass.constructor.call( this, cfg );
		
		this.isPopUp = this.openMode === Runner.pages.constants.OPENMODE_POPUP;
	},	
		
	/**
	 * Initialize the page
	 */
	init: function() {
		Runner.pages.LoginPage.superclass.init.call( this );

		this.initFields();
		this.initButtons();
		
		if ( Runner.pages.PageSettings.getGlobalData("isFB") ) {
			this.initFBLoginMethod();
		}	
		
		if ( this.isPopUp ) {
			this.on('windowSizeCorrected', this.setUserFocus);
		} else {
			this.setUserFocus();
		}
				
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
		
	/**
	 * Initialize fields and links for simple login page
	 */
	initFields: function() {
		var pageObj = this;
		
		this.userName = $('input[name="username"]', this.pageCont);
		
		this.password = $('input[name="password"]', this.pageCont).on('keydown', function(e) {
			if ( e.which != 13 ) {
				return;
			}
			
			$('#submitLogin' + pageObj.id, pageObj.pageCont).trigger('click'); 			
			return false;
		});
		
		if ( this.userval ) {
			this.userName.val( this.userval );
		}
		if ( this.passval ) {
			this.password.val( this.passval );
		}

		if ( this.isPopUp ) {
			this.captcha = $('#value_captcha_' + this.id);
			this.notRedirect = $('#notRedirect', this.pageCont ).val();
			this.rememberPassword = $('input[name="remember_password"]', this.pageCont);			
		}		
	},
	
	/**
	 * Set focus to user name field
	 */
	setUserFocus: function() {
		if ( !this.userName.prop("disabled") && this.userName.is(":visible") ) {
			this.userName.focus();
		}
	},
	
	/**
	 * Initialize the login page's buttons
	 */
	initButtons: function() {
		var pageObj = this,
			$regTableLink,
			$continueButton = $( "#continueButton", this.pageCont ),
			$submitLogin = $( "#submitLogin" + this.id, this.pageCont );
		
		if ( !this.isPopUp ) {
			$submitLogin.on("click", function(e) {
				$('#form1', pageObj.pageCont).submit();
				return false;	
			});
			
			return;
		}
		
		$regTableLink = $('a[name="RegisterPage"]', this.pageCont).on("click", function(e) {
			pageObj.registerPage( $regTableLink.data("table") );
			return false;
		});
		
		$('a[name="ForgotPasswordPage"]', this.pageCont).on("click", function(e) {
			pageObj.forgotPasswordPage();
			return false;
		});
		
		$continueButton.on("click", function(e) {
			pageObj.close();
			return false;
		});
				
		$submitLogin.on("click", function(e) {
			var	pageParams = {
				onFly: 2,
				parId: pageObj.id,
				id: Runner.genId(),
				btnSubmit: 'Login',
				username: pageObj.userName.val(),
				password: pageObj.password.val(),
				value_captcha_1: pageObj.captcha.val(),
				remember_password: pageObj.rememberPassword.is(':checked') ? 1 : 0
			};

			Runner.runnerAJAX( Runner.getPageUrl("login"), pageParams, function( respObj ) {
				if (respObj.redirect) {
					if ( pageObj.notRedirect ) {
						$submitLogin.hide();
						$continueButton.show();
						respObj.message = Runner.lang.constants.SUCCES_LOGGED_IN;
						pageObj.win.set( "headerContent", "" );
						
						pageObj.hideBrick( 'loginfields' );
						pageObj.hideBrick( 'wrapper' );
						if ( pageObj.hostPageObj ) {
							pageObj.hostPageObj.hideBrick( 'message' );
							pageObj.hostPageObj.adjustPopWindowHeightByContent();
						}
					} else {
						window.location.href = respObj.redirect;
					}
				}
				if (respObj.message) {
					pageObj.showBrick( 'message' );
					setTimeout(	function() {
						pageObj.adjustPopWindowHeightByContent()
					}, 300);
					$("#login_message").text(respObj.message);
				}				
			});	
			return false;
		});	
	},
	
	/**
	 * Initialize the Facebook login method
	 */
	initFBLoginMethod: function() {
		var pageObj = this,
			js;
		
		window.fbAsyncInit = function() {
			FB.init({
				appId : Runner.pages.PageSettings.getGlobalData("FBappId"), 
				status : true, // check login status
				cookie : true // enable cookies to allow the server to access the session
			});
		};
		
		js = document.createElement('script');
		js.src = document.location.protocol + '//connect.facebook.net/en_US/all.js';
		js.async = true;
		
		$('<div id="fb-root"></div>').append( js )
			.appendTo('#form1');

		
		$('.fb_button', this.pageCont).bind("click", function(e) {
			pageObj.FBLogIn();
			return false;
		});
	},
	
	/**
	 * Login method from Facebook
	 */
	FBLogIn: function() {
		var newWindow, windowFeatures
			screenX = window.screenX !== undefined ? window.screenX : window.screenLeft,
			screenY = window.screenY !== undefined ? window.screenY : window.screenTop,
			outerWidth = window.outerWidth !== undefined ? window.outerWidth : document.body.clientWidth,
			outerHeight = window.outerHeight !== undefined ? window.outerHeight : (document.body.clientHeight - 22),
			width = 500, height = 270;
		
		windowFeatures = 'width=' + width + ',height=' + height + ',left=' + parseInt(screenX + (outerWidth - width) / 2, 10) 
				+ ',top=' + parseInt(screenY + (outerHeight - height) / 2.5, 10);
		
		newWindow = window.open( Runner.pages.PageSettings.getGlobalData("FBLoginUrl"), 'Login_by_facebook', windowFeatures );
 		
		if ( window.focus ) {
			newWindow.focus();
		}
		
		return false;
	},
	
	/**
	 * Open a 'forgot password' page in a popup window
	 */
	forgotPasswordPage: function() {
		var pageObj = this,
			pageParams = {
				pageType: Runner.pages.constants.PAGE_REMIND,
				tName: Runner.pages.constants.NOT_TABLE_BASED_TNAME,
				pageId: -1,
				modal: true,
				baseParams: {
					parId: this.id
				},
				afterCreateHn: function() { 
					var forgotPageObj = this;

					this.win.getButton( "close" ).detach( "click" ).on( "click", function() {
						forgotPageObj.win.get('boundingBox').hide();
						forgotPageObj.openLoginPageOnPopUpClose( pageObj.notRedirect, pageObj.hostPageObj );
					});		
					
					pageObj.close();
				}
			};
		
		this.win.get('boundingBox').hide();
		Runner.pages.PageManager.openPage( pageParams );
	},
	
	/**
	 * Open a register page in a popup window
	 * @param {string} regTable
	 */
	registerPage: function( regTable ) {
		var pageObj = this,
			pageParams = {
				pageType: Runner.pages.constants.PAGE_REGISTER,
				tName: regTable,
				pageId: -1,
				modal: true,
				baseParams: {
					parId: this.id
				},
				afterCreateHn: function() {
					var regPageObj = this;

					pageObj.close();
					this.win.getButton( "close" ).detach( "click" ).on( "click", function() {
						regPageObj.win.get('boundingBox').hide();
						regPageObj.openLoginPageOnPopUpClose( pageObj.notRedirect, pageObj.hostPageObj );
					});						
				}
			};
		
		this.win.get('boundingBox').hide();
		Runner.pages.PageManager.openPage( pageParams );
	}	
});
Runner.pages.RemindPage = Runner.extend(Runner.pages.RunnerPage, {
	init: function() {
		Runner.pages.RemindPage.superclass.init.call(this);
		this.initButtons();
	},
 
	initButtons: function() {
		var pageObj = this;

		$("a[id=submitRemind]", this.pageCont).on("click", function(e) {
			var	pageParams = {
				parId: pageObj.id,
				id: Runner.genId(),
				onFly: 2,
				btnSubmit: 'Remind',
				username_email: $('input[name="username_email"]').val(),
				value_captcha_1: $('input[id="value_captcha_' + pageObj.id + '"]').val()
			};

			Runner.runnerAJAX( Runner.getPageUrl("remind"), pageParams, function( respObj ) {
				if (respObj.message) {
					pageObj.showBrick('message');
					setTimeout(	function() {
						pageObj.adjustPopWindowHeightByContent()
					}, 300);
					$("#remind_message").text(respObj.message);
				}
				if (respObj.html) {
					pageObj.win.set('bodyContent', respObj.html);
					$("a[id=closeWindowRemind]").bind("click", function(e) {
						pageObj.openLoginPageOnPopUpClose();
						return false;
					}).show();
					$("a[id=ProceedToLogin]").hide();
					$("a[id=submitRemind]").hide();
				}
			});	
			return false;
		});	
	},
	
	/**
	 * @param {boolean} notRedirect
	 * @param {object} hostPage
	 */
	openLoginPageOnPopUpClose: function( notRedirect, hostPage ) {
		var	pageObj = this;
		
		this.openLoginPage( '', '', function() {
				pageObj.close();
			}, notRedirect, hostPage);
	}	
});

/**
 * Base abstract class for all pages with showing content, list, report etc.
 */
Runner.pages.DataPageWithSearch = Runner.extend( Runner.pages.RunnerPage, {
	/**
	 * Table short name
	 * @type {string}
	 */
	shortTName: "",
	
	/**
	 * Search Controller 
	 * @type {object} 
	 */
	searchController: null,
	
	/**
	 * Indicator showing if the 'Search saving' is enabled
	 * @type {boolean}
	 */
	searchSavingEnabled: false,
	
	/**
	 * The searchParamsLogger object reference
	 * @type {object} 
	 */
	searchParamsLogger: null,
	
	
	constructor: function( cfg ) {
		Runner.pages.DataPageWithSearch.superclass.constructor.call( this, cfg );
		
		this.shortTName = Runner.pages.PageSettings.getShortTName( this.tName );
	},
		
	init: function() {
		Runner.pages.DataPageWithSearch.superclass.init.call( this );	
	},
	
	initForGrid: function() {
		Runner.pages.DataPageWithSearch.superclass.initForGrid.call( this );
		this.initPagination();
	},
	
	/**
	 * A 'Click' delegated handler that
	 * opens the the full field's content in a popup window
	 * @param {jQuery Event object} e
	 */
	largeTextOpenerDelegate: function(e) {
		var $target = $( e.target ),
			query = $target.data("query"),
			afterCreateTextWin, afterCloseTextWin;
		
		if ( !$target.is("a") || !query ) {
			return;
		}

		afterCreateTextWin = function( win ) {
			Runner.runnerAJAX( query, {}, function( respObj ) {				
				win.set('bodyContent', respObj.success ? respObj.textCont : respObj.error || "Server error");
				Runner.pages.PageManager.correctYUIWindowSize( win, true );
			});
		};	
		
		afterCloseTextWin = function( win ) {
			set_cookie( 'textWinWidth', $( win.get('boundingBox').getDOMNode() ).width() - 18, '', Runner.getCookieRoot() );
		};
		
		//create YUI3 Panel object representing the popup window
		Runner.pages.PageManager.createFlyWin.call( this, { width: parseInt( get_cookie('textWinWidth'), 10 ) || 550 }, false, afterCreateTextWin, afterCloseTextWin );
		
		Runner.Event.prototype.stopEvent(e);	
	},
	
	/**
	 * Ininitialize the page's search functionality
	 */
	initSearch: function() {
		if ( !this.controlsMap.search ) {
			return false;
		}
		
		this.searchController = new Runner.search.SearchController({
			id: this.pageId,
			tName: this.tName,
			pageType: this.pageType,
			searchTableName: this.tName,
			shortTName: this.shortTName,
			usedSrch: this.controlsMap.search.usedSrch,
			fNamesArr: this.controlsMap.search.allSearchFields,
			searchFieldsLabels: this.controlsMap.search.allSearchFieldsLabels,			
			panelSearchFields: this.controlsMap.search.panelSearchFields,
			isSearchPanelInflexible: this.controlsMap.search.inflexSearchPanel,
			isSearchRequired: this.controlsMap.search.isSearchRequired,
			requiredSearchFields: this.controlsMap.search.requiredSearchFields,
			useSuggest: Runner.pages.PageSettings.getTableData(this.tName, "ajaxSuggest"),
			filterContolsData: this.controlsMap.filters? this.controlsMap.filters.controls : []
		});	
		this.searchController.init(this.controlsMap.search.searchBlocks);
		
		this.searchSavingEnabled = Runner.pages.PageSettings.getTableData(this.tName, "searchSaving");		
		if ( !this.searchSavingEnabled ) {
			return;
		}
		
		//Create the SearchParamsLogger instance to provide this search saving functionality
		this.searchParamsLogger = new Runner.search.SearchParamsLogger({
				id: this.pageId,
				tName: this.tName,
				pageType: this.pageType,
				savedSearches: this.controlsMap.search.savedSearches || {},
			})
			.init( this.searchController );
	},
	
	/**
	 * Initialize the pagination block
	 */
	initPagination: function() {
		var pageObj = this;
		
		$("[data-function=pagination" + this.id + "]").each( function( index, elem ) {
			$(elem).bind("click", function(e) {	
				Runner.Event.prototype.stopEvent(e);	
				
				var $target = $(e.target);
				
				if ( !$target.is("a") ) {
					return false;
				}
				
				pageObj.reload( { 
					goto: $target.attr("pageNum")
				});
			});
		});
	},
	
	/**
	 * Initialize the 'Advanced search' button
	 */
	initAdvSearch: function() {
		var pageObj = this;
		
		$("a[id=advButton" + this.pageId + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl( pageObj.shortTName, "search" );
		});
	},
	
	initPrintFrLink: Runner.emptyFn,
	
	initPrintAll: Runner.emptyFn,
	
	/**
	 * Initialize an 'Export to EXCEL' link
	 */	
	initExcelLink: function() {
		var pageObj = this;
		
		$("a[id=export_to_excel" + this.pageId + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl( pageObj.shortTName, "print", "all=1&format=excel" );
		});
	},
	
	/**
	 * Initialize an 'Export to WORD' link
	 */	
	initWordLink: function() {
		var pageObj = this;
		$("a[id=export_to_word" + this.pageId + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl( pageObj.shortTName, "print", "all=1&format=word" );
		});
	},
	
	/**
	 * Initialize an 'Export to PDF' link
	 */
	initPDFLink: function() {
		var pageObj = this;
		
		$("a[id=export_to_pdf" + this.pageId + "]").bind("click", function(e) {	
			/* exportPdf #9868 */
			window.location.href = Runner.getPageUrl( pageObj.shortTName, "print", "all=1&exportPdf=1" );
		});
	},
	
	/**
	 * Initialize details previews for master list/report pages
	 */
	initDetails: function() {
		var detTables = Runner.pages.PageSettings.getTableData(this.tName, "detailTables"),
			dpParams, tName;
		
		dpParams = {
			id : this.id,
			masterTName: this.tName,
			oldLayout: this.oldLayout,
			parId: this.parId || this.id
		};
			
		this.dpObjs = {};
		
		for (tName in detTables) {
			dpParams.tName = tName;
			dpParams.pageType = detTables[ tName ].pageType;
			dpParams.hideChild = detTables[ tName ].hideChild;
			dpParams.pageContext = this.pageCont;
			
			if ( this.controlsMap.gridRows) {
				dpParams.rows = this.controlsMap.gridRows.slice(0);
			}
			
			if ( detTables[ tName ].listShowType == Runner.pages.constants.DP_POPUP ) {
				this.dpObjs[ tName ] = new Runner.util.details.DPPopUp( dpParams );
				this.dpObjs[ tName ].init();
				continue;
			} 
			
			this.dpObjs[ tName ] = new Runner.util.details.InlineDP( dpParams );
			this.dpObjs[ tName ].init();
			
			if ( typeof this.onBeforeShowDetails === "function" ) {
				this.dpObjs[ tName ].on('beforeShowDetails', this.onBeforeShowDetails, this);
			}
			
			if ( typeof this.onAfterShowDetails === "function" ) {			
				this.dpObjs[ tName ].on('afterShowDetails', this.onAfterShowDetails, this);
			}
		}
	},
	
	/**
	 * The details object 'beforeShowDetails' event object
	 * @param {object} dpObj
	 * @param {object} row
	 */
	onBeforeShowDetails: function( dpObj, row) {
		var shownDPObj, tName;
			
		for (tName in this.dpObjs) {
			if ( this.dpObjs[ tName ].getRowByInd( row.rowInd ).isShown ) { 
				shownDPObj = this.dpObjs[ tName ];
				break;
			}
		}
		
		if ( !shownDPObj ) {
			dpObj.closeDetailsByInd( row.rowInd );
			return;
		} 
		
		// show the 'loading' message while switching to another details preview
		shownDPObj.loadingCell( shownDPObj.getRowByInd( row.rowInd ) );		
	},
	
	/**
	 * @param {jQuery Event object} e
	 */
	largeTextOpenerDelegateMobile: function(e) {
		var pageObj = this,
			$target = $( e.target ),
			query = $target.data("query");
		
		if ( !$target.is("a") || !query ) {
			return false;
		}
		
		Runner.Event.prototype.stopEvent(e);
	
		Runner.runnerAJAX( query, { id: this.id }, function( respObj ) {
			var brickContent = '<div class="rnr-fulltext-content">'
					+ ( respObj.success ? respObj.textCont : ( respObj.error || "Server error" ) )
				+ '</div>';
				
			pageObj.replaceBrickContentHTMLWith("fulltext_mobile", brickContent);
			pageObj.hideBricks( pageObj.bricksArr );
			pageObj.showBricks( ["fulltext_mobile", "backbutton"] );
		});	
	},
	
	/**
	 * Initialize the back button on mobile detail page
	 */ 
	initLargeTextBackButtonMobileDP: function() {	
		var pageObj = this;
		$("#backbutton", this.pageCont).unbind("click").bind("click", function(e) {
			pageObj.hideBricks( pageObj.bricksArr );
			pageObj.showBricks( pageObj.bricksArrList );
		});
	}	
});
/**
 * Base abstract class for all pages with showing content, list, view etc.
 */
Runner.pages.ListPageCommon = Runner.extend( Runner.pages.DataPageWithSearch, {
	/**
	 * Grid element 
	 * Get with method getBrickGridElem only after resize
	 * @type {object}
	 */
	gridElem: null,
	
	/**
	 * An indicator showing if to initialize
	 * the 'Scroll table data' functionality
	 * @type {boolean}
	 */
	isScrollGridBody: false,
	
	/**
	 * The number of records per row
	 * @type {number}
	 */
	recsPerRowList: false,
	
	/**
	 * The 'Srollable table data' height. 
	 * It could be updated by user 
	 * in the "afterPageReady" event
	 * @type {number}
	 */
	heightScrollGridBody: 0,
	
	
	constructor: function(cfg) {
		Runner.pages.ListPageCommon.superclass.constructor.call(this, cfg);
		
		this.isScrollGridBody = this.isScrollingGrid();
		this.permis = Runner.pages.PageSettings.getTableData(this.tName, "permissions");	
		this.recsPerRowList = Runner.pages.PageSettings.getTableData(this.tName, "recsPerRowList");
	},
		
	init: function() {
		this.initGridElem();
		Runner.pages.ListPageCommon.superclass.init.call(this);	
		this.initResize();
		this.initSelectAll();
	},
	
	initForGrid: function() {
		Runner.pages.ListPageCommon.superclass.initForGrid.call(this)
		this.initHeaderCheckBox();
		this.initInline();
		this.initMaps();
	},
	
	initGridElem: function() {
		var bindedGridClickHn = $.proxy( this.gridClickHn, this );
		
		this.gridElem = this.getBrickGridElem();	
		$( this.gridElem ).unbind("click").bind("click", bindedGridClickHn);
		
		$( this.getBrickElem('masterinfo') ).unbind("click").bind("click", bindedGridClickHn);
	},
	
	/**
	 * Initialize the page's functionality that need initializing after tabs are loaded.
	 * If there are no tabs on the page it's invoked from the page's init method 
	 * otherwise from the initTabs method
	 * @intellisense
	 */
	initForTabs: function() {
		this.initControls();
		
		if ( !this.useResize ) {
			this.initViewControls();
		}
	
		this.initLookups();
	
	},
	
	/**
	 * Cover of inlineEdit object function
	 * If inlineEdit is turn off, then get recsId by another way
	 */	
	getRecsId: function() {
		if ( this.inlineEdit ) {
			return this.inlineEdit.getRecsId();
		}
		var recsId = {};
		$('.rnr-row:not(.gridRowAdd)', this.gridElem).not( this.inDetailPreviewContainer )
			.each( function(i, row) {
				var attrId = $(row).attr('id'),
					lastInd = attrId.lastIndexOf('w');
					
				recsId[++i] = parseInt( attrId.substr(lastInd + 1) );
			});	
		return recsId;
	},
	
	gridClickHn: function(e) {
		this.largeTextOpenerDelegate(e);
	},
	
	initResize: function() {
		if ( Runner.isMobile || !this.useResize ) {
			return;
		}

		var self = this;
		this.Y.use('cookie', 'json-parse', 'json-stringify', 'datatable-base', 'resize', function(Y) {
			if ( !self.resizeGrid ) {
				self.resizeGrid = new Runner.resize.Grid({
					tName: self.tName,
					pageId: self.pageId,
					oldLayout: self.oldLayout,
					layoutName: self.layoutName
				});
			}
			self.resizeGrid.init();
			self.initGridElem();
			self.initForGrid();
		});
	},
	
	/**
	 * Initialize the 'Choose all' checkeboxes
	 */
	initHeaderCheckBox: function() {
		var pageId = this.id;
		
		$( '.chooseAll' + pageId ).parent().unbind( "click" ).bind( "click", function(e) {
			var $chooseAll = $('.chooseAll' + pageId , this),
				checked = $chooseAll.prop("checked");
				
			if ( !$chooseAll.is( e.target ) ) {
				checked = !checked;				
			}
			
			//set checked/unchecked for all checkbox in grid rows
			$('input[type=checkbox][id^=check' + pageId + '_]').prop( "checked", checked );

			//set checked/unchecked for all chooseAll checkboxes
			$('input[type=checkbox][id^=chooseAll_' + pageId + ']').prop( "checked", checked );					
		});
	},
	
	/**
	 * Init the 'Select/Unselect all' button or checkbox
	 */
	initSelectAll: function() {
		var pageObj = this,
			selectAll = $('#select_all' + this.id),
			useCaption;
			
		if ( !selectAll.length ) {
			return false;
		}
		
		useCaption = Runner.pages.PageSettings.getTableData(this.tName, "listGridLayout") !== Runner.pages.constants.HORIZONTAL_LAYOUT;
		selectAll[0].checkAllStatus = false;
		
		selectAll.bind("click", function(e) {
			this.checkAllStatus = !this.checkAllStatus;
			$('input[type=checkbox][id^=check' + pageObj.id + '_]').prop("checked", this.checkAllStatus);
			
			if ( useCaption ) {
				$(this).html( this.checkAllStatus ? Runner.lang.constants.UNSELECT_ALL : Runner.lang.constants.SELECT_ALL );
			}
			
			return false;
		});
	},
	
	/**
	 * Init the Google maps functionality using the Runner.GmapLoader instance
	 */
	initMaps: function() {
		if ( !this.controlsMap.gMaps || !this.controlsMap.gMaps.isUseGoogleMap || !Runner.globalGmapLoader ) {
			return;
		}
		
		var initMaps = function() {		
			this.mapManager = new Runner.controls.MapManager( this.controlsMap.gMaps ); 
			this.mapManager.init();				
			
			if ( this.inlineEdit ) {				
				this.inlineEdit.on('cancel', function( row, fieldNames ) {
					var i, mapId;	 
			
					for (i = 0; i < fieldNames.length; i++) {
						if ( this.isFieldIsMap( fieldNames[i] ) ) {
							mapId =	this.getMapDivId( "FIELD_MAP", row.id, fieldNames[i] );
							this.initMap( mapId, true );
						}
					}
				}, this.mapManager);
				
				this.inlineEdit.on('afterSubmit', function( vals, fields, keys, recId, data ) {
					var i, recordVals = {keys: keys};			
					
					Runner.apply( recordVals, data.rawVals );
				
					for (i = 0; i < fields.length; i++) {
						this.initInlineMapOrCenterLink( fields[i], recId, vals[ fields[i] ] );
					}
					this.updateAfterEdit( recId, recordVals );					
				}, this.mapManager);
			}
			
			if ( this.inlineAdd ) {
				this.inlineAdd.on('afterSubmit', function( vals, fields, keys, recId, data ) {
					var i, recordVals = {keys: keys};
					 
					Runner.apply( recordVals, data.rawVals );	
					this.updateAfterAdd( recId, recordVals );
					
					for (i = 0; i < fields.length; i++) {
						this.initInlineMapOrCenterLink( fields[i], recId, vals[ fields[i] ], true );
					}
				}, this.mapManager);
			}
		}
		
		Runner.globalGmapLoader.onLoad( initMaps, this );
	},
	
	afterInitInlineAdd: function( row ) {
		if ( !this.useButtons ) {
			return;
		}
		var i, newId, $buttonElem, button;	
		
		for (i = 0; i < this.buttonNames.length; i++) {
			$buttonElem = $("#" + this.buttonNames[i], row.row);
			if ( !$buttonElem.length ) {
				continue;
			}
			newId = this.buttonNames[i] + "_" + Runner.genId();
			$buttonElem.attr('id', newId);
			// create object
			button = new Runner.form.Button({
				id: newId,
				btnName: this.buttonNames[i]
			});
			// init
			button.init({args: [this, this.proxy, this.id, true]});	
		}
	},

	/**
	 * Remove all excessive containers
	 * Disable the page's grid and show the 'loading' message
	 * @param {DOM element} gridElem
	 */
	preparePageForReloading: function( gridElem ) {
		if ( this.inlineEdit || this.inlineAdd ) {
			( this.inlineEdit || this.inlineAdd ).cancelAll();
		}
		
		Runner.runLoading( "", gridElem || this.gridElem, this.openMode === Runner.pages.constants.OPENMODE_POPUP, this.win );
	},
	
	/**
	 * Set 'afterInit' event's handler settings the scrollable grid
	 * @param {object} pageObj
	 * @param {object} proxy
	 * @param {number} pageid
	 */
	afterInit: function( pageObj, proxy, pageid ) {
		this.heightScrollGridBody = proxy['gridHeight'];
		this.initScrollGridBody();
	},
	
	/**
	 * Is grid scrolling or not
	 * @return {boolean}
	 */	
	isScrollingGrid: function() {
		if ( Runner.pages.PageSettings.getTableData(this.tName, "isUseResize") ) {
			return false;
		}
		
		return Runner.pages.PageSettings.getTableData(this.tName, "scrollGridBody");
	},
	
	/**
	 * Make the grid data scrollable
	 */	
	initScrollGridBody: function() {
		if ( !this.isScrollGridBody ) {
			return;
		}
		
		var maxExtraHeight = 80,
			scrollElementWidth = 15,
			viewPortHeight = $(window).height(),
			gridHeight = this.gridElem.height(),
			gridPosition = this.gridElem.position(),
			fullGridHeight = gridHeight + gridPosition.top,
			extraDocumentHeight, baseClassPref, divScrollWrappper, divSrollInner, header, footer, 
			bottomRow, scrollGridHeight, wrapperHeight, theadHeight, footerHeight, bottomHeight;	
		
		if ( fullGridHeight < viewPortHeight ) {
			// the all grid data is visible in the view port
			this.isScrollGridBody = false;
			return;
		}
	
		scrollGridHeight = this.heightScrollGridBody;
		header = $('thead tr', this.gridElem);
		footer = $('.footer', this.gridElem);
		baseClassPref = this.oldLayout ? 'runner-' : 'rnr-';
		bottomRow = $('.' + baseClassPref + 'bottomrow', this.gridElem);

		// reset the grid's width that user may have set in the wizard
		this.gridElem.css('width', 'auto');
		
		// set width values in explicit way for the header, foter and bottom rows' cells 
		// Note: some grid elements height could be changed 
		this.setEdgeRowsWidthStyles( header, footer, bottomRow);	
		
		theadHeight = header.height() || 32;	
		footerHeight = footer.height();
		bottomHeight = bottomRow.height();
		
		this.gridElem.data('theadheight', theadHeight);
	
		if ( !scrollGridHeight ) {
			scrollGridHeight = viewPortHeight - gridPosition.top;
			
			extraDocumentHeight = $(document).height() - gridPosition.top - gridHeight;
			scrollGridHeight = extraDocumentHeight < maxExtraHeight ? scrollGridHeight - extraDocumentHeight : scrollGridHeight;
			
			scrollGridHeight = scrollGridHeight < 0 ? scrollGridHeight * (-1) : scrollGridHeight;
			if ( scrollGridHeight - footerHeight - bottomHeight - theadHeight < 32 ) {
				//set the scrollable grid height so It can show the scroll element correctly
				scrollGridHeight += theadHeight + 32;
			}
		}
		
		//calculate height values for the grid element's wrapper and container 
		scrollGridHeight = scrollGridHeight - footerHeight - bottomHeight - theadHeight;
		wrapperHeight = scrollGridHeight + bottomHeight + footerHeight;
		
		//create the new grid element wrapper 
		divScrollWrappper = $('<div></div>')
			.addClass( baseClassPref + 'scrollgrid-wrap' )
			.css({
				'position': 'relative',
				'height': wrapperHeight + 'px',
				'padding': theadHeight + 'px 0 0',
				'margin-bottom' : this.gridElem.css('margin-bottom')
			});	
		
		//create the grid element's container providing grid data with the vertical scrolling ability 
		divSrollInner = $('<div></div>')
			.addClass( baseClassPref + 'scrollgrid-inner' )
			.css({
				'height': scrollGridHeight + 'px',
				'overflow-y': 'auto',
				'overflow-x': 'hidden',
				'width': this.gridElem.outerWidth( true ) + scrollElementWidth + 'px'
			})
			.scroll( function() {
				$('div.shiny_box').hide();
			})
			.appendTo( divScrollWrappper );		
			
		// set the grid scrollable by changing page's html markup	
		this.gridElem.closest( '.' + baseClassPref + 's-grid' )
			.not( '.not-container' )
			.before( divScrollWrappper )
			.appendTo( divSrollInner );
		
		//add styles to some grid elements to set them out of the scrollable grid
		this.setAbsolutePositionForHeaderAndFooter( true, header, footer, bottomRow, scrollElementWidth, scrollGridHeight, theadHeight, footerHeight );
		
		this.addScrollElemWidthToLastCells( scrollElementWidth, header, footer, bottomRow );
	},
	
	/**
	 * Set for the grid's footer and header elements an absolute position
	 * @param {Boolean} setOffset
	 * @param {jQuery object} header 
	 * @param {jQuery object} footer 
	 * @param {jQuery object} bottomRow
	 * @param {Number} scrollElementWidth
	 * @param {Number} gridHeight
	 * @param {Number} theadHeight
	 * @param {Number} footerHeight
	 */
	setAbsolutePositionForHeaderAndFooter: function( setOffset, header, footer, bottomRow, scrollElementWidth, gridHeight, theadHeight, footerHeight ) {
		var newWidth = this.gridElem.width() + scrollElementWidth;
		
		header.css('position', 'absolute').width( newWidth );	
		footer.css('position', 'absolute').width( newWidth );
		bottomRow.css('position', 'absolute').width( newWidth );
		
		if ( setOffset ) {
			header.css('top', '0px');	
			footer.css('top', gridHeight + theadHeight - 5 + 'px');
			bottomRow.css('top', gridHeight + theadHeight + footerHeight - 5 + 'px');
		}
	},
	
	/**
	 * Add to the last foter, header and bottom Row cells width value the scroll element's width
	 * @param {Number} scrollElementWidth
	 * @param {jQuery object} header
	 * @param {jQuery object} footer
	 * @param {jQuery object} bottomRow
	 */
	addScrollElemWidthToLastCells: function( scrollElementWidth, header, footer, bottomRow ) {
		if (this.oldLayout) {
			return;
		}
		var thHeader = $('th:last', header),
			thFooter = $('td:last', footer),
			thBottom = $('td:last', bottomRow);
		
		thHeader.css( 'width', thHeader.width() + scrollElementWidth + 'px' );
		thFooter.css( 'width', thFooter.width() + scrollElementWidth + 'px' );
		thBottom.css( 'width', thBottom.width() + scrollElementWidth + 'px' );
	},
	
	/** 
	 * Set style:width values for the header, foter and bottom rows' cells 
	 * @param {jQuery object} header
	 * @param {jQuery object} footer
	 * @param {jQuery object} bottomRow
	 */	 
	setEdgeRowsWidthStyles: function( header, footer, bottomRow ) {
		var cellsWidths = [],
			baseClassPref = this.oldLayout ? 'runner-' : 'rnr-',		
			cellsSelector = this.oldLayout ? '.' + baseClassPref + 'cc' : 'th, td',
			gridRow = $( '.' + baseClassPref + 'row:not(.gridRowAdd):first', this.gridElem )
							.not( this.inDetailPreviewContainer ),
			gridRowCells = gridRow.children( cellsSelector );
		
		// Set the grid row's cells min-width explicitly
		gridRowCells.each( function( ind, cell ) {
			var jQcell = $(cell);
			jQcell.css('min-width', jQcell.width() + 'px');
		});
		
		// store cells' outerWidth values in the array		
		gridRowCells.each( function( ind, cell ) {
			var jQcell = $(cell);
			cellsWidths.push( jQcell.outerWidth( true ) );	
		});		
			
		this.setOuterElementCellsWidthStyles( cellsSelector, header, cellsWidths );
		this.setOuterElementCellsWidthStyles( cellsSelector, bottomRow, cellsWidths );
		this.setOuterElementCellsWidthStyles( cellsSelector, footer, cellsWidths );
	},
	
	/**
	 * Set the grid's outer element cells' styles
	 * @param {String} cellsSelector
	 * @param {jQuery object} element
	 * @param {Array} cellsWidths
	 */
	setOuterElementCellsWidthStyles: function( cellsSelector, element, cellsWidths ) {
		element.children( cellsSelector ).each( function( ind, cell ) {
			var jQcell = $(cell),
				paddings = jQcell.outerWidth( true ) - jQcell.width(),
				width = cellsWidths[ ind ] - paddings;
			
			jQcell.css('width', width + 'px');
		});	
	},
	
	/** 
	 *	Set style:width 'auto' for the header, foter and bottom rows' cells 
	 */
	setEdgeRowWidthAuto: function() {
		var baseClassPref = this.oldLayout ? 'runner-' : 'rnr-',		
			cellsSelector = this.oldLayout ? '.' + baseClassPref + 'cc' : 'th, td',
			edgeRows;
			
		edgeRows = $('.' + baseClassPref + 'toprow, .' + baseClassPref + 'row:not(.gridRowAdd):first, .footer, .' + baseClassPref + 'bottomrow', this.gridElem )
			.not( this.inDetailPreviewContainer )
			.css('position', 'static');
		
		edgeRows.children( cellsSelector )
			.css('min-width', 'auto')
			.css('width', 'auto');	
	},
	
	/**
	 * jQuery callback function checking if the current 
	 * DOM element belongs to the DetailPreview container
	 * @return {Boolean}
	 */
	inDetailPreviewContainer: function() {
		return $(this).closest('td.dpinline').length;
	},
	
	/**
	 * Recalculation grid size for scrolling
	 */	
	recalculationGridSize: function() {
		if ( !this.isScrollGridBody || !Runner.pages.PageSettings.getTableData(this.tName, 'showRows') ) {
			return;
		}
		var pageObj = this,
			scrollElementWidth = 15,
			baseClassPref = this.oldLayout ? 'runner-' : 'rnr-',
			divScrollWrappper = this.gridElem.closest('.' + baseClassPref + 'scrollgrid-wrap'),
			divSrollInner = this.gridElem.closest('.' + baseClassPref + 'scrollgrid-inner'),
			header = $('.' + baseClassPref + 'toprow', this.gridElem).not( this.inDetailPreviewContainer ),
			footer = $('.footer', this.gridElem).not( this.inDetailPreviewContainer ),	
			bottomRow = $('.' + baseClassPref + 'bottomrow', this.gridElem).not( this.inDetailPreviewContainer ),	
			scrollGridWidth = divSrollInner.width(),
			headerTh = $('th:first', header),
			theadHeight = headerTh.get(0).offsetHeight || 32;
			
			
		if ( !this.oldLayout ) {
			divSrollInner.width( scrollGridWidth - scrollElementWidth );
		}
		
		this.setEdgeRowWidthAuto();		
		this.setEdgeRowsWidthStyles( header, footer, bottomRow );

		if ( this.gridElem.data('theadheight') !== theadHeight ) {
			// recalculate the scrollable grid height and set absolute position 
			// and offsets for header, footer and grid's bottom row elements
			this.recalculateGridHeight( divSrollInner, divScrollWrappper, footer, bottomRow, theadHeight );
			this.gridElem.data('theadheight', theadHeight);			
		} else {
			// set absolute position for header, footer and grid's bottom row
			this.setAbsolutePositionForHeaderAndFooter( false, header, footer, bottomRow, scrollElementWidth );
		}
		
		// provide the browser width some time to recalculate the page's markup 
		setTimeout( function() {
			pageObj.adjustScrollableGridContainer( scrollElementWidth, divSrollInner );
			pageObj.addScrollElemWidthToLastCells( scrollElementWidth, header, footer, bottomRow );
		}, 0);
		
		divSrollInner.css('overflow-y', 'auto');			
	},
	
	/**
	 * Recalculate the scrollable grid's height
	 * @param {jQuery object} divSrollInner 	
	 * @param {jQuery object} divScrollWrappper	
	 * @param {jQuery object} footer
	 * @param {jQuery object} bottomRow	
	 * @param {Number} theadHeight
	 */
	recalculateGridHeight: function( divSrollInner, divScrollWrappper, footer, bottomRow, theadHeight ) {
		var myHeight = divScrollWrappper.height(),
			footerHeight, bottomHeight;
			
		divSrollInner.css({
			'overflow-y': 'hidden',
			'height': 'auto'	
		});
		
		divScrollWrappper.css('height', 'auto');	
				
		footerHeight = footer.height();
		bottomHeight = bottomRow.height();
					
		divScrollWrappper.css({
			'height': myHeight,
			'padding': theadHeight + 'px 0 0'
		});
		
		myHeight = myHeight - bottomHeight - footerHeight;
		divSrollInner.css('height', myHeight);
		
		this.setAbsolutePositionForHeaderAndFooter( true, header, footer, bottomRow, scrollElementWidth, myHeight, theadHeight, footerHeight );	
	},
	
	/**
	 * Adjust scrollable grid container width after the frid size recalculation
	 * basing on the grid element width 
	 * @param {Number} scrollElementWidth
	 * @param {jQuery object} container
	 */ 
	adjustScrollableGridContainer: function( scrollElementWidth, container ) {
		container.width( this.gridElem.width() + scrollElementWidth );		
	}
});	
Runner.pages.ListPageFly = Runner.extend( Runner.pages.ListPageCommon, {
	/**
	 * The main lookup control
	 * @type {object}
	 */	
	lookupCtrl: null,
	
	lookupBaseParams: null,
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {	
		Runner.pages.ListPageFly.superclass.constructor.call(this, cfg);
		this.listFields = Runner.pages.PageSettings.getTableData(this.tName, 'listFields');
		this.bricksForReload = ["grid", "pagination", "message"];
		
		this.on("afterInit", function(pageObj) {	
			this.lookupCtrl.lookupVals = this.controlsMap.lookupVals;
			
			this.lookupCtrl.initLinks(this.pageId);
			
			this.lookupCtrl.lookupSelectField = this.controlsMap.lookupSelectField;
			this.lookupCtrl.dispFieldAlias = this.controlsMap.dispFieldAlias;
			this.lookupCtrl.linkField = this.controlsMap.linkField;
			this.lookupCtrl.dispField = this.controlsMap.dispField;
		}, this);
		
		this.lookupBaseParams = {
			parId: this.lookupCtrl.pageId, 
			table: this.lookupCtrl.table, 
			field: this.lookupCtrl.fieldName, 
			mode: "lookup",
			category: this.lookupCtrl.parentCtrl ? this.lookupCtrl.parentCtrl.getValue() : '',
			control: "control", 
			editMode: this.lookupCtrl.mode,
			pageType: this.baseParams.pageType,
			id: this.pageId
		};
	},
	
	destructor: function() {
		Runner.pages.ListPageFly.superclass.destructor.call(this);
		this.pageCont = null;
		this.lookupCtrl.pageId = -1;
	},
	
	init: function() {
		Runner.pages.ListPageFly.superclass.init.call(this);
		if (Runner.isMobile) {
			this.showBrickMobile(["vmsearch2", "cancelbutton_mobile"], "flylist");
		}
		this.initSorting();
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	/**
	 * Resize don't use on the list lookup
	 */
	initResize: Runner.emptyFn,
	
	initScrollGridBody: Runner.emptyFn,
	
	initSearch: function() {
		this.searchController = new Runner.search.SearchController({
			id: this.pageId,
			tName: this.tName,
			fNamesArr: this.controlsMap.search.allSearchFields,
			shortTName: this.shortTName,
			usedSrch: this.controlsMap.search.usedSrch,
			panelSearchFields: this.controlsMap.search.panelSearchFields,
			ajaxSubmit: true,
			useSuggest: false,
			pageType: this.pageType
		});
		
		this.searchController.init( this.controlsMap.search.searchBlocks );
		this.searchController.srchForm.baseParams = this.lookupBaseParams;
		
		if ( !Runner.isMobile ) {
			this.searchController.srchForm.on("beforeSubmit", function(form) {
				this.preparePageForReloading( this.win.bodyNode.getDOMNode() );
			}, this);
			this.searchController.srchForm.on('submitFailed', function() {
				Runner.stopLoading( this.win.bodyNode.getDOMNode() );
			}, this);
		}
		
		this.searchController.on('afterSearch', function(respObj, srchController, srchForm) {
			if ( !Runner.isMobile ) {
				Runner.stopLoading( this.win.bodyNode.getDOMNode() );
			}
			this.pageReloadHn( respObj );
			this.searchController.toggleShowAll( this.searchController.usedSrch );
		}, this);		
	},
	
	/**
	 * Initialize 'Inline Add' functionality
	 */
	initInline: function() {
		if ( !Runner.pages.PageSettings.getTableData(this.tName, "isInlineAdd") || !this.permis['add'] ) {
			return;
		}
		
		this.inlineAdd = new Runner.util.inlineEditing.InlineAdd({
			tName: this.tName,
			shortTName: this.shortTName,
			id: this.pageId,
			fNames: this.listFields,
			rows: this.controlsMap.gridRows,
			inlineEditObj: this.inlineEdit,
			lookupField: this.lookupCtrl.fieldName,
			categoryValue: this.lookupCtrl.parentCtrl ? this.lookupCtrl.parentCtrl.getValue() : "",
			lookupTable: this.lookupCtrl.table,
			isOldLayout: this.oldLayout,
			loadSettings: true
		});

		this.inlineAdd.init();
		
		this.inlineAdd.on("beforeSetVals", function(row, fields) {
			if ( row.data[ this.lookupCtrl.dispFieldAlias ] ) {
				row.data[this.lookupCtrl.dispFieldAlias] = '<a href="#" type="lookupSelect'+this.searchController.srchForm.baseParams.id+'">'+row.data[this.lookupCtrl.dispFieldAlias]+'</a>';
			} else if (row.data[this.lookupCtrl.dispField]) {
				row.data[this.lookupCtrl.dispField] = '<a href="#" type="lookupSelect'+this.searchController.srchForm.baseParams.id+'">'+row.data[this.lookupCtrl.dispField]+'</a>';
			} else {
				for (field in row.data) {
					row.data[field] = '<a href="#" type="lookupSelect'+this.searchController.srchForm.baseParams.id+'">'+row.data[field]+'</a>';
					break;
				}
			}
		}, this);
		
		this.inlineAdd.on("afterSubmit", function(vals, fields, keys, rowId) {
			var linkField = vals[ this.lookupCtrl.linkField ];
			if (typeof linkField == "undefined") {
				linkField = keys[ this.lookupCtrl.linkField ];
			}
			var newInd = this.lookupCtrl.addLookupVal( linkField, vals[ this.lookupCtrl.dispFieldAlias ] || vals[ this.lookupCtrl.dispField ] ),
				links = $('tr[id="gridRow' + rowId + '"] a[type="lookupSelect' + this.searchController.srchForm.baseParams.id + '"]');
			
			if (links.length) {
				this.lookupCtrl.initLink( links.eq(0), newInd );
			}
		}, this);
		
		this.inlineAdd.on("afterInit", function( pageObj, proxy, pageid, row ) {
			this.afterInitInlineAdd( row );
		}, this);
	},
	
	/**
	 * Initialize sorting functionality
	 */
	initSorting: function() {
		var pageObj = this;
		
		for (var i = 0; i < this.listFields.length; i++) {
			$('[id="order_' + Runner.goodFieldName( this.listFields[i] ) + '_' + this.pageId + '"]').on("click", function(e) {				
				if (!Runner.isMobile) {
					pageObj.preparePageForReloading();
				}
				
				Runner.runnerAJAX( $(this).data("href"), {pageType: pageObj.baseParams.pageType}, function( respObj ) {
					pageObj.pageReloadHn( respObj )
				});
				return false;
			});
		}
	},
	
	/**
	 * Initialize the pagination block.
	 * The 'pagination' brick  are not replaced after ajax reloading
	 * so it doesn't need reinitializing in pageReloadHn
	 */
	initPagination: function() {
		var pageObj = this;
		
		$.each( this.getBrickObjs('pagination'), function( index, brick ) {
			brick.elem.bind("click", function(e) {	
				Runner.Event.prototype.stopEvent(e);
				
				var $target = $(e.target),
					url;
				
				if ( !$target.is("a") ) {
					return;
				}
				
				if ( !Runner.isMobile ) {
					pageObj.preparePageForReloading();
				}	
				
				url = Runner.pages.getUrl( pageObj.tName, pageObj.pageType ) + "?goto=" + $target.attr("pageNum");
				
				Runner.runnerAJAX( url, pageObj.lookupBaseParams, function( respObj ) {
					pageObj.pageReloadHn( respObj )
				});
			});
		});
	},
	
	/**
	 * The fly list page's reload handler
	 * @param {Object} respObj
	 */	
	pageReloadHn: function( respObj ) {
		Runner.stopLoading( this.gridElem );
		
		if (!respObj.success) {
			this.win.set('bodyContent', "REQUEST FAILED");
			return;
		}
				
		this.destroyVideo();
		Runner.setIdCounter( respObj.idStartFrom );
		
		// replace bricks		
		this.replaceBricksHTMLWith( this.getBricksHtml(respObj.html) );
		
		// set controlsMap
		this.controlsMap = respObj["controlsMap"][ this.tName ][ this.pageType ][ this.pageId ];
		
		// set new vals
		this.lookupCtrl.lookupVals = this.controlsMap.lookupVals;			
		this.lookupCtrl.initLinks( this.pageId );
		
		this.initGridElem();
		this.initSorting();
		
		if ( this.mapManager && this.controlsMap.gMaps && this.controlsMap.gMaps.isUseGoogleMap ) {
			this.mapManager.init( this.controlsMap.gMaps.mapsData );
		}
		
		if ( this.inlineAdd ) {
			this.inlineAdd.reInit( this.controlsMap.gridRows );
		}
		
		this.searchController.usedSrch = this.controlsMap.search.usedSrch;	
		this.searchController.toggleShowAll( this.searchController.usedSrch );	
		
		if ( typeof respObj.viewControlsMap === "object" && respObj.viewControlsMap[ this.tName ][ this.pageType ][ this.pageId ].controls ) {
			this.reInitViewControls( respObj.viewControlsMap[ this.tName ][ this.pageType ][ this.pageId ].controls );
		}
		
		this.fireEvent('afterPageReady', this, this.proxy, this.pageId);
	},
	
	/**
	 * Reinitialize view controls
	 * @param {array} viewControls
	 */ 
	reInitViewControls: function( viewControls ) {
		var ctrl, i;

		for (i = 0; i < viewControls.length; i++) {
			viewControls[i].table = this.tName;
			ctrl = Runner.viewControls.ViewControlFabric( viewControls[i], this.pageType, this.pageCont, this );
			ctrl.init();
		}		
	}	
});		
Runner.pages.ListPage = Runner.extend( Runner.pages.ListPageCommon, {
		
	inlineEdit: null,
	
	inlineAdd: null,
	
	pageType: Runner.pages.constants.PAGE_LIST,
		
	mapManager: null,
		
	multipleHint: null,
	
	existMultipleHint: false,
		
	constructor: function( cfg ) {
		Runner.pages.ListPage.superclass.constructor.call(this, cfg);
		this.listFields = Runner.pages.PageSettings.getTableData(this.tName, 'listFields');
		this.multipleHint = $(".rnr-sorthint", document.body);
		this.isUseInlineEdit = Runner.pages.PageSettings.getTableData(this.tName, "isInlineEdit");
		this.addEvents("afterInlineAdd", "afterInlineEdit");
	},
	
	destructor: function() {
		for (var tName in this.dpObjs) {
			this.dpObjs[tName].destructor();
		}
		Runner.pages.ListPage.superclass.destructor.call(this);
	},
	
	init: function() {
		Runner.pages.ListPage.superclass.init.call(this);
		this.initButtons();
		this.initSection508();
		
		this.initUnlockingOnPageUnload();	
	},
	
	initForGrid: function() {
		Runner.pages.ListPage.superclass.initForGrid.call(this);
		this.initSorting();
		this.initDetails();
		this.initPopupLinks();
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	initSection508: function() {
		if ( Runner.pages.PageSettings.getGlobalData("s508") ) {
			this.s508Obj = new Runner.s508({
				pageId: this.id,
				gridObj: this.gridElem,
				pageURL: Runner.pages.getUrl(this.tName, this.pageType),
				maxPages: Runner.pages.PageSettings.getTableData(this.tName, "maxPages"),
				isUseInlineEdit: this.isUseInlineEdit && this.permis['edit']
			});
			this.s508Obj.init();
		}
	},
	
	/**
	 * Inint Inline Add/Edit basing on page's settings
	 */
	initInline: function() {	
		var showAddInPopup = Runner.pages.PageSettings.getTableData(this.tName, "showAddInPopup") && !Runner.isMobile,
			showEditInPopup = Runner.pages.PageSettings.getTableData(this.tName, "showEditInPopup") && !Runner.isMobile,
			showViewInPopup = Runner.pages.PageSettings.getTableData(this.tName, "showViewInPopup") && !Runner.isMobile;
		
		if (this.isUseInlineEdit && this.permis['edit'] || showAddInPopup || showEditInPopup || showViewInPopup) {
			this.initInlineEdit();
		}
		
		if (Runner.pages.PageSettings.getTableData(this.tName, "isInlineAdd") && this.permis['add'] || showAddInPopup || showEditInPopup || showViewInPopup) {
			this.initInlineAdd();
		}
	},

	/**
	 * @return {object}
	 */
	getInlineEditParams: function() {
		return {
			id: this.pageId,
			tName: this.tName,
			shortTName: this.shortTName,
			fNames: this.listFields,
			rows: this.controlsMap.gridRows,
			loadSettings: true,
			isOldLayout: this.oldLayout
		}
	},
	
	/**
	 * Init Inline Edit
	 */
	initInlineEdit: function() {
		this.inlineEdit = new Runner.util.inlineEditing.InlineEdit( this.getInlineEditParams() );
		
		this.inlineEdit.init();
		
		this.inlineEdit.on("afterSave", function(fieldsData) {
			this.fireEvent("afterInlineEdit", fieldsData);
		}, this);
		
		this.inlineEdit.on("recalcGridSize", function() {
			this.recalculationGridSize();
		}, this);
		
		//after multiple saving rows
		this.inlineEdit.on("rowsEdited", function() {
			this.fireEvent("recalcGridSize");
		});
		
		this.inlineEdit.on("afterInit", function(pageObj, proxy, pageid, row) {
			this.recalculationGridSize();
		}, this);
	},
	
	/**
	 * @return {object}
	 */
	getInlineAddParams: function() {
		return {
			id: this.pageId,
			tName: this.tName,
			shortTName: this.shortTName,
			fNames: this.listFields,
			rows: this.controlsMap.gridRows,
			inlineEditObj: this.inlineEdit,
			loadSettings: true,
			isOldLayout: this.oldLayout
		}
	},
	
	/**
	 * Init Inline Add
	 */
	initInlineAdd: function() {
		this.inlineAdd = new Runner.util.inlineEditing.InlineAdd( this.getInlineAddParams() );
		
		this.inlineAdd.init();
		
		this.inlineAdd.on("afterSubmit", function(vals, fields, keys, id, resp) {
			var detailsBricks = this.getBrickObjs('details_found'),
				tName, detTables;
			
			if (!detailsBricks.length) {
				detailsBricks = this.getBrickObjs('vdetails_found');
			}
			
			$.each(detailsBricks, function(ind, brick) {
				$('.rnr-details_found_count', brick.elem[0]).each( function(dind, detail) {
					var df = parseInt( $(detail).html(), 10 );
					$(detail).html( df ? df + 1 : '1' );
				});
			});
			
			if (resp.noKeys === true) {
				return;
			}
			
			for	(tName in this.dpObjs) {
				this.dpObjs[ tName ].addRow({
					id: id,
					masterKeys: resp.detKeys[ tName ],
					keys: keys
				});
			}
			
			detTables = Runner.pages.PageSettings.getTableData(this.tName, "detailTables");
			
			for (tName in detTables) {
				$("#master_" + Runner.pages.PageSettings.getShortTName(tName) + "_" + id).show();
			}	
		}, this);
		
		
		this.inlineAdd.on("afterSave", function(fieldsData) {
			this.fireEvent("afterInlineAdd", fieldsData);
		}, this);
		
		this.inlineAdd.on("recalcGridSize", function() {
			this.recalculationGridSize();
		}, this);
		
		//after multiple saving rows
		this.inlineAdd.on("rowsEdited", function() {
			this.fireEvent("recalcGridSize");
		});
		
		this.inlineAdd.on("afterInit", function(pageObj, proxy, pageid, row) {
			this.afterInitInlineAdd(row);
			this.recalculationGridSize();
		}, this);
	},
	
	afterInlineAdd: function(fn) {
		this.on('afterInlineAdd', fn, this);
	},
	
	afterInlineEdit: function(fn) {
		this.on('afterInlineEdit', fn, this);
	},
	
	/**
	 * The details object 'afterShowDetails' event object
	 */	
	onAfterShowDetails: function() {
		// recalculate the scrollable grid size
		this.recalculationGridSize();	
	},
	
	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		this.initDeleteButton();
		this.initRecordBlock();
		this.initExportLink();
		this.initPrintLink();
		this.initAddButton();
		this.initAdminButton();
		
		this.initButtonGroupTogglers();
	},
	
	/**
	 * Initialize popup link to details pages
	 */
	initPopupLinks: function() {
		if ( Runner.isMobile || typeof this.dpObjs === "undefined" ) {
			return;
		}
		
		var pageObj = this, 
			detTables = Runner.pages.PageSettings.getTableData(pageObj.tName, "detailTables"),
			masterMouseOver = function() {
				var linkId = $(this).attr('id'),
					shortTName = linkId.match(/^[^_]+_(.*)_[^_]+$/)[1], 
					rowId = linkId.match(/_([^_]+)$/)[1], 
					masterKeys = {},
					page, tName, row, requestUrl, detTName;
					
				for ( detTName in detTables ) {
					if ( Runner.pages.PageSettings.getShortTName( detTName ) == shortTName ) {
						page = detTables[ detTName ].pageType;
						tName = detTName;
						break;
					}
				}	

				if ( !tName ) {
					return;
				}
				
				$.each( pageObj.dpObjs[ tName ].rows, function( index, tRow ) {
					if (tRow.id == rowId) {
						row = tRow;
						return false;
					}
				});
				
				if ( !row) {
					return;
				}
				
				$.each( row.masterKeys, function( mKey, mKeyValue ) {
					masterKeys[ mKey ] = mKeyValue || "";
				});
				
				page = page === Runner.pages.constants.PAGE_LIST ? 'detailspreview' : page;
				requestUrl = Runner.getPageUrl( shortTName, page ),
				pageObj.dpObjs[ tName ].showPopup( this, requestUrl, pageObj.tName, masterKeys );
			};
			
		
		$.each( this.dpObjs, function( tName, tObj ) {			
			if ( detTables[ tName ].listShowType == Runner.pages.constants.DP_NONE ) {
				return;
			}
			
			var $detailLink = $( "a[id^='master_" + tObj.shortTName + "']", pageObj.getBrickGridElem() );
			
			if ( Runner.isDirRTL() ) {
				$detailLink.attr("dir", $("html").attr("dir") );
			}
			
			$detailLink.unbind('mouseover').unbind('mouseout')
				.bind({
					mouseover: masterMouseOver,
					mouseout: $.proxy( tObj.hidePopup, tObj )
				});
		});
	},
	
	/**
	 * @param {Stirng} rowId
	 * @return {Boolean}
	 */
	getEditRows: function( rowId ) {
		var rows = this.controlsMap.gridRows,
			i;
		for (i = 0; i < rows.length; i++) {
			if ( rows[i].id == parseInt(rowId, 10) && rows[i].isEditOwnRow ) {
				return true;
			}
		}
		return false;
	},
	
	/**
	 * Initialize the 'Delete selected' button
	 */
	initDeleteButton: function() {	
		var pageObj = this,
			submitUrl = Runner.getPageUrl(this.shortTName, this.pageType);
		
		$("a[id=delete_selected" + this.id + "]").unbind("click").bind("click", function(e) {
			var selBoxes = pageObj.getSelBoxes( pageObj.id ),
				tempBoxes, form;

			if ( Runner.pages.PageSettings.getTableData( pageObj.tName, "isEditOwn" ) ) {
				tempBoxes = [];
				
				$.each( selBoxes, function( index, checkBox ) {
					var $checkBox = $(checkBox),
						boxId = $checkBox.attr('id'),
						rowId = boxId.substr( boxId.lastIndexOf('_') + 1 );
					
					if ( ( !pageObj.inlineAdd || !pageObj.inlineAdd.getRowById( rowId ).isAddOwnRow ) && !pageObj.getEditRows(rowId) ) {
						$checkBox.prop("checked", false);
						return;
					}
					tempBoxes.push( checkBox );
				});
				
				selBoxes = tempBoxes;
			}
			
			if ( !selBoxes.length || !confirm( Runner.lang.constants.TEXT_DELETE_CONFIRM ) ) {
				return false;
			}
			
			form = new Runner.form.BasicForm({
				standardSubmit: true,
				submitUrl: submitUrl,
				method: 'POST',
				id: pageObj.id,
				baseParams: {a: 'delete'},
				addElems: pageObj.cloneFormElements( selBoxes )
			});
			
			form.submit();
			form.destructor();

			return false;
		});
	},
	
	/**
	 * Initialize the 'Export selected' button
	 */
	initExportLink: function() {
		var pageObj = this,
			submitUrl = Runner.getPageUrl(this.shortTName, Runner.pages.constants.PAGE_EXPORT);
		
		$("a[id=export_selected" + this.id + "]").unbind("click").bind("click", function(e) {
			var selBoxes = pageObj.getSelBoxes( pageObj.id ),
				form;
			
			if ( !selBoxes.length ) {
				return false;
			}
			
			form = new Runner.form.BasicForm({
				standardSubmit: true,
				submitUrl: submitUrl,
				target: '_blank',
				method: 'POST',
				id: pageObj.id,
				addElems: pageObj.cloneFormElements( selBoxes ),
				baseParams: {a: "export"}
			});
			
			form.submit();
			form.destructor();
		});	
	},

	/**
	 * Initialize the 'Print selected' button
	 */	
	initPrintLink: function() {
		var pageObj = this,
			submitUrl = Runner.getPageUrl(this.shortTName, Runner.pages.constants.PAGE_PRINT);
			
		$("a[id=print_selected" + this.id + "]").unbind("click").bind("click", function(e) {
			var selBoxes = pageObj.getSelBoxes( pageObj.id ),
				form;
			
			if ( !selBoxes.length ) {
				return false;
			}
			
			form = new Runner.form.BasicForm({
				standardSubmit: true,
				submitUrl: submitUrl,
				target: '_blank',
				method: 'POST',
				id: pageObj.id,
				addElems: pageObj.cloneFormElements( selBoxes ),
				baseParams: {a: "print"}
			});
			
			form.submit();
			form.destructor();
		});
	},

	/**
	 * Initialize the 'With selected...' and 'More...' buttons 
	 * that toggle the corresponding buttons groups
	 */
	initButtonGroupTogglers: function() {
		var pageObj = this,
			zIndex = Runner.genZIndexMax(),
			buttonClass =  this.makeClassName( "button" ), 
			$selectButtonsGroup = $("#selectButtonsGroup" + this.id),
			$extraButtonsGroup = $("#extraButtonsGroup" + this.id);
		
		$("#extraButtonsToggler" + this.id).add( "#selectButtonsToggler" + this.id ).on('click', function(e) {
			return false;
		});
		
		$selectButtonsGroup.add( $extraButtonsGroup ).css("z-index", zIndex);
		
		$("." + buttonClass, $selectButtonsGroup).on("click", function(e) {
			$selectButtonsGroup.hide();
			pageObj.resetButtonGroupDisplayStyle( $selectButtonsGroup );		
		});	

		$("." + buttonClass, $extraButtonsGroup).on("click", function(e) {
			$extraButtonsGroup.hide();
			pageObj.resetButtonGroupDisplayStyle( $extraButtonsGroup );			
		});		
	},
	
	/**
	 * Initialize the 'Records per page' select element
	 */
	initRecordBlock: function() {
		var submitUrl = Runner.pages.getUrl( this.tName, this.pageType );
		
		$("[id='recordspp" + this.id + "']").on("change", function(e) {
			window.location.href = submitUrl + '?pagesize=' + this.options[ this.selectedIndex ].value;
		});
	},
	
	/**
	 * Initialize the 'Add new' button
	 */
	initAddButton: function() {
		if ( !Runner.pages.PageSettings.getTableData(this.tName, "showAddInPopup") || Runner.isMobile ) {
			return;
		}
		var pageObj = this;
		
		$("a[id=addButton" + this.id + "]").unbind("click").bind("click", function(e) {
			pageObj.hideBrick('message');
			var pageParams = {
				tName: pageObj.tName, 
				pageType: Runner.pages.constants.PAGE_ADD, 
				modal: true, 
				editType: Runner.pages.constants.ADD_POPUP,
				baseParams: {
					parId: pageObj.id,
					table: pageObj.tName,
					editType: Runner.pages.constants.ADD_POPUP
				},
				afterSave: {
					fn: function( respObj, formObj, fieldControls, addPageObj ) {
						if ( respObj.success ) {
							pageObj.inlineAdd.addRowToGrid( respObj, this );
							return;	
						} 
						
						addPageObj.adjustPopWindowHeightByContent();
						$( addPageObj.win.bodyNode.getDOMNode() ).animate( {scrollTop: 0} );
						return false;	
					},
					scope: pageObj
				}
			};
			
			Runner.pages.PageManager.openPage( pageParams );
			return false;
		});
	},
	
	/**
	 * Initialize the 'Admin area' and 'Exit Admin area' buttons 
	 */
	initAdminButton: function() {
		$("a[id=exitAdminArea" + this.id + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl("menu");
		});
		
		$("a[id=adminArea" + this.id + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl("admin_rights_list");
		});
	},

	/**
	 * Get checked checkboxes
	 * @param {number} id 	The page's id 
	 * @return {array}
	 * @intellisense
	 */
	getSelBoxes: function( id ) {
		var selBoxes = [];
		
		$("input[type='checkbox'][id^='check" + id + "_']:checked").each( function() {
			selBoxes.push( this );
		});		
		
		return selBoxes;
	},	
	
	/**
	 * Clone form elements
	 * Now using only for clone elements from grid
	 * @param {object} elems
	 * @return {array}
	 * @intellisense
	 */
	cloneFormElements: function( elems ) {
		var cloneElems = [];
		
		$(elems).each( function(i, n) {
			if (n.type == "checkbox" && !n.checked) {
				return;
			}
			var cln = $('<input type=hidden>')
				.attr( 'name', $(n).attr('name') )
				.val( $(n).val() );
			
			cloneElems.push( cln );
		});
		
		return cloneElems;
	},	
	
	/**
	 * Remove all excessive containers
	 * Disable the page's grid and show the 'loading' message
	 * @param {DOM element} gridElem
	 */
	preparePageForReloading: function( gridElem ) {
		this.delSortHint();
		Runner.pages.ListPage.superclass.preparePageForReloading.call( this, gridElem );
	},
	
	/**
	 * Initialize sorting functionality
	 */
	initSorting: function() {
		var pageObj = this, i, reloadParams;
		
		for (i = 0; i < this.listFields.length; i++) {
			$('[id="order_' + Runner.goodFieldName( this.listFields[i] ) + '_' + this.id + '"]')
				.mouseout( function() {
					pageObj.delSortHint();
				})
				.mousemove( function(e) {
					pageObj.moveSortHint(e);
				})
				.mouseover( function(e) {
					pageObj.addSortHint(e);
				})
				.mousedown( function(e) {
					reloadParams = { orderby: $(this).data("order") };
					if ( e.ctrlKey ) {
						reloadParams.ctrl = 1;
					}
					pageObj.reload(reloadParams);
//					window.location.href = pageObj.getSortUrl( e, $(this).data("href") );
				});
		}
	},
	
	/**
	 * Get sorting url 
	 * @param {object} event
	 * @param {string} pageUrl
	 * @return {string}
	 */	
	getSortUrl: function( event, pageUrl ) {		
		return event.ctrlKey ? pageUrl + '&ctrl=1' : pageUrl; 
	},
	
	/**
	 * Add hint for multiple sorting
	 * @param {object} event
	 */	
	addSortHint: function(e) {
		this.existMultipleHint = true;
		this.showSortHint(e);
	},	
	
	/**
	 * Set coordinates for sorting hint
	 * @param {object} event
	 */
	setCoordinatesSortHint: function(e) {
		var winDim = Runner.getWindowDimensions(),
			scrollX = $(window).scrollLeft(),
			scrollY = $(window).scrollTop(),
			hintY = e.pageY + 20,
			hintX = e.pageX;
					
		if ( hintX + this.multipleHint.width() > winDim.width + scrollX ) {
			hintX -= this.multipleHint.width();
		}
		if ( hintY + this.multipleHint.height() > winDim.height + scrollY ) {
			hintY -= this.multipleHint.height();
		}
		this.multipleHint.css({
			left: hintX + "px",
			top: hintY + "px"
		});
	},
	
	/**
	 * Show hint, it may take some time
	 * @param {object} event
	 */	
	showSortHint: function(e) {
		if ( !this.multipleHint.length ) {
			this.multipleHint = $('<span class="rnr-sorthint"><b>' + Runner.lang.constants.TEXT_CTRL_CLICK + '</b></span>')
				.appendTo("body");
		}
		if ( this.existMultipleHint ) { 
			this.setCoordinatesSortHint(e);
			this.multipleHint.show();
		}
	},
	
	/**
	 * Delete hint for multiple sorting
	 */	
	delSortHint: function() {
		if ( this.multipleHint.length ) {
			this.multipleHint.hide();
			this.existMultipleHint = false;
		}	
	},
	
	/**
	 * Moving hints for multiple sorting
	 * @param {object} event
	 */	
	moveSortHint: function(e) {
		if ( this.multipleHint.length && this.multipleHint.is(":visible") ) {
			this.setCoordinatesSortHint(e);
		}
	},
	
	/**
	 * For the List page with activated Inline edit functionality
	 * add the 'onbeforeunload' handler that will unlock all inline records
	 * if the locking is turned on for the table
	 */	
	initUnlockingOnPageUnload: function() {
		if ( !this.inlineEdit || !this.inlineEdit.isUseLocking ) {
			return;
		}
		
		Runner.pages.PageManager.addUnloadHn( function() {
			var rows = this.rows,
				i;
			
			for (i = 0; i < rows.length; i++) {
				if ( !rows[i].submitted ) {
					this.locking.UnlockRecordInline( this.getKeysForLocking( rows[i] ), true );
				}
			}
		}, this.inlineEdit);
	}		
});

Runner.pages.ListPageAjax = Runner.extend( Runner.pages.ListPage, {
	/**
	 * Base params for ajax reload
	 * @type {object}
	 */
	ajaxBaseParams: null,
	
	constructor: function(cfg) {	
		Runner.pages.ListPageAjax.superclass.constructor.call(this, cfg);
		this.listFields = Runner.pages.PageSettings.getTableData(this.tName, 'listFields');
		
		this.ajaxBaseParams = {
			mode: "ajax",
			id: this.pageId
		};
		
		this.bricksForReload = [
			"details_found", 
			"page_of", 
			"recsperpage", 
			"vrecsperpage", 
			"vdetails_found", 
			"vpage_of", 
			"grid", 
			"pagination", 
			"message", 
			"filterpanel", 
			"search_saving_buttons", 
			"recordcontrol"
		];
	},
	
	initSearch: function() {	
		Runner.pages.ListPageAjax.superclass.initSearch.call( this );
		
		this.searchController.ajaxSubmit = true;
		this.searchController.srchForm.standardSubmit = false; 
		this.searchController.srchForm.baseParams = this.ajaxBaseParams;
		
		this.searchController.srchForm.on("beforeSubmit", function( form ) {
			this.preparePageForReloading();
		}, this);

		this.searchController.on('afterSearch', function( respObj, srchController, srchForm ) {
			Runner.stopLoading();
			this.pageReloadHn( respObj );
		}, this);
		
		this.searchController.srchForm.on('submitFailed', function() {
			Runner.stopLoading();
		}, this);
	},
	
	/**
	* Init the inlineAdd/inlineEdit functionality
	* The initialization code is invoked once when initial page is loaded	
	*/	
	initInline: function() {
		Runner.pages.ListPageAjax.superclass.initInline.call( this );
		this.initInline = Runner.emptyFn;
	},
	
	/**
	 * Reinintialize Inline Add/Edit functionality
	 */	
	reInitInline: function() {		
		this.inlineButtonsIntialized = false;
		
		if ( this.inlineAdd ) {
			this.inlineAdd.reInit( this.controlsMap.gridRows );
			this.inlineAdd.reinitButtons();
		}
		if ( this.inlineEdit ) {
			this.inlineEdit.reInit( this.controlsMap.gridRows );
			this.inlineEdit.reinitButtons();
		}
		
		if ( this.inlineAdd || this.inlineEdit ) {
			( this.inlineAdd || this.inlineEdit ).toggleMassRecButt();  
		}		
	},

	/**
	 * Initialize the 'Records Per Page' select element
	 */	
	initRecordBlock: function() {
		var pageObj = this;
		
		$("[id='recordspp" + this.id + "']").on("change", function(e) {
			var ajaxURL = Runner.pages.getUrl( pageObj.tName, pageObj.pageType ) + "?pagesize=" + $(this).val();
	
			pageObj.preparePageForReloading();
		
			Runner.runnerAJAX( ajaxURL, pageObj.ajaxBaseParams, function( respObj ) {
				pageObj.pageReloadHn( respObj );
			});
		});	
	},
	
	/**
	 * Initialize sorting functionality
	 */
	initSorting: function() {
		var pageObj = this, i;
			
		for (i = 0; i < this.listFields.length; i++) {
			$('[id="order_' + Runner.goodFieldName( this.listFields[i] ) + '_' + this.id + '"]')
				.mouseout( function() {
					pageObj.delSortHint();
				})
				.mousemove( function(e) {
					pageObj.moveSortHint(e);
				})
				.mouseover( function(e) {
					pageObj.addSortHint(e);
				})
				.mousedown( function(e) {					
					var	url = pageObj.getSortUrl( e, $(this).data("href") );
						
					pageObj.preparePageForReloading();
					Runner.runnerAJAX( url, pageObj.ajaxBaseParams, function( respObj ) {
						pageObj.pageReloadHn( respObj )
					});
				});
		}
	},
	
	initDeleteButton: function() {
		var pageObj = this;
		
		$("a[id='delete_selected" + this.id + "']").bind("click", function(e) {
			Runner.Event.prototype.stopEvent(e);
			pageObj.preparePageForReloading();			
			
			var selBoxes = pageObj.getSelBoxes( pageObj.id ),
				form;
				
			if ( selBoxes.length == 0 || !confirm(Runner.lang.constants.TEXT_DELETE_CONFIRM) ) {
				Runner.stopLoading();
				return false;
			}
			form = new Runner.form.BasicForm({
				submitUrl: Runner.pages.getUrl(pageObj.tName, pageObj.pageType)+"?" + $(selBoxes).serialize(),
				standardSubmit: false,
				method: 'POST',
				baseParams: Runner.apply({a: 'delete'}, pageObj.ajaxBaseParams),
				successSubmit: {
					fn: function(respObj, formObj, fieldControls) {
						this.pageReloadHn( respObj );
					},
					scope: pageObj
				}
			});
			
			form.submit();
		});
	},
	
	/**
	 * Init the pagination block
	 */
	initPagination: function() {
		var pageObj = this;
		
		$.each( this.getBrickObjs('pagination'), function( index, brick ) {
			brick.elem.bind("click", function(e) {				
				Runner.Event.prototype.stopEvent(e);		
				
				var $target = $(e.target),
					ajaxURL;
						
				if ( !$target.is("a") ) {
					return false;
				}

				pageObj.preparePageForReloading();
				ajaxURL = Runner.pages.getUrl( pageObj.tName, pageObj.pageType ) + "?goto=" + $target.attr("pageNum")

				Runner.runnerAJAX( ajaxURL, pageObj.ajaxBaseParams, function( respObj ) {
					pageObj.pageReloadHn( respObj )
				});
			});
		});
	
		this.initPagination = Runner.emptyFn;
	},
	
	/**
	 * Add user-defined custom grid styles
	 * @param {string} styles
	 */
	addCustomCss: function( cssRules ) {
		var customCellsStyle = this.gridElem.parent().find(".rnr-cells-css");
		
		if ( customCellsStyle.length ) {
			customCellsStyle.html( cssRules );
			return;
		} 
		customCellsStyle = $('<style class="rnr-cells-css" type="text/css"> ' + cssRules + ' </style>');
		this.gridElem.parent().prepend( customCellsStyle );
	},
	
	/**
	 * @param {number} numberOfRecs
	 * @param {number} recPerPage
	 */
	updateMoreButtonsVisibility: function( numberOfRecs, recPerPage) {
		this.toggleBrick("toplinks_print", numberOfRecs > 0);
		$("#printAll_" + this.id).toggle( numberOfRecs > recPerPage && recPerPage > 0 );
	},
	
	/**
	 * The page's ajax reload handler
	 * @param {Object} respObj
	 */
	pageReloadHn: function( respObj ) {
		Runner.stopLoading();
				
		if ( !respObj || !respObj.success ) {
			this.displayMessage('Submit failed', true, true);
			return;	
		}

		var respControlsMap = respObj["controlsMap"][ this.tName ][ this.pageType ][ this.id ];
				
		Runner.setIdCounter( respObj.idStartFrom );
		Runner.pages.PageSettings.addSettings( this.tName, respObj.settings, false );
		this.controlsMap.gridRows = respControlsMap.gridRows;

		this.destroyVideo();		
		// replace bricks
		this.replaceBricksHTMLWith( this.getBricksHtml( respObj.html ) );
		
		this.toggleBrick( "message", !this.controlsMap.gridRows.length || respObj.usermessage );
		
		this.updateMoreButtonsVisibility( respObj["numberOfRecs"], respObj["recPerPage"] );
		
		this.initGridElem();
		this.initDetails();
		this.initPopupLinks();
		this.initSorting();
		this.initHeaderCheckBox();	
		this.initResize();
		
		this.initDeleteButton();
		this.initExportLink();
		this.initPrintLink();
		this.initSelectAll();
		this.initRecordBlock();
		
		this.searchController.usedSrch = respControlsMap.search && respControlsMap.search.usedSrch;
		if ( this.searchController.usedSrch ) {
			this.searchController.simpleSearchActive = Runner.pages.PageSettings.getTableData( this.tName, "simpleSearchActive" );
		}	
		
		if ( respControlsMap.search ) {
			if( respControlsMap.search.isSearchRequired) {
				this.searchController.toggleResetButton( respControlsMap.search.usedSrch );
			} else {	
				this.searchController.toggleShowAll( respControlsMap.search.usedSrch );
			}	
		}
		
		if ( respControlsMap.filters ) {
			this.searchController.filterContolsData = respControlsMap.filters.controls;
			this.searchController.initFilters();
		}
		
		if ( this.searchSavingEnabled ) {
			this.searchParamsLogger.initSearchSavingButtons();
			this.searchParamsLogger.initSavedSearchesList();
		}
											
		this.reInitInline();

		//add custom cells css rules
		this.addCustomCss( respObj['cellStyles'] );
		
		if ( this.mapManager && respControlsMap.gMaps && respControlsMap.gMaps.isUseGoogleMap ) {
			this.mapManager.init( respControlsMap.gMaps.mapsData );
		}
		
		if ( typeof respObj.viewControlsMap === "object" && respObj.viewControlsMap.controls ) {
			this.reInitViewControls( respObj.viewControlsMap.controls );
		}

		this.fireEvent('afterInit', this, this.proxy, this.pageId);
		if ( !this.useResize ) {
			this.fireEvent('afterPageReady', this, this.proxy, this.pageId);
		}			
	},
	
	/**
	 * Reinitialize view controls
	 * @param {array} viewControls
	 */ 
	reInitViewControls: function( viewControls ) {
		var ctrl, i;

		for (i = 0; i < viewControls.length; i++) {
			viewControls[i].table = this.tName;
			ctrl = Runner.viewControls.ViewControlFabric( viewControls[i], this.pageType, this.pageCont, this );
			ctrl.init();
		}		
	},
	
	initScrollGridBody: Runner.emptyFn
});

Runner.pages.ListPageDP = Runner.extend( Runner.pages.ListPage, {
	
	baseParams: null,	
	
	detCont: null,
	
	useChildCount: true,
	
	masterKeys: null,
	
	hideSaveButt: false,
	
	constructor: function( cfg ) {
		Runner.pages.ListPageDP.superclass.constructor.call(this, cfg);
		// page container must be DOM element!
		this.pageCont = $('#detailPreview' + this.id)[0];
		this.addEvents("beforeSaveDetails", "afterSaveDetails", "afterDeleteDetails", "afterPageReady");
		this.baseParams = this.baseParams || { id: this.pageId };
		
		// add masterKeys to baseParams
		Runner.apply(this.baseParams, this.controlsMap.masterKeys);
	},
	
	init: function() {
		Runner.pages.ListPageDP.superclass.init.call(this);
	
		if (this.beforeSaveDetails) {
			this.on({'beforeSaveDetails': this.beforeSaveDetails});
		}
		if (this.afterSaveDetails) {
			this.on({'afterSaveDetails': this.afterSaveDetails});
		}
		if (this.afterDeleteDetails) {
			this.on({'afterDeleteDetails': this.afterDeleteDetails});
		}
		if (this.saveFailed) {
			this.on({'saveFailed': this.saveFailed});
		}
	},
	/**
	 * Search don't use on dpInline
	 */
	initSearch: Runner.emptyFn,
	
	initScrollGridBody: Runner.emptyFn,
	
	afterPageReady: Runner.emptyFn,
	
	/**
	 * Recalculate a size of the parent scrollable grid
	 */
	recalculationGridSize: function() {
		var parPageObj = Runner.pages.PageManager.getAt( this.baseParams.mastertable, this.parId );
		
		if ( parPageObj && parPageObj.pageType == Runner.pages.constants.PAGE_LIST) {
			parPageObj.recalculationGridSize();
		}
	},
	
	/**
	 * Initialize the 'Delete selected' button
	 */
	initDeleteButton: function() {
		var submitUrl = Runner.getPageUrl(this.shortTName, this.pageType),
			pageObj = this;
		
		$("a[id='delete_selected" + this.id + "']").unbind("click").bind("click", function(e) {
			var selBoxes = pageObj.getSelBoxes( pageObj.id ),
				form;
			
			if ( selBoxes.length == 0 || !confirm( Runner.lang.constants.TEXT_DELETE_CONFIRM ) ) {
				return false;
			}
			
			form = new Runner.form.BasicForm({
				standardSubmit: false,
				submitUrl: submitUrl + "?" + $(selBoxes).serialize(),
				method: 'POST',
				id: pageObj.id,
				baseParams: Runner.apply( {a: 'delete', mode: Runner.pages.constants.MODE_LIST_DETAILS}, pageObj.baseParams ),
				successSubmit: {
					fn: function( respObj, formObj, fieldControls ) {
						this.fireEvent("afterDeleteDetails");
						if ( this.parId ) {
							Runner.pages.PageManager.getById( this.parId ).setRecountFlagForPopup();
						}
						this.pageReloadHn( respObj );
						formObj.destructor();
					},
					scope: pageObj
				}
			});
			
			form.submit();
			return false;
		});
	},
	
	/**
	 * Inintialize Inline Add/Edit basing on page's settings
	 */
	initInline: function() {
		Runner.pages.ListPageDP.superclass.initInline.call( this );
		this.initInline = Runner.emptyFn;
	},
	
	/**
	 * Reinintialize Inline Add/Edit functionality
	 */
	reInitInline: function() {
		this.inlineButtonsIntialized = false;
		
		if ( this.inlineAdd ) {
			this.inlineAdd.reInit( this.controlsMap.gridRows );
		}
		if ( this.inlineEdit ) {
			this.inlineEdit.reInit( this.controlsMap.gridRows );
		}	
	},
	
	/**
	 * Init Inline Edit
	 */
	initInlineEdit: function() {
		if ( this.baseParams.masterpagetype !== Runner.pages.constants.PAGE_EDIT  && this.baseParams.masterpagetype !== Runner.pages.constants.PAGE_LIST ) {
			return;
		}
		
		Runner.pages.ListPageDP.superclass.initInlineEdit.call( this );
		
		if ( !this.inlineEdit ) {
			return;
		}
		
		this.inlineEdit.on("beforeSubmit", function( row, inlineObj, formObj ) {
			// add base params
			Runner.apply( formObj.baseParams, this.masterKeys );
			return this.fireEvent("beforeSave", row, inlineObj, formObj);
		}, this);
		
		this.inlineEdit.on("rowsEdited", function( allVals, fields, allKeys, allRowIds, isEdited ) {
			if ( !this.inlineAdd || !this.inlineAdd.isRowsEditing() ) {
				this.fireEvent("afterSaveDetails", allVals, fields, allKeys, allRowIds, isEdited);
			}
		}, this);
		
		this.inlineEdit.on("submitFailed", function( respObj, hnScope, formObj, fieldControls ) {
			this.fireEvent("saveFailed", respObj, formObj, fieldControls);
		}, this);
		
		this.inlineEdit.on("beforeRequestControls", function( inlineObj, inlineEditRow, reqParams ) {
			Runner.apply( reqParams, this.masterKeys );
		}, this);

		this.inlineEdit.on("validationFailed", function( formObj, fieldControls ) {
			this.validationFailed();
		}, this);	
	},

	/**
	 * @return {object}
	 */
	getInlineAddParams: function() {
		var params = Runner.pages.ListPageDP.superclass.getInlineAddParams.call( this );
		
		params.hideSaveButt = this.hideSaveButt;
		return params;
	},
	
	/**
	 * Init Inline Add
	 */
	initInlineAdd: function() {
		if ( this.baseParams.masterpagetype !== Runner.pages.constants.PAGE_ADD && this.baseParams.masterpagetype !== Runner.pages.constants.PAGE_EDIT 
			&& this.baseParams.masterpagetype !== Runner.pages.constants.PAGE_LIST ) {
			return;
		}		
		
		Runner.pages.ListPageDP.superclass.initInlineAdd.call( this );
		
		if ( !this.inlineAdd ) {
			return;
		}
		
		this.inlineAdd.on("beforeSubmit", function( row, inlineObj, formObj ) {
			// add base params
			Runner.apply( formObj.baseParams, this.masterKeys );
			return this.fireEvent("beforeSave", row, inlineObj, formObj);
		}, this);
		
		this.inlineAdd.on("rowsEdited", function( allVals, fields, allKeys, allRowIds, isEdited, singleSaveBtnPressed ) {
			if ( !this.inlineEdit || !this.inlineEdit.isRowsEditing() || singleSaveBtnPressed ) {
				this.fireEvent("afterSaveDetails", allVals, fields, allKeys, allRowIds, isEdited);
			}
		}, this);
		
		this.inlineAdd.on("submitFailed", function( respObj, hnScope, formObj, fieldControls ) {
			this.fireEvent("saveFailed", respObj, formObj, fieldControls);
		}, this);
		
		this.inlineAdd.on("beforeRequestControls", function( inlineObj, inlineEditRow, reqParams ) {
			Runner.apply( reqParams, this.masterKeys );
		}, this);
		
		this.inlineAdd.on("validationFailed", function( formObj, fieldControls ) {
			this.validationFailed();
		}, this);		
	},

	/**
	 * A stub
	 * Details inlineAdd/InlineEdit rows' validationFailed event handler
	 */
	validationFailed: Runner.emptyFn,
	
	/**
	 * Save all detail records
	 */
	saveAll: function( mKeys ) {
		var saveAllInlines = false;
		if (this.inlineEdit) {
			if (mKeys) {
				Runner.apply(this.inlineEdit.baseParams, mKeys);
				this.inlineEdit.baseParams['mastertable'] = this.masterTName;
			}
			saveAllInlines = true;
			this.inlineEdit.saveAll();
		}
		if (this.inlineAdd) {
			if (mKeys) {
				Runner.apply(this.inlineAdd.baseParams, mKeys);
				this.inlineAdd.baseParams['mastertable'] = this.masterTName;
			}
			saveAllInlines = true;
			this.inlineAdd.saveAll();
		}
		return saveAllInlines;
	},
	
	/**
	 * Initialize sorting functionality
	 */	
	initSorting: function() {
		var pageObj = this, i;
		
		for (i = 0; i < this.listFields.length; i++) {
			$('[id="order_' + Runner.goodFieldName( this.listFields[i] ) + '_' + this.id + '"]').on("click", function(e) {
				var url = pageObj.getSortUrl( e, $(this).data("href") );								
				
				pageObj.preparePageForReloading( pageObj.detCont[0] );					
				Runner.runnerAJAX( url, pageObj.baseParams, function( respObj ) {
					pageObj.pageReloadHn( respObj )
				});
			});
		}
	},
	
	/**
	 * Initialize the pagination block
	 */	
	
	initPagination: function() {
		var pageObj = this;
		$.each( this.getBrickObjs('pagination'), function( index, brick ) {
			brick.elem.bind("click", function(e) {	
				Runner.Event.prototype.stopEvent(e);

				var $target = $(e.target),
					pageNum, url;
					
				if ( !$target.is("a") ) {
					return;
				}

				pageObj.preparePageForReloading( pageObj.detCont[0] );
				pageNum = $target.attr("pageNum");
				
				url = Runner.pages.getUrl(pageObj.tName, pageObj.pageType) + "?goto=" + pageNum;
				// ajax page reload	
				Runner.runnerAJAX( url, pageObj.baseParams, function( respObj ) {
					pageObj.pageReloadHn.call( pageObj, respObj )
				});
			});
		});
	},
	
	pageReloadHn: function( respObj ) {
		Runner.stopLoading( this.detCont[0] );
		
		if ( !respObj.success ) {
			$("#message_block" + this.id).html("Submit failed!");	
		}
				
		this.destroyVideo();
		Runner.setIdCounter( respObj.idStartFrom );
		
		this.detCont.html( respObj.html );
		// set controlsMap
		this.controlsMap = respObj["controlsMap"][ this.tName ][ this.pageType ][ this.pageId ];
		
		this.toggleBrick( "message", this.controlsMap.gridRows.length || respObj.delMess );
		
		this.initGridElem();
		this.initSorting();
		this.initDetails();
		this.initPopupLinks();
		this.initHeaderCheckBox();
		this.initResize();

		this.initPagination();	
		this.initSelectAll();
		this.reInitInline();
		this.initRunnerButtons();
		this.initDeleteButton();
		
		if ( this.mapManager && this.controlsMap.gMaps && this.controlsMap.gMaps.isUseGoogleMap ) {
			this.mapManager.init( this.controlsMap.gMaps.mapsData );
		}
		
		var viewControls, i, ctrl;		
		if ( respObj.viewControlsMap ) {
			viewControls = respObj.viewControlsMap[ this.tName ][ this.pageType ][ this.pageId ].controls || [];
			
			for (i = 0; i < viewControls.length; i++) {
				viewControls[i].table = this.tName;
				ctrl = Runner.viewControls.ViewControlFabric( viewControls[i], this.pageType, this.pageCont, this );
				ctrl.init();
			}
		}	
		if ( !this.useResize ) {
			this.fireEvent('afterPageReady', this, this.proxy, this.pageId);
		}			
	},
	
	/**
	 * Details list page's destructor
	 */
	destructor: function() {
		if ( this.inlineEdit || this.inlineAdd ) {
			( this.inlineEdit || this.inlineAdd ).cancelAll();
		}
		Runner.pages.ListPageDP.superclass.destructor.call( this );
	}
});

Runner.pages.ListPageMobile = Runner.extend( Runner.pages.ListPage, {
	
	morePanel: null,
	
	menuPanel: null,
	
	srchOptDivMobile: null,
	
	bricksArr: null,
	
	bricksArrList: null,
	
	constructor: function( cfg ) {
		Runner.pages.ListPageMobile.superclass.constructor.call(this, cfg);
		
		this.useResize = false;
		
		this.morePanel = $("#more" + this.id);
		this.menuPanel = $("#menu_mobile_" + this.id);
		this.srchOptDivMobile = $(".searchOptions", this.pageCont);
		
		this.bricksArr = [
			"masterinfo_mobile",
			"vmenu_mobile",
			"tableinfo_mobile",
			"search_mobile",
			"vmenu",
			"searchpanel_mobile",
			"backbutton",
			"morelink_mobile",
			"message",
			"grid",
			"filterpanel",
			"pagination",
			"languages",
			"loggedas",
			"details_found",
			"page_of",
			"recsperpage",
			"fulltext_mobile",
			"vmsearch2",
			"cancelbutton_mobile"
		];
		
		this.bricksArrList = [
			"masterinfo_mobile",
			"vmenu_mobile",
			"tableinfo_mobile",
			"search_mobile",
			"morelink_mobile",
			"message",
			"grid",
			"pagination",
			"languages",
			"loggedas",
			"filterpanel",
			"details_found",
			"page_of",
			"recsperpage"
		];
	},
	
	init: function() {	
		Runner.pages.ListPageMobile.superclass.init.call( this );	
		
		this.srchOptDivMobile.show();
		$( window ).bind('hashchange', $.proxy( this.updatePageAppearance, this) );
		
		if ( !window.location.hash ) {
			window.location.hash = "#list";
		} else {
			this.updatePageAppearance();
		}
	},
	
	/**
	 * Update the page's brick visibility basing on window.location.hash value
	 * It's supposed that 'this' context is instance of Runner.pages.ListPageMobile
	 */
	updatePageAppearance: function() {
		if ( window.location.hash == '#search' ) {
			this.showMobileSearchPanel();	
		}
		if ( window.location.hash == '#menu' ) {
			this.showMobileMenu();
		}
		if ( window.location.hash == '#list' ) {
			this.showMobileListPage();
		}
	},
	
	initMoreButton: function() {
		var pageObj = this,
			offsetLeft;
		
		$("#morebutton").unbind("click").bind("click", function(e) {
			if ( !pageObj.morePanel.is(":visible") ) {
				offsetLeft = e.clientX - pageObj.morePanel.width();
				pageObj.morePanel.css({
					left: ( offsetLeft > 0 ? offsetLeft : 0 ) + 5,
					top: e.clientY + 5
				}).show();
			}
			return false;
		});
	},

	initMoreClosePanel: function() {
		var pageObj = this;

		$("#more_close").unbind("click").bind("click", function(e) {
			pageObj.morePanel.hide();
			return false;
		});
	},
	
	/**
	 * Show the mobile menu page
	 */
	showMobileMenu: function() {
		if ( window.location.hash !== '#menu' ) {
			return;
		}
		this.hideBricks( this.bricksArr );
		this.showBricks( ["vmenu", "backbutton"] );
		
		Runner.menu.TreeLikeVmenu.prototype.openMenuOnLoad();			
	},
	
	/**
	 * Initialize the 'Back to List' button
	 */ 
	initBackButton: function() {	
		var pageObj = this;
		$("#backbutton").unbind("click").bind("click", function(e) {
			pageObj.showMobileListPage();
		});
	},	
	
	/**
	 * Show the mobile list page
	 */
	showMobileListPage: function() {
		if ( window.location.hash !== '#list' ) {
			return;
		}
		this.hideBricks( this.bricksArr );
		this.showBricks( this.bricksArrList );
	},
	
	/**
	 * Show the mobile Search panel
	 */
	showMobileSearchPanel: function() {
		if ( window.location.hash !== '#search' ) {
			return;
		}
		
		var bricksToShow = this.getSearchBricks();

		this.hideBricks( this.bricksArr );
		this.showBricks( bricksToShow );
	},
	
	/**
	 * Get search bricks to show them on the search page
	 * @return {array}
	 */
	getSearchBricks: function() {
		var searchBricks = ["searchpanel_mobile", "backbutton"];
		
		if ( this.controlsMap.search.googleLikeFields && this.controlsMap.search.googleLikeFields.length ) {
			searchBricks.push( "vmsearch2" );
		}
		
		return searchBricks;
	},
	
	/**
	 * Add click row's click handler to show view/edit links
	 */
	initRowClick: function() {
		var pageObj = this,
			flyButtons = $("div[id^='gridRow'][name='flybutton']");
		
		if ( !flyButtons.length ) {
			return; 
		}
		
		$("td, th", "tr[id^='gridRow']")
			.not("[ieditcont='checkBox'], [ieditcont='all'], [class~='rnr-cg']")
			.unbind("click")
			.bind("click", function(e) {
				var $target = $(e.target),
					trId, currentFlyButton, isVisible;
				
				if ( $target.is("a") || $target.parents().hasClass("projekktor") ) {
					return;
				}
				
				trId = $(this).closest("tr[id^='gridRow']").attr("id");		
				currentFlyButton  = $("div#" + trId);
				isVisible = currentFlyButton.is(':visible');
					
				if ( !isVisible ) {
					currentFlyButton.css("left", e.pageX + 5);			
					if ( !pageObj.isScrollGridBody || pageObj.recsPerRowList > 1 ) {
						currentFlyButton.css("top", e.pageY + 5);
					}
				} 
				
				flyButtons.hide();				
				currentFlyButton.toggle( !isVisible );	
			}
		);
	},
	
	/**
	 * @param {jQuery Event object} e
	 */
	largeTextOpenerDelegate: function(e) {
		this.largeTextOpenerDelegateMobile(e);
	},

	/**
	 * Init the 'Select/Unselect all' button or checkbox
	 */
	initSelectAll: function() {
		var pageObj = this,
			selectAll = $('#select_all' + this.id),
			useCaption;
			
		if ( !selectAll.length ) {
			return false;
		}
		
		useCaption = Runner.pages.PageSettings.getTableData(this.tName, "listGridLayout") !== Runner.pages.constants.HORIZONTAL_LAYOUT;
		selectAll[0].checkAllStatus = false;
		
		selectAll.on("click", function(e) {
			this.checkAllStatus = !this.checkAllStatus;
			$('input[type=checkbox][id^=check'+pageObj.id+'_]').prop("checked", this.checkAllStatus);
	
			if ( useCaption ) {
				$(this).html( this.checkAllStatus ? Runner.lang.constants.UNSELECT_ALL : Runner.lang.constants.SELECT_ALL );
			}
	
			if (e.stopImmediatePropagation) {
				e.stopImmediatePropagation();
			}
			pageObj.morePanel.hide();
		});
	},
	
	initSorting: function() {
		var pageObj = this, i;
		
		for (i = 0; i < this.listFields.length; i++) {
			$('[id="order_' + Runner.goodFieldName( this.listFields[i] ) + '_' + this.id + '"]')
				.click( function(e) {
					window.location.href = pageObj.getSortUrl( e, $(this).data("href") );
				});
		}
	},
	
	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		Runner.pages.ListPageMobile.superclass.initButtons.call(this);
		
		this.initRowClick();
		this.initMoreButton();
		this.initMoreClosePanel();
		this.initBackButton();
	}
});
Runner.pages.ListPageMobileDP = Runner.extend( Runner.pages.ListPageDP, {

	bricksArr: null,
	
	bricksArrList: null,
	
	constructor: function( cfg ) {
		Runner.pages.ListPageMobileDP.superclass.constructor.call(this, cfg);
		
		this.initLargeTextBackButtonMobileDP();
		this.useResize = false;
		
		this.bricksArr = [
			"backbutton",
			"morelink_mobile",
			"message",
			"grid",
			"fulltext_mobile"
		];
		
		this.bricksArrList = [
			"morelink_mobile",
			"message",
			"grid",
		];
	},
	
	pageReloadHn: function( respObj ) {
		Runner.pages.ListPageMobileDP.superclass.pageReloadHn.call( this, respObj );
		
		this.initLargeTextBackButtonMobileDP();
	},
	
	/**
	 * @param {jQuery Event object} e
	 */
	largeTextOpenerDelegate: function(e) {
		this.largeTextOpenerDelegateMobile(e);
	}
});
Runner.pages.ReportPageMobile = Runner.extend( Runner.pages.ListPageMobile, {
	
	pageType: Runner.pages.constants.PAGE_REPORT,
	
	constructor: function( cfg ) {
		Runner.pages.ReportPageMobile.superclass.constructor.call( this, cfg );
		
		this.bricksArr = [
			"masterinfo_mobile", 
			"vmenu_mobile", 
			"tableinfo_mobile", 
			"search_mobile", 
			"vmenu", 
			"searchpanel", 
			"backbutton", 
			"message", 
			"report",
			"filterpanel",			
			"pagination", 
			"languages", 
			"loggedas", 
			"vmsearch2",
			"fulltext_mobile",
			"crosscontrols"
		];
		
		this.bricksArrList = [
			"masterinfo_mobile", 
			"vmenu_mobile", 
			"tableinfo_mobile", 
			"search_mobile", 
			"message", 
			"report", 
			"filterpanel",
			"pagination", 
			"languages", 
			"loggedas",
			"crosscontrols"
		];
		
	},
	
	init: function() {
		Runner.pages.ReportPageMobile.superclass.init.call( this );
		this.fireEvent('afterInit', this, this.proxy, this.id);
		
		$( this.getBrickElem('report') ).bind( "click", $.proxy( this.reportClickHn, this ) );
		
		Runner.pages.ReportPage.prototype.initCrossTableGroupSelection.call(this);
	},
	
	reportClickHn: function(e) {
		this.largeTextOpenerDelegate(e);
	},
	
	getPaginationLink: function( pageNum, linkText, cls ) {
		return '<a href="#" pageNum="' + pageNum + '" ' + ( cls ? 'class="pag_n"' : '' ) + ' style="text-decoration: none;">' + linkText + '</a>';
	},
	
	initAdvSearch: function() {
		var pageObj = this;
		$("#advButton" + this.pageId).bind("click", function(e) {
			window.location.href = Runner.getPageUrl(pageObj.shortTName, "search", pageObj.initCrossTableParams());
		});
	},
	
	/**
	 * initRowClick don't use on report
	 */
	initRowClick: Runner.emptyFn,
	
	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		this.initBackButton();
	},
	
	/**
	 * Get search bricks to show them on the search page
	 * @return {array}
	 */
	getSearchBricks: function() {
		var searchBricks = ["searchpanel", "backbutton"];
		
		if ( this.controlsMap.search.googleLikeFields && this.controlsMap.search.googleLikeFields.length ) {
			searchBricks.push( "vmsearch2" );
		}
		
		return searchBricks;
	}	
});
/**
 * The report page class
 */
Runner.pages.ReportPage = Runner.extend( Runner.pages.DataPageWithSearch, {
	
	pageType: Runner.pages.constants.PAGE_REPORT,

	/**
	 * The corresponding dashboard element's name
	 * It's contains reference to Runner.pages.DashboardPage object
	 * when the page is open on a dashboard
	 * @type {string}
	 */
	dashElement: null,	
	
	crossTable: false,
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.ReportPage.superclass.constructor.call( this, cfg );
		
		this.crossTable = Runner.pages.PageSettings.getTableData( this.tName, "crossTable" );
	},
	
	/**
	 * Initialize the page
	 */
	init: function() {
		Runner.pages.ReportPage.superclass.init.call( this );
		this.fireEvent('afterInit', this, this.proxy, this.id);
		
		if ( this.pageMode !== Runner.pages.constants.LIST_DASHBOARD ) {
			this.initAdvSearch();
			this.initPrintFrLink();
			this.initExcelLink();
			this.initWordLink();
			this.initPDFLink();
			
			this.initAdminButton();
			this.initDetails();
			this.initPopupLinks();
		}
		
		this.initLinksMore();
		this.initMaps();
		
		this.initCrossTableGroupSelection();
	},
		
	/**
	 * Initialize popup link to details pages
	 * (not in use)
	 */
	initPopupLinks: function() {
		if ( Runner.isMobile || typeof this.dpObjs === "undefined") {
			return;
		}
		
		var pageObj = this, 
			detTables = Runner.pages.PageSettings.getTableData(pageObj.tName, "detailTables"),
			masterMouseOver = function() {
				var linkId = $( this ).attr('id'),
					shortTName = linkId.match(/^[^_]+_(.*)_[^_]+$/)[1], 
					rowId = linkId.match(/_([^_]+)$/)[1], 
					masterKeys = {},
					page, tName, row, requestUrl, detTName;
					
				for ( detTName in detTables ) {
					if ( Runner.pages.PageSettings.getShortTName( detTName ) == shortTName ) {
						page = detTables[ detTName ].pageType;
						tName = detTName;
						break;
					}
				}
				
				if ( !tName ) {
					return;
				}
				
				$.each( pageObj.dpObjs[ tName ].rows, function( index, tRow ) {
					if ( tRow.id == rowId ) {
						row = tRow;
						return false;
					}
				});
				
				if ( !row ) {
					return;
				}
				
				$.each( row.masterKeys, function( mKey, mKeyValue ) {
					masterKeys[ mKey ] = mKeyValue || "";
				});
				
				page = page === Runner.pages.constants.PAGE_LIST ? 'detailspreview' : page;
				requestUrl = Runner.getPageUrl( shortTName, page );
				pageObj.dpObjs[ tName ].showPopup( this, requestUrl, pageObj.tName, masterKeys );
			};

		$.each( this.dpObjs, function( tName, tObj ) {			
			if ( detTables[ tName ].listShowType == Runner.pages.constants.DP_NONE ) {
				return;
			}
			
			var detailLink = $( "a[id^='master_" + tObj.shortTName + "']", pageObj.getBrickGridElem() );
			
			if ( Runner.isDirRTL() ) {
				detailLink.attr("dir", $("html").attr("dir") );
			}
			
			detailLink.unbind('mouseover').unbind('mouseout')
				.bind({
					mouseover: masterMouseOver,
					mouseout: $.proxy( tObj.hidePopup, tObj )
				});
		});
	},
	
	reportClickHn: function(e) {
		this.largeTextOpenerDelegate(e);
	},
	
	initLinksMore: function() {
		var bindedReportClickHn = $.proxy( this.reportClickHn, this );
		$( this.getBrickElem('report') ).bind( "click", bindedReportClickHn );		
		$( this.getBrickElem('masterinfo') ).unbind("click").bind("click", bindedReportClickHn);
	},
		
	getPaginationLink: function( pageNum, linkText, cls ) {
		return '<a href="#" pageNum="' + pageNum + '" ' + ( cls ? 'class="pag_n"' : '' ) + ' style="text-decoration: none;">' + linkText + '</a>';
	},
	
	initAdvSearch: function() {
		var pageObj = this;
		$("a[id=advButton" + this.pageId + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl(pageObj.shortTName, "search", pageObj.initCrossTableParams());
			return false;
		});
	},
	
	initPrintFrLink: function() { 
		var pageObj = this;
		$("a[id=print_" + this.pageId + "]").bind("click", function(e) {
			window.open( Runner.getPageUrl(pageObj.shortTName, "print", pageObj.initCrossTableParams()), 'wPrint' );
			return false;
		});
	},
	
	initPrintAll: function() {
		var pageObj = this;
		$("a[id=printAll_" + this.pageId + "]").bind("click", function(e) {
			window.open(Runner.getPageUrl(pageObj.shortTName, "print", "all=1"),'wPrint');
		});
	},

	initExcelLink: function() {
		var pageObj = this;
		$("a[id=export_to_excel" + this.pageId + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl(pageObj.shortTName, "print", "all=1&format=excel&" + pageObj.initCrossTableParams());
			return false;
		});
	},
	
	initWordLink: function() {
		var pageObj = this;
		$("a[id=export_to_word" + this.pageId + "]").bind("click", function(e) {
			window.location.href = Runner.getPageUrl(pageObj.shortTName, "print", "all=1&format=word&" + pageObj.initCrossTableParams());
			return false;
		});
	},
	
	initPDFLink: function() {
		var pageObj = this;
		$("a[id=export_to_pdf" + this.pageId + "]").bind("click", function(e) {
		
			/* exportPdf #9868 */
			window.open(Runner.getPageUrl( pageObj.shortTName, "print", "all=1&exportPdf=1&" + pageObj.initCrossTableParams() ), 'wPrint');

			return false;
		});
	},

	/**
	 * Initialize the 'Admin area' button 
	 */
	initAdminButton: function() {		
		$("a[id=adminArea" + this.id + "]").on("click", function(e) {
			window.location.href = Runner.getPageUrl("admin_rights_list");
		});
	},
	
	/**
	 * Add the crosstab params to advanced search link
	 */
	initCrossTableParams: function() {
		if ( !$("#select_group_x" + this.id).length ) {
			return "";
		}

		var pos, pos2, grfunc_value,
			axis_x = $("#select_group_x" + this.id).val(),
			axis_y = $("#select_group_y" + this.id).val(),
			field = $("#select_data" + this.id).val(),
			shref = window.location.href,
			begin_pos = shref.indexOf("?", 0);
		
		if ( begin_pos >= 0 ) {
			shref = shref.substr( begin_pos + 1);
			pos = shref.indexOf("&axis_x", 0);
			if ( pos >= 0 ) {
				shref = shref.substr(0, pos);
				pos2 = shref.indexOf("a=", 0);
				if ( pos2 >= 0 ) {
					shref = shref.substr( pos2 );
				}
			}
		} else {
			shref = "";
		}
		
		grfunc_value = $("input[name='group_func" + this.id + "']:checked").val();
		grfunc_value = grfunc_value === undefined ? 0 : grfunc_value;
		
		return "axis_x=" + axis_x + "&axis_y=" + axis_y + "&field=" + field + "&group_func=" + grfunc_value + "&" + shref;
	},
	
	/**
	 * Init the Google maps functionality using the Runner.GmapLoader instance
	 */
	initMaps: function() {
		if ( !this.controlsMap.gMaps || !this.controlsMap.gMaps.isUseGoogleMap || !Runner.globalGmapLoader ) {
			return false;
		}
		
		Runner.globalGmapLoader.onLoad( function() {		
			this.mapManager = new Runner.controls.MapManager( this.controlsMap.gMaps );		
			this.mapManager.init();
		}, this );
	},
	
	/**
	 * Reload the crosstab report page when a group field is changed
	 */
	initCrossTableGroupSelection: function() {
		if ( !this.crossTable && !Runner.isMobile ) {
			return;
		}
		
		if ( this.pageMode === Runner.pages.constants.LIST_DASHBOARD && this.dashboard ) {
			this.initDashCrossTableGroupSelection();
			return;
		}

		var reportFileName = Runner.getPageUrl( this.shortTName, this.pageType );
		
		$("#select_group_x" + this.id).on("change", function(e) {
			window.location.href = reportFileName + "?axis_x=" + $(this).val();
		});
		
		$("#select_group_y" + this.id).on("change", function(e) {
			window.location.href = reportFileName + "?axis_y=" + $(this).val();
		});			

	},
	
	/**
	 * Reload the crosstab report page on the dash when a group field is changed
	 */	
	initDashCrossTableGroupSelection: function() {
		if ( !this.crossTable || this.pageMode !== Runner.pages.constants.LIST_DASHBOARD || !this.dashboard ) {
			return;
		}
		
		var pageObj = this,
			reportDashElems = this.dashboard.getDashElements( this.tName, Runner.pages.constants.DASHBOARD_REPORT, this.dashElement );
		
		$("#select_group_x" + this.id).on("change", function(e) {
			var additionalPageParams = {
					baseParams: {
						axis_x: $(this).val(),
						criteria: pageObj.baseParams.criteria,
						q: pageObj.baseParams.q
					}
				};
				
			// reload the page
			Runner.pages.PageManager.unregister( pageObj.tName, pageObj.pageId );
			pageObj.dashboard.loadPage( reportDashElems[0], additionalPageParams );			
		});
		
		$("#select_group_y" + this.id).on("change", function(e) {
			var additionalPageParams = {
					baseParams: {
						axis_y: $(this).val(),
						criteria: pageObj.baseParams.criteria,
						q: pageObj.baseParams.q
					}
				};
				
			// reload the page
			Runner.pages.PageManager.unregister( pageObj.tName, pageObj.pageId );
			pageObj.dashboard.loadPage( reportDashElems[0], additionalPageParams );
		});	
	}
});
Runner.pages.ChartPageMobile = Runner.extend( Runner.pages.ListPageMobile, {
	
	pageType: Runner.pages.constants.PAGE_CHART,
		
	constructor: function( cfg ) {
		Runner.pages.ChartPageMobile.superclass.constructor.call(this, cfg);
		
		this.bricksArr = [
			"masterinfo_mobile", 
			"vmenu_mobile", 
			"charttableinfo_mobile", 
			"search_mobile", 
			"vmenu", 
			"searchpanel", 
			"backbutton", 
			"message", 
			"chart",
			"filterpanel",	
			"languages", 
			"vmsearch2",
			"loggedas"
		];
		
		this.bricksArrList = [
			"masterinfo_mobile", 
			"vmenu_mobile", 
			"charttableinfo_mobile", 
			"search_mobile", 
			"message", 
			"chart",
			"filterpanel",	
			"languages", 
			"loggedas"
		];
	},
	
	init: function() {
		Runner.pages.ChartPageMobile.superclass.init.call( this );
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	initButtons: Runner.emptyFn,
	
	/**
	 * Get search bricks to show them on the search page
	 * @return {array}
	 */
	getSearchBricks: function() {
		var searchBricks = ["searchpanel", "backbutton"];
		
		if ( this.controlsMap.search.googleLikeFields && this.controlsMap.search.googleLikeFields.length ) {
			searchBricks.push( "vmsearch2" );
		}
		
		return searchBricks;
	}	
});
/**
 * The chart page class
 */
Runner.pages.ChartPage = Runner.extend( Runner.pages.DataPageWithSearch, {
	
	pageType: Runner.pages.constants.PAGE_CHART,
	
	
	/**
	 * @constructor
	 * @param {object} cfg 
	 */
	constructor: function(cfg) {
		Runner.pages.ChartPage.superclass.constructor.call(this, cfg);
	},
	
	init: function() {
		Runner.pages.ChartPage.superclass.init.call(this);
		
		this.initLinksMore();
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	chartClickHn: function(e) {
		this.largeTextOpenerDelegate(e);
	},
	
	initLinksMore: function() {
		var bindedChartClickHn = $.proxy( this.chartClickHn, this );
		$( this.getBrickElem('masterinfo') ).unbind("click").bind("click", bindedChartClickHn);
	},
	
	initDetails: Runner.emptyFn
});
Runner.pages.ChartPageDP = Runner.extend( Runner.pages.ChartPage, {
	/**
	 * An object containing detail chart params
	 * @type {object}
	 */
	pageParams: null,
	
	
	constructor: function( cfg ) {
		Runner.pages.ChartPageDP.superclass.constructor.call(this, cfg);
	},
	
	/**
	 * Initialize a detail chart
	 */
	init: function() {
		this.initDPChart();
	}
});

Runner.pages.ChartPageMobileDP = Runner.extend( Runner.pages.ChartPageMobile, {
	/**
	 * An object containing detail chart params
	 * @type {object}
	 */
	pageParams: null,
	
	
	constructor: function( cfg ) {
		Runner.pages.ChartPageMobileDP.superclass.constructor.call(this, cfg);
		
		this.hideBricks( ["backbutton"] );
	},
	
	/**
	 * Initialize a detail chart
	 */
	init: function() {
		this.initDPChart();
	}
});

/**
 * The chart dash page class
 */
Runner.pages.ChartPageDash = Runner.extend( Runner.pages.ChartPage, {
	/**
	 * @type {object}
	 */
	baseParams: null,
	
	/**
	 * @type {boolean}
	 */
	dependentElementsVisible: false,
	
	/**
	 * @constructor
	 * @param {object} cfg 
	 */
	constructor: function(cfg) {
		Runner.pages.ChartPageDash.superclass.constructor.call(this, cfg);
		
		this.addEvents( "afterPageReady" );
	},
	
	init: function() {
		Runner.pages.ChartPageDash.superclass.init.call(this);
		
		if ( this.pageMode == Runner.pages.constants.LIST_DASHDETAILS ) {
			return;
		}
		
		if ( this.getDependentElements().length ) {
			this.loadDependencies();
			this.dashboard.toggleDependentElements( this.getDependentElements(), this.dependentElementsVisible );
		}
	},
	
	/**
	 * @param {object} mesterKeys
	 */
	loadDependencies: function( mesterKeys ) {
		if ( this.pageMode == Runner.pages.constants.LIST_DASHDETAILS ) {
			return;
		}
		
		var pageObj = this,
			i, dependents,
			masterkey = {},
			params = { 
				parentGrid: this,
				baseParams: {} 
			};
		
		dependents = this.getDependentElements();
		
		for ( i = 0; i < dependents.length; ++i ) {
			if ( dependents[i].type == Runner.pages.constants.DASHBOARD_DETAILS ) {
				// unregister current details
				this.dashboard.unregisterDashDetailsPage( dependents[i].details, dependents[i].elementName );
				
				//	read master key values
				$.each( dependents[i].details, function( detailId, detail ) {
					masterkey[ detail.dDataSourceTable ] = mesterKeys ? mesterKeys[ detail.dDataSourceTable ] || {} : {};
				});
				this.dashboard.loadDetails( dependents[i], params, masterkey );
			} else {
				//unregister a dependant page
				this.dashboard.unregisterDashPage( dependents[i].table, this.dashboard.getElementPageType( dependents[i].type ), dependents[i].elementName );
				
				this.dashboard.loadPage( dependents[i], jQuery.extend( true, {}, params ) );
			}
		}
	},
	
	/**
	 * Check if there are dependent elements in the dashboard and return it
	 * @return {array}
	 */
	getDependentElements: function() {
		var dependents = this.dashboard.getDashElements( this.tName, [Runner.pages.constants.DASHBOARD_DETAILS] );
		
		this.getDependentElements = function() { 
			return dependents;
		};
		
		return dependents;
	}
});
Runner.pages.ReportPageDP = Runner.extend( Runner.pages.ReportPage, {
	
	baseParams: null,
	
	constructor: function( cfg ) {
		Runner.pages.ReportPageDP.superclass.constructor.call(this, cfg);
		this.pageCont = $('#detailPreview' + this.id)[0];
		this.addEvents("afterPageReady");
		this.baseParams = this.baseParams || { id: this.pageId };
		// add masterKeys to baseParams
		Runner.apply(this.baseParams, this.controlsMap.masterKeys);
	},
	
	init: function() {
		Runner.pages.ReportPageDP.superclass.init.call(this);
		this.loadFiles();
	},

	initSearch: Runner.emptyFn,
	
	preparePageForReloading: function( gridElem ) {
		Runner.runLoading( "", gridElem || this.gridElem);
	},
	
	initPagination: function() {
		var pageObj = this;
		$.each( this.getBrickObjs('pagination'), function( index, brick ) {
			brick.elem.bind("click", function(e) {	
				Runner.Event.prototype.stopEvent(e);

				var $target = $(e.target),
					pageNum, url;
					
				if ( !$target.is("a") ) {
					return;
				}

				pageObj.preparePageForReloading( pageObj.detCont[0] );
				pageNum = $target.attr("pageNum");
				
				url = Runner.pages.getUrl(pageObj.tName, pageObj.pageType) + "?goto=" + pageNum;
				// ajax page reload	
				Runner.runnerAJAX( url, pageObj.baseParams, function( respObj ) {
					pageObj.pageReloadHn.call( pageObj, respObj )
				});
			});
		});
	},
	
	pageReloadHn: function( respObj ) {
		Runner.stopLoading( this.detCont[0] );
		Runner.setIdCounter( respObj.idStartFrom );
		
		this.detCont.html( respObj.html );
		this.controlsMap = respObj["controlsMap"][ this.tName ][ this.pageType ][ this.pageId ];
		this.initPagination();

		if ( this.mapManager && this.controlsMap.gMaps && this.controlsMap.gMaps.isUseGoogleMap ) {
			this.mapManager.init( this.controlsMap.gMaps.mapsData );
		}

		var viewControls, i, ctrl;		
		if ( respObj.viewControlsMap ) {
			viewControls = respObj.viewControlsMap[ this.tName ][ this.pageType ][ this.pageId ].controls || [];
			
			for (i = 0; i < viewControls.length; i++) {
				viewControls[i].table = this.tName;
				ctrl = Runner.viewControls.ViewControlFabric( viewControls[i], this.pageType, this.pageCont, this );
				ctrl.init();
			}
		}	
	},

	destructor: function() {
		Runner.pages.ReportPageDP.superclass.destructor.call( this );
	}
});

Runner.pages.ReportPageMobileDP = Runner.extend( Runner.pages.ReportPageDP, {
	
	bricksArr: null,
	
	bricksArrList: null,
	
	constructor: function( cfg ) {
		Runner.pages.ReportPageMobileDP.superclass.constructor.call(this, cfg);
		
		this.initLargeTextBackButtonMobileDP();
		this.useResize = false;
		
		this.bricksArr = [
			"backbutton",
			"morelink_mobile",
			"message",
			"report",
			"fulltext_mobile"
		];
		
		this.bricksArrList = [
			"morelink_mobile",
			"message",
			"report",
		];
	},
	
	/**
	 * @param {jQuery Event object} e
	 */
	largeTextOpenerDelegate: function(e) {
		this.largeTextOpenerDelegateMobile(e);
	}
});

Runner.pages.PrintPageCommon = Runner.extend( Runner.pages.RunnerPage, {
		
	pageType: Runner.pages.constants.PAGE_PRINT,
	
	pageHeight: Runner.pages.constants.VPRINT_PAGE_HEIGHT,
	
	pageWidth: Runner.pages.constants.VPRINT_PAGE_WIDTH,
	
	repeatClass: "rp-repeat",
	
	hideClass: "rp-hide",
	
	tableClass: "rp-maintable",
	
	pageNoClass: "rp-pageno",
	
	noPrintClass: "rp-noprint",
	
	pageCountClass: "rp-pagecount",
	
	loadingPrintClass: "rnr-loading-print",
	
	divideIntoPagesLoadingClass: "divideintopagesloading",
	
	divideIntoPagesButtonClass: "divideintopages",
	
	zoom: 100,

	preSplit: false,

	autoZoom: false,
	
	edgeClass: "rnr-edge",
	
	contentWidth: Runner.pages.constants.VPRINT_PAGE_WIDTH,
	
	/**
	 * The storage of pages' objects
	 * @type {array}
	 */
	pages: [],
	
	/**
	 * The print page's layout type
	 * @type {number}
	 */
	layout: 0,
	
	/**
	 * PDF Fit to page
	 */
	pdfFitToPage: 1,
	
	/**
	 * PDF split by records. 0 - split on client, otherwise - at server.
	 */
	pdfSplitByRecords: 0,
	/**
	 * Submit splited page's data
	 * to the pdf converter connector
	 * @type {boolean}
	 */
	createPdf: false,
	
	/**
	 * The flag indicating that pdf generating
	 * must be started automatically through an iframe elem
	 * (with params createPdf = true)
	 * @type {boolean}
	 */
	exportPdf: true,
	
	/**
	 * The flag indicating that 
	 * pdf generating is turned on for the page
	 * @type {boolean}
	 */
	hasPdf: false,
	
	/**
	 * The flag indicating that 
	 * RTL is turned on for the page
	 * @type {boolean}
	 */
	isRTL: false,
	
	$noPrintElements: null,
	
	getContentWidth: function() {
		return $(".rnr-center").width();
	},
	
	init: function()
	{
		Runner.pages.PrintPageCommon.superclass.init.call( this );

		var pageObj = this;
		this.contentWidth = this.getContentWidth();
		if( this.preSplit && this.autoZoom )
		{
			//	set zoom to each page individually
			$(".rp-page").each( function(i, page) {
				var $page = $(page),
					wZoom = 100.0 * pageObj.pageWidth / $page.width(),
					hZoom = 100.0 * pageObj.pageHeight / $page.height(),
					zoom = hZoom < wZoom ? hZoom : wZoom;
				if( zoom > 120 )
					zoom = 120;
				$page.addClass( "page" + i );
				$("<style>@media print { .page" + i + " { zoom:" + zoom + "%;} }</style>").appendTo( document.head );
			});
		
		}
		else
		{
			if( this.autoZoom ) {
				this.zoom = 100.0 * this.pageWidth / this.contentWidth;
				this.zoom = this.zoom > 120.0 ? 120.0 : this.zoom;
			}

			this.pageWidth *= ( 100.0 / this.zoom );
			this.pageHeight *= ( 100.0 / this.zoom );
			$("<style>@media print { body { zoom:" + this.zoom + "%;} }</style>").appendTo( document.head );
			
		}
		
		this.setPrintOrientation();
	},
	constructor: function(cfg) {
		Runner.pages.PrintPageCommon.superclass.constructor.call( this, cfg );	
		this.createPdf = this.proxy.createPdf;
		if( this.createPdf )
		{
			this.zoom = Runner.pages.PageSettings.getTableData( this.tName, "pdfPrinterPageScale" );
			this.autoZoom = Runner.pages.PageSettings.getTableData( this.tName, "pdfFitToPage" );
			this.landscapeOrientation = Runner.pages.PageSettings.getTableData( this.tName, "pdfPrinterPageOrientation" );
			//	the page would not be called in the in createPdf mode if presplit
			this.preSplit = false;
		}
		else
		{
			this.zoom = Runner.pages.PageSettings.getTableData( this.tName, "printerPageScale" );
			this.autoZoom = Runner.pages.PageSettings.getTableData( this.tName, "isPrinterPageFitToPage" );
			this.landscapeOrientation = Runner.pages.PageSettings.getTableData( this.tName, "printerPageOrientation" );
			this.preSplit = Runner.pages.PageSettings.getTableData( this.tName, "printerSplitRecords" ) != 0;
		}
		this.layout = Runner.pages.PageSettings.getTableData( this.tName, "printGridLayout" );
		if( this.landscapeOrientation ) {
			this.pageWidth = Runner.pages.constants.HPRINT_PAGE_WIDTH;
			this.pageHeight = Runner.pages.constants.HPRINT_PAGE_HEIGHT;
		}
		this.pdfFitToPage = Runner.pages.PageSettings.getTableData( this.tName, "pdfFitToPage" );
		this.exportPdf = Runner.pages.PageSettings.getTableData( this.tName, "exportPdf" );
		this.hasPdf = Runner.pages.PageSettings.getTableData( this.tName, "printerPagePDF" );
		this.isRTL = Runner.pages.PageSettings.getTableData( this.tName, "isRTL" );
		this.pdfSplitByRecords = Runner.pages.PageSettings.getTableData( this.tName, "printerPDFSplitRecords" );
	},
	
	/**
	 * creates a new print page
	 * @return {object}
	 */
	newPage: function() {
		var tableClass = this.tableClass;
		
		return {
			$page: $( "<div class=rp-page></div>" ),
			height: 0,
			$tbody: function() {
				return this.$page.find( "." + tableClass + " > tbody" ).first();
			}
		};
	},
	
	
	/**
	 * Add page after idx page
	 * @param {number} insertAfterIdx
	 * @param {boolean} cloneTableOnly
	 * @return {number}					An index of the new page object in this.pages
	 */
	addPage: function( insertAfterIdx, cloneTableOnly ) {
		var newPage = this.newPage();
		
		if ( typeof insertAfterIdx == "undefined" ) {
			insertAfterIdx = this.pages.length - 1;
			newPage.$page.appendTo( document.body );
		} else {
			this.pages[ insertAfterIdx ].$page.after( newPage.$page );
		}
		
		insertAfterIdx++;
		
		this.pages.splice( insertAfterIdx, 0, newPage );
		this.cloneBranch( this.pages[0].$page, newPage.$page, cloneTableOnly );
		newPage.height = newPage.$page.height();
		
		return insertAfterIdx;
	},
	
	/**
	 * Copy elements to the new page
	 * @param {jQuery object} $from
	 * @param {jQuery object} $to
	 * @param {boolean} skipRepeat
	 */
	cloneBranch: function( $from, $to, skipRepeat ) {
		var pageObj = this;
		
		$from.children().each( function( i, elem ) {
			var $elem = $( elem ),
				$cloned = null;
			
			if ( $elem.hasClass( pageObj.hideClass ) ) {
				return;
			}
			
			if ( $elem.hasClass( pageObj.tableClass ) ) {
				$cloned = $( Runner.domShallowCopy( elem ) )
					.appendTo( $to )
					.append( !skipRepeat ? $elem.children("THEAD").clone() : $( "<thead></thead>" ) )
					.append( $("<tbody></tbody>") );
				return;
			} 			
			
			if ( $elem.hasClass( pageObj.repeatClass ) ) {
				$elem.clone().appendTo( $to );
			} else if ( $elem.find( "." + pageObj.repeatClass ).length || $elem.find( "." + pageObj.tableClass ).length ) {
				$cloned = $( Runner.domShallowCopy( elem ) ).appendTo( $to );
				pageObj.cloneBranch( $elem, $cloned, skipRepeat );
			}
		});
	},
	
	/**
	 * Create the new page object and move 
	 * all the print page's content to its $page element.
	 * Append $page element to document.body
	 */
	addFirstPage: function() {
		var newPage = this.newPage();
		
		$( document.body ).children( ":not(meta):not(script):not(style):not(title):not(link):not(iframe)" )
			.appendTo( newPage.$page );
		
		newPage.$page.appendTo( document.body );
		
		this.pages.push( newPage );
	},
	
	/**
	 * Split horizontal table by rows
	 */
	splitTableByRows: function() {
		var pageObj = this,
			currentPageId = 0,
			$rows = [],
			firstPageTop, firstPageHeight, $table, firstPageAddOn,
			rowsSelector = this.layout == Runner.pages.constants.COLUMNS_LAYOUT ? "." + this.tableClass : "." + this.tableClass + " > TBODY";
		
		Runner.Async.loop( [null], function() {
			firstPageHeight = pageObj.pages[0].$page.height();
			firstPageTop = pageObj.pages[0].$page.offset().top;
			$table = pageObj.pages[0].$page.find( "." + pageObj.tableClass );
			firstPageAddOn = firstPageHeight + firstPageTop - ( $table.offset().top + $table.height() );
			pageObj.pages[ 0 ].$page.find( rowsSelector ).children().each( function( i, row ) {
				$rows.push( $( row ) );
			});
		});
		
		Runner.Async.loop( $rows, function( i, $row ) {
			$row.height( $row.height() + 'px' );
			
			// Set height of cells (for PDF)
			$row.children().each( function( cellId, cell ) {
				var $cell = $( cell );
				$cell.height( $cell.height() + 'px' );
			});
			
			if ( 0 == currentPageId && $row.offset().top + $row.height() - firstPageTop + firstPageAddOn < pageObj.pageHeight ) {
				return;
			}
				
			if ( 0 == currentPageId || currentPageId > 0 && $row.height() + pageObj.pages[ currentPageId ].$page.height() > pageObj.pageHeight ) {
				currentPageId = pageObj.addPage();
			}
			
			if ( pageObj.layout == Runner.pages.constants.COLUMNS_LAYOUT ) {
				$row = $row.children();
			}
			
			pageObj.pages[ currentPageId ].$tbody().append( $row );
		});
	},
	
	/**
	 * Copy table columns to the $dstTable jQuery table object passed
	 * @param {jQuery object} $srcTable
	 * @param {jQuery object} $dstTable		
	 * @param {number} startCol
	 */
	copyTableColumns: function( $srcTable, $dstTable, startCol ) {
		var pageObj = this;
		
		$.each( ["thead", "tbody"], function( _i, tag ) {
			var $rows = $srcTable.children( tag ).children(),
				$rowContainer = null;
			
			if ( 0 == $rows.length ) {
				return;
			}
			
			// create new row container (THEAD or TBODY)
			$rowContainer = $( Runner.domShallowCopy( $srcTable.children( tag ).get(0) ) )
				.appendTo( $dstTable );
			
			$rows.each( function( _i, row ) {
				// create new row
				var $dstRow = $( Runner.domShallowCopy( row ) ).appendTo( $rowContainer );
				// move cells
				$( row ).children().slice( startCol ).appendTo( $dstRow );
				$( row ).children().last().addClass( pageObj.edgeClass );
			});
		});
	},
	
	/**
	 * Copy the columns out of view port to the next page
	 */
	splitTableByColums: function() {
		if( this.autoZoom )
			return;
		var pageObj = this;
		
		Runner.Async.loop( this.pages, function( idx, page ) {
			Runner.Async.loop( page.$page.find( "." + pageObj.tableClass + " > thead > tr" ).children(), function( col, cell ) {
				var $cell = $( cell ), 
					newPageId;
					
				$cell.width( $cell.width() + "px" );
				if ( pageObj.getLeftOffset( $cell ) + $cell.width() < pageObj.pageWidth || $cell.hasClass( pageObj.edgeClass ) ) {
					return;
				}
				
				// all collums out of view port are available through  pageObj.pages array under the next index
				newPageId = pageObj.addPage( idx, true );
				pageObj.copyTableColumns( page.$page.find( "." + pageObj.tableClass ), pageObj.pages[ newPageId ].$page.find( "." + pageObj.tableClass ), col );
				
				return false;
			});
		});
	},
	
	/**
	 * Set page numbers to all pages
	 */
	setPageNumbers: function() {
		var pageObj = this;
		
		Runner.Async.loop( [null], function() {
			var idx, $h1;
			
			for ( idx = 0; idx < pageObj.pages.length; ++idx ) {
				$h1 = pageObj.pages[ idx ].$page.find( "h1" );
				
				$h1.css( "height", $h1.height() + "px" );
				pageObj.pages[ idx ].$page.find( "." + pageObj.pageNoClass ).text( idx + 1 );
			}
			
			$( "." + pageObj.pageCountClass ).text( pageObj.pages.length );
		});
	},
	
	/**
	 * Set the print page's orientation
	 */
	setPrintOrientation: function() {
		if ( Runner.pages.PageSettings.getTableData( this.tName, "printerPageOrientation" ) !== Runner.pages.constants.PORTRAIT_PRINT_ORIENTATION ) {
			$( "link:first" ).before( '<style type="text/css" media="print">@page { size: landscape; }</style>' );
		}
	},
	
	/**
	 * Set page width and height for pdf fit to page
	 */
	setPdfFitToPageParams: function() {
		if ( !this.createPdf || !this.pdfFitToPage ) {
			return;
		}
		
		var scale = this.pageHeight / this.pageWidth,
			$table = $( "." + this.tableClass ).first();
		
		this.pageWidth = $table.width() + this.getLeftOffset( $table );
		this.pageHeight = this.pageWidth * scale;
	},
	
	/**
	 * Init PDF functionality
	 */
	initPdf: function() {
		var pageObj = this,
			$pdfLink = $( ".pdflink" );
		
		if ( !pageObj.hasPdf ) {
			return;
		}
		
		if ( pageObj.createPdf ) {
			Runner.Async.loop( jQuery.proxy(pageObj.convertPdfFile, pageObj) );
			return;
		}
			
		// initialize the 'view PDF' link
		if( !this.pdfSplitByRecords ) {
		
			$pdfLink.click( function(e) {
				pageObj.openPrintPdfPageInIframe();
				$pdfLink.hide();
				return false;
			});
		} else {
			$pdfLink.click( function(e) {
				pageObj.getPdfFile();
				$pdfLink.hide();
				return false;
			});
		}

		if ( pageObj.exportPdf ) {
			pageObj.getPdfFile();
			$pdfLink.hide();

//			pageObj.openPrintPdfPageInIframe();
		}
	},
	
	/**
	 * Create loading for divide into pages
	 */
	createDivideIntoPagesLoading: function() {
		if ( this.createPdf ) {
			return;
		}
		
		$( ".rnr-page" ).first().prepend(
			'<div class="' + this.loadingPrintClass + " " + this.divideIntoPagesLoadingClass + " " + this.noPrintClass + '">'
				+ Runner.getLoadingBlock( Runner.lang.constants.PREPARE_PAGE_FOR_PRINTING ) +
			'</div>'
		);
	},
	
	/**
	 * Destroy loading for divide into pages
	 */
	destroyDivideIntoPagesLoading: function() {
		if ( this.createPdf ) {
			return;
		}
		
		var pageObj = this;
		
		Runner.Async.loop( [null], function() {
			$( "." + pageObj.divideIntoPagesLoadingClass ).remove();
		});
	},
	
	/**
	 * Open the page in an invisible iframe elem
	 * to generate a pdf file
	 */
	openPrintPdfPageInIframe: function() {
		$( "<iframe></iframe>" )
			.css( {
				position: "absolute",
				top: "-10000px",
				width: $(window).width() + "px",
				height: $(window).height() + "px",
			} )
			.appendTo( "body" )
			.attr( "src", window.location.href + ( window.location.href.indexOf( "?" ) >= 0 ? "&" : "?" ) + "pdf=prepare" );
		
		// set the "Building PDF...." message
		$( ".rnr-page" ).first().prepend(
			'<div class="' + this.loadingPrintClass + " " + this.noPrintClass + '">'
			+ Runner.getLoadingBlock( Runner.lang.constants.TEXT_PDF_BUILD1 )
			+ '</div>'
		);
	},
	
	/**
	 * Return left offset jQuery object considering RTL
	 * @param {object} $obj
	 * @return {number}
	 */
	getLeftOffset: function( $obj ) {
		if ( this.isRTL ) {
			return $( window ).width() - ( $obj.offset().left + $obj.outerWidth() );
		} else {
			return $obj.offset().left;
		}
	},
	
	afterPagesDivided: function() {
	//	improve only screen representation of divided page
		if( this.createPdf )
		{
			$(".rp-page").last().css("page-break-after","auto");
			return;
			
		}
		$(document.body).addClass("rp-divided");
		$("<style>@media screen { .rp-page{ width:" + (this.pageWidth + 20) + "px;height:" + (this.pageHeight + 20) + "px }} </style>").appendTo( document.head );
		$("<style>@media print { .rp-page{ width:" + (this.pageWidth ) + "px;height:" + (this.pageHeight ) + "px }} </style>").appendTo( document.head );
		if( this.$noPrintElements )
			this.$noPrintElements.css('display','');
	},


	/**
	 * Upload splitted html to server and get pdf file
	 */
	getPdfFile: function() {
		var connector = window.location.href.indexOf('?') >= 0 ? '&' : '?',
			action, timer, 
			cookie = "x" + Math.floor( Math.random()*10000000 ).toString();

		// set the "Building PDF...." message
		$( ".rnr-page" ).first().prepend(
			'<div class="' + this.loadingPrintClass + " " + this.noPrintClass + '">'
			+ Runner.getLoadingBlock( Runner.lang.constants.TEXT_PDF_BUILD1 )
			+ '</div>'
		);

			
		action = window.location.href.replace(/#/g,'') + connector + "pdf=build&width=" + this.contentWidth + "&rndval=" + cookie;
		
		//	strip off all SCRIPT tags
		$("<iframe id=pdfiframe name=pdfiframe></iframe>")
			.css({ 
				position: "absolute",
				top: "-1000px"
			})
			.appendTo("body");
			
		$( "<form method='post' style='display:none' target=pdfiframe action='" + action + "'></form>")
			.appendTo( "body" )
			.submit();
		timer = setInterval(function() {
			if(get_cookie("pdfDownloaded") == cookie) {
				window.parent.$( ".rnr-loading-print" ).remove(); 
				clearInterval(timer);
			}
		}, 500);
	},

	
	/**
	 * Upload splitted html to server and get pdf file
	 */
	convertPdfFile: function() {
		var connector = window.location.href.indexOf('?') >= 0 ? '&' : '?',
			action, timer, 
			cookie = "x" + Math.floor( Math.random()*10000000 ).toString();
		
		action = Runner.getPageUrl( this.shortTName, "print", "pdf=convert&width=" + this.pageWidth + "&rndval=" + cookie);
		
		//	strip off all SCRIPT tags
		$("script").remove();
		$("<iframe id=pdfiframe name=pdfiframe></iframe>")
			.appendTo("body");
			
		$( "<form method='post' style='display:none' target=pdfiframe action='" + action + "'>" 
			+ "<textarea name='htmlPdfContent'>" 
				+ "<html>" + $( "html" ).html() + "</html>" 
			+ "</textarea>" 
		+ "</form>")
			.appendTo( "body" )
			.submit();
		timer = setInterval(function() {
			if(get_cookie("pdfDownloaded") == cookie) {
				window.parent.$( ".rnr-loading-print" ).remove(); 
				clearInterval(timer);
			}
		}, 500);
	}
});
Runner.pages.PrintPage = Runner.extend( Runner.pages.PrintPageCommon, {
	
	constructor: function(cfg) {
		Runner.pages.PrintPage.superclass.constructor.call( this, cfg );
//		this.setPdfFitToPageParams();
	},
	
	init: function() {
		Runner.pages.PrintPage.superclass.init.call( this );
		
		if ( !$( "." + this.tableClass ).length ) {
			return;
		}
		
		if ( this.createPdf ) {
			this.divideIntoPages();
		}
		
		this.initDivideIntoPagesButton();
		this.initPdf();
		
		this.fireEvent( 'afterInit', this, this.proxy, this.id );
	},
	
	/**
	 * Init divide into pages button
	 */
	initDivideIntoPagesButton: function() {
		$( "." + this.divideIntoPagesButtonClass ).click( $.proxy( this.divideIntoPages, this ) );
	},
	
	/**
	 * Divide into pages
	 */
	divideIntoPages: function() {
		var pageObj = this;
		this.$noPrintElements = $("." + this.noPrintClass + ":visible");
		this.$noPrintElements.hide();
		$( "." + this.divideIntoPagesButtonClass ).hide();
		
		this.createDivideIntoPagesLoading();
		this.addFirstPage();
		
		switch ( this.layout ) {
			case Runner.pages.constants.VERTICAL_LAYOUT:
				this.splitVerticalTableByColums();
				this.splitVerticalTableByRows();
				break;
			case Runner.pages.constants.COLUMNS_LAYOUT:
				this.splitColumnsTableByColumns();
				this.splitColumnsTableByRows();
				break;
			default:
				// HORIZONTAL_LAYOUT
				this.splitTableByRows();
				this.splitTableByColums();
		}
		Runner.Async.loop( jQuery.proxy( this.afterPagesDivided, this ) );

		this.setPageNumbers();
		this.destroyDivideIntoPagesLoading();
		
		return false;
	},
	
	/**
	 * Split vertical table by rows
	 */
	splitVerticalTableByRows: function() {
		var pageObj = this,
			verticalTableBody = "td > table > tbody",
			rows = [],
			idx, $newRow, $rowTables, $newRowTables, i, copyTheRest;
		
		Runner.Async.loop( [null], function() {
			pageObj.pages[0].$page.find( "." + pageObj.tableClass + " > TBODY" ).children().each( function( rowId, row ) {
				rows.push( $( row ) );
			});
		});
		
		Runner.Async.loop( rows, function( idx, $row ) {
			if ( $row.height() < pageObj.pageHeight ) {
				return;
			}
			
			// if this row height > pageHeight, split this row into 2 pieces #9699[3]
			$newRow = $row.clone();
			$newRowTables = $newRow.find( verticalTableBody ).empty();
			$row.after( $newRow )
			rows.splice( idx + 1, 0, $newRow );
			$rowTables = $row.find( verticalTableBody );
			
			for ( i = 0; i < $rowTables.length; ++i ) {
				copyTheRest = false;
				
				// move vertical table rows to the second vertical table
				$rowTables.eq( i ).children().each( function( j, vrow ) {
					var $vrow = $( vrow );
					
					if ( ($vrow.offset().top - $row.offset().top + $vrow.height() < pageObj.pageHeight) && !copyTheRest ) {
						return;
					}
					
					copyTheRest = true;
					$vrow.appendTo( $newRowTables[i] );
				});
				
				// delete emtpy tables
				if ( !$newRowTables.eq(i).children().length ) {
					$newRowTables.eq(i).parent().remove();
				}
			}
		});
		
		// pagination
		pageObj.splitTableByRows();
	},
	
	/**
	 * Remove empty rows and set width to all cells
	 */
	clearVerticalTablesAndSetWidth: function() {
		var pageObj = this,
			$table = this.pages[0].$page.find( "." + this.tableClass + " > TBODY" ),
			$rows;
		
		// remove empty columns and rows
		$table.children().remove( ".rnr-rs" );
		$rows = $table.children();
		$rows.find( ".rnr-cs" ).remove();
		
		Runner.Async.loop( $rows, function( rowIdx, row ) {
			$( row ).children().each( function( cellIdx, cell ) {
				var $cell = $( cell );
				$cell
					.data( "width", $cell.width() )
					.data( "offset-left", pageObj.getLeftOffset( $cell ) );
			});
		});
	},
	
	/**
	 * Split vertical table by colums
	 */
	splitVerticalTableByColums: function() {	
		var pageObj = this,
			rows = [],			
			$table, idx, 
			verticalTables, copyTheRest, lastRow, $nextRow;
			
		this.clearVerticalTablesAndSetWidth();
		
		$table = this.pages[0].$page.find( "." + this.tableClass + " > TBODY" );
		
		Runner.Async.loop( [null], function() {
			$table.children().each( function( rowId, row ) {
				rows.push( $( row ) );
			});
		});
		
		Runner.Async.loop( rows, function( idx, $row ) {
			verticalTables = [];
			copyTheRest = false;
			lastRow = idx === rows.length - 1;
			
			// if vertical table width goes beyond the print width
			$row.children().each( function( i, cell ) {
				var $cell = $( cell );
				
				$cell.css( "min-width", $cell.data( "width" ) + "px" );
				if ( ( $cell.data( "offset-left" ) + $cell.data( "width" ) < pageObj.pageWidth || i == 0 ) && !copyTheRest ) {
					return;
				}
				
				copyTheRest = true;
				verticalTables.push( $cell );
			});
			
			// move vertical tables to next row
			if ( verticalTables.length ) {
				if ( lastRow ) {
					// if last row add new row
					$nextRow = $( "<tr></tr>" ).appendTo( $table );
					rows.push( $nextRow );
				} else {
					$nextRow = rows[ idx + 1 ]; 
				}
				
				while ( verticalTables.length ) {
					$nextRow.prepend( verticalTables.pop() );
				}
			}
		});
	},
	
	/**
	 * Split columns table by rows
	 */
	splitColumnsTableByRows: function() {
		var pageObj = this,
			records = [], 
			$newRecord, 
			recordRows, copyTheRest, $recordRow;
		
		Runner.Async.loop( [null], function() {
			pageObj.pages[0].$page.find( "." + pageObj.tableClass ).children().each( function( recordId, record ) {
				records.push( $( record ) );
			});
		});
		
		// split records
		Runner.Async.loop( records, function( idx, $record ) {
			if ( $record.height() < pageObj.pageHeight ) {
				return;
			}
			
			$newRecord = $record.clone();
			$newRecord.find( ".rnr-row" ).empty();
			$record.after( $newRecord )
			records.splice( idx + 1, 0, $newRecord );
			recordRows = $record.find( ".rnr-row" );
			
			recordRows.each( function( idx ) {
				copyTheRest = false;
				$recordRow = recordRows.eq( idx );
					
				if ( ( $recordRow.offset().top - $record.offset().top + $recordRow.height() < pageObj.pageHeight ) && !copyTheRest ) {
					return;
				}
				
				copyTheRest = true;
				$recordRow.appendTo( $newRecord );
			});
		});
		
		// pagination
		this.splitTableByRows();
	},
	
	/**
	 * Set width to all records
	 */ 
	setWidthColumnsTables: function() {
		var pageObj = this;
		
		Runner.Async.loop( this.pages[0].$page.find( "." + this.tableClass ).children(), function( recordIdx, record ) {
			$( record ).find( ".rnr-row > td" ).each( function( recordCellIdx, recordCell ) {
				var $recordCell = $( recordCell );
				$recordCell
					.data( "width", $recordCell.width() )
					.data( "offset-left", pageObj.getLeftOffset( $recordCell ) );
			});
		});
	},
	
	/**
	 * Split columns table by columns
	 */
	splitColumnsTableByColumns: function() {
		var pageObj = this,
			records = [];
		
		this.setWidthColumnsTables();
		
		Runner.Async.loop( [null], function() {
			pageObj.pages[0].$page.find( "." + pageObj.tableClass ).children().each( function( recordIdx, record ) {
				records.push( $( record ) );
			});
		});
		
		Runner.Async.loop( records, function( recordIdx, $record ) {
			var $recordRows = $record.find( ".rnr-row" ),
				recordRowCellsCount = Math.round( $record.find( "tr:nth-child(2)" ).children().length / 2 ),
				recordRowCellsCountArr = new Array( recordRowCellsCount ),
				allCells = [], splitCell = 1,
				i, rowsPerRecord, edgeRecord;
			
			if ( $record.width() < pageObj.pageWidth ) {
				return;
			}
			
			// get all cells from record
			Runner.Async.loop( recordRowCellsCountArr, function( j ) {
				$recordRows.each( function( recordRowIdx, recordRow ) {
					var $recordRow = $( recordRow ),
						recordRowCells = $recordRow.children(),
						$recordRowCellLabel = recordRowCells.eq( j * 2 ),
						$recordRowCellValue = recordRowCells.eq( j * 2 + 1 );
					
					$recordRowCellLabel.width( $recordRowCellLabel.data( "width" ) + "px" );
					$recordRowCellValue.width( $recordRowCellValue.data( "width" ) + "px" );
					
					if ( $recordRowCellValue.data( "offset-left" ) + $recordRowCellValue.data( "width" ) > pageObj.pageWidth && splitCell == 1 && j > 0 ) {
						splitCell = j;
					}
					
					if ( $recordRowCellLabel.html() != "&nbsp;" ) {
						allCells.push( $recordRowCellLabel );
						allCells.push( $recordRowCellValue.removeClass( pageObj.edgeClass ) );
					}
				});
			});
			
			// reorganize record and set cells 
			Runner.Async.loop( [null], function() {
				$recordRows.remove();
				rowsPerRecord = Math.ceil( Math.ceil( allCells.length / 2 ) / splitCell );
				edgeRecord = rowsPerRecord * splitCell * 2 - rowsPerRecord * 2;
				$record.find( "tr:first > td:first" )
					.attr( "colspan", splitCell * 2 );
				
				for ( i = 0; i < rowsPerRecord; ++i ) {
					$record.append( '<tr class="rnr-row"></tr>' );
				}
				
				i = 0;
				$recordRows = $record.find( ".rnr-row" );
				while ( i < allCells.length ) {
					$recordRows.each( function( recordRowIdx, recordRow ) {
						var emptyCell = "<td>&nbsp;</td>",
							$label = allCells[i] || $( emptyCell ),
							$value = allCells[i + 1] || $( emptyCell );
						
						if ( i >= edgeRecord ) {
							$value.addClass( pageObj.edgeClass );
						}
						
						$( recordRow )
							.append( $label )
							.append( $value );
						
						i += 2;
					});
				}
			});
		});
	}
});
Runner.pages.ReportPrintPage = Runner.extend( Runner.pages.PrintPageCommon, {
		
	pageType: Runner.pages.constants.PAGE_REPORT_PRINT,
	
	tableClass: "rnr-report",
	
	$summaryHeader: null,
	
	$summaryPage: null,
	
	$summaryGlobal: null,
	
	summaryPageHeight: 0,
	
	/**
	 * The print page's mode PRINT FRIENDLY or PRINT WHOLE
	 * @type {number}
	 */
	reportPrintMode: 0,
	
	groupsPerPage: 3,
	
	/**
	 * Partiton type PAGE FIT or FIXED GROUPS
	 */
	partitionType: 0,
	
	reportLayout: 0,
	
	/**
	 * The number of report's group
	 * @type {number}
	 */
	lowGroup: 1,
	
	reportType: 0,
	
	
	constructor: function(cfg) {
		Runner.pages.ReportPrintPage.superclass.constructor.call(this, cfg);
		
		this.reportLayout = Runner.pages.PageSettings.getTableData( this.tName, "reportPrintLayout" );
		this.reportPrintMode = Runner.pages.PageSettings.getTableData( this.tName, "reportPrintMode" );
		this.partitionType = Runner.pages.PageSettings.getTableData( this.tName, "reportPrintPartitionType" );
		this.groupsPerPage = Runner.pages.PageSettings.getTableData( this.tName, "reportPrintGroupsPerPage" );
		this.lowGroup = Runner.pages.PageSettings.getTableData( this.tName, "lowGroup" );
		this.reportType = Runner.pages.PageSettings.getTableData( this.tName, "reportType" );
		
		if ( this.reportLayout == Runner.pages.constants.TABULAR_LAYOUT ) {
			this.tableClass = "rnr-b-report";
		}
		if ( this.reportType == Runner.pages.constants.REPORT_TYPE_CROSSTAB ) {
			this.tableClass = "rnr-cw-grid";
		}
		//	
		this.pdfSplitByRecords = 3;
		this.setPdfFitToPageParams();
	},
	
	init: function() {
		Runner.pages.ReportPrintPage.superclass.init.call( this );
		
		if ( !$( "." + this.tableClass ).length ) {
			return;
		}
		
		if ( this.createPdf ) {
			this.divideIntoPages();
		}
		
		this.initDivideIntoPagesButton();
		this.initPdf();
		
		this.fireEvent( 'afterInit', this, this.proxy, this.id );
	},
	
	/**
	 * Init divide into pages button
	 */
	initDivideIntoPagesButton: function() {
		$( "." + this.divideIntoPagesButtonClass ).click( $.proxy( this.divideIntoPages, this ) );
	},
	
	/**
	 * Divide into pages
	 */
	divideIntoPages: function() {
		
		if ( this.reportType === Runner.pages.constants.REPORT_TYPE_CROSSTAB )
			return false;
		
		$( "." + this.divideIntoPagesButtonClass ).hide();
		this.$noPrintElements = $("." + this.noPrintClass + ":visible");
		this.$noPrintElements.hide();
		
		this.createDivideIntoPagesLoading();
		this.addFirstPage();
			
		this.setTotalsData();
		this.splitReportTableByRows();
		this.splitReportTableByColums();
			
		this.setPageNumbers();

		Runner.Async.loop( jQuery.proxy( this.afterPagesDivided, this ) );
		this.destroyDivideIntoPagesLoading();
		
		return false;
	},
	
	/**
	 * Split horizontal report table by rows
	 */
	splitReportTableByRows: function() {
		if ( this.reportPrintMode == Runner.pages.constants.REPORT_MODE_PRINT_FRIENDLY ) {
			this.splitReportTableOnPrintFriendlyMode();
		} else {
			this.splitReportTableOnPrintWholeMode();
		}
	},
	
	/**
	 * Split horizontal report table by rows on print friendly mode
	 */
	splitReportTableOnPrintFriendlyMode: function() {
		var pageObj = this;
		
		this.splitTableByRows();
		Runner.Async.loop( [null], function() {
			pageObj.setTotalsDataToPage( pageObj.pages.length - 1, pageObj.$summaryHeader );
			pageObj.setTotalsDataToPage( pageObj.pages.length - 1, pageObj.$summaryPage );
			pageObj.setTotalsDataToPage( pageObj.pages.length - 1, pageObj.$summaryGlobal );
		});
	},
	
	/**
	 * Split horizontal report table by rows on print whole report mode
	 */
	splitReportTableOnPrintWholeMode: function() {
		var pageObj = this;
		
		if ( this.partitionType == Runner.pages.constants.REPORT_PRINT_PAGE_FIT ) {
			this.splitReportTableByRowsPageFit();
			Runner.Async.loop( [null], function() {
				pageObj.calculatePageSummary( pageObj.lowGroup );
			});
		} else {
			this.splitReportTableByRowsPerPrintedPage();
			Runner.Async.loop( [null], function() {
				pageObj.calculatePageSummary( 1 );
			});
		}
	},
	
	/**
	 * Calculate page summary for whole report mode
	 * @param {number} groupLevel
	 */
	calculatePageSummary: function( groupLevel ) {
		var pageObj = this,
			$pageBody, $pageSummary,
			result = {};
		
		Runner.Async.loop( this.pages, function( idx, page ) {
			$pageBody = page.$tbody();
			
			// calculate groups summary and set to result
			$pageBody.find( ".summary-" + groupLevel ).each( function( cellId, cell ) {
				var $cell = $( cell ),
					type = $cell.data( "type" ),
					field = $cell.data( "field" ) || "total",
					value = $cell.data( "value" );
					
				result = pageObj.calculateGroupsSummary( type, field, value, result );
			});
			
			// set result to page summary
			$pageSummary = $pageBody.find( ".page-summary" );
			
			$pageSummary.each( function( cellId, cell ) {
				var $cell = $( cell ),
					type = $cell.data( "type" ),
					field = $cell.data( "field" ) || "total",
					avgValue = 0,
					avgArr, i;
				
				if ( result[ type ] && result[ type ][ field ] ) {
					if ( type == "avg" ) {
						avgArr = result[ type ][ field ];
						for ( i = 0; i < avgArr.length; ++i ) {
							if ( !isNaN( avgArr[ i ] ) ) {
								avgValue += avgArr[ i ];
							}
						}
						
						result[ type ][ field ] = avgValue / avgArr.length;
					}
					
					$cell.html( result[ type ][ field ] );
				}
			});
			
			if ( $pageSummary.length ) {
				result = {};
			}
		});
	},
	
	/**
	 * Calculate groups summary
	 * @param {string} type
	 * @param {string} field
	 * @param {string || number} value
	 * @param {array} result
	 */
	calculateGroupsSummary: function( type, field, value, result ) {
		result[ type ] = result[ type ] || {};
		
		if ( type == "min" || type == "max" ) {
			if ( typeof result[ type ][ field ] == "undefined" && value !== "" ) {
				result[ type ][ field ] = value;
			}
		} else {
			if ( isNaN( result[ type ][ field ] ) ) {
				result[ type ][ field ] = 0;
			}
			if ( isNaN( value ) ) {
				value = 0;
			}
		}
		
		switch ( type ) {
			case "sum":
				result[ type ][ field ] += value;
				break;
			case "max":
				if ( value > result[ type ][ field ] && value !== "" ) {
					result[ type ][ field ] = value;
				}
				break;
			case "min":
				if ( value < result[ type ][ field ] && value !== "" ) {
					result[ type ][ field ] = value;
				}
				break;
			case "avg":
				if ( !result[ type ][ field ] ) {
					result[ type ][ field ] = [];
				}
				result[ type ][ field ].push( value );
				break;
			default:
				result[ type ][ field ] = ( result[ type ][ field ] || 0 ) + value;
		}
		
		return result;
	},
	
	/**
	 * Split horizontal report table by rows (per printed page partition type)
	 */
	splitReportTableByRowsPerPrintedPage: function() {
		var pageObj = this,
			$rows, $pageBody,
			pageOffsetTop, pageIdx,
			groupsCount;
		
		Runner.Async.loop( this.pages, function( idx, page ) {
			$pageBody = page.$tbody();
			$rows = page.$page.find( "." + pageObj.tableClass + " > TBODY" ).children();
			groupsCount = 0;
			
			Runner.Async.loop( $rows, function( rowIdx, row ) {
				var $row = $( row );
				
				$row.height( $row.height() + 'px' );
				
				if ( $row.hasClass( "group-spliter-1" ) ) {
					groupsCount++;
				}
				
				if ( groupsCount < pageObj.groupsPerPage + 1 ) {
					return;
				}
				
				pageIdx = pageObj.addPage();
				$pageBody.children().slice( rowIdx )
					.appendTo( pageObj.pages[ pageIdx ].$tbody() );
				
				pageObj.setTotalsDataToPage( idx, pageObj.$summaryPage );
				
				return false;
			});
		});
		
		Runner.Async.loop( [null], function() {
			pageObj.setTotalsDataToPage( pageObj.pages.length - 1, pageObj.$summaryPage );
			pageIdx = pageObj.addPage();
			pageObj.setTotalsDataToPage( pageIdx, pageObj.$summaryHeader );
			pageObj.setTotalsDataToPage( pageIdx, pageObj.$summaryGlobal );
		});
		
		Runner.Async.loop( this.pages, function( idx, page ) {
			pageOffsetTop = page.$page.offset().top;
			$pageBody = page.$tbody();
			$rows = page.$page.find( "." + this.tableClass + " > TBODY" ).children();
			
			if ( $pageBody.height() > pageObj.pageHeight ) {
				$rows.each( function( rowIdx, row ) {
					var $row = $( row );
					
					if ( $row.offset().top + $row.height() - pageOffsetTop < pageObj.pageHeight ) {
						return;
					}
					
					pageIdx = pageObj.addPage( idx, true );
					$pageBody.children().slice( rowIdx ).appendTo( pageObj.pages[ pageIdx ].$tbody() );
					
					return false;
				});
			}
		});
	},
	
	/**
	 * Split horizontal report table by rows (page fit partition type)
	 */
	splitReportTableByRowsPageFit: function() {
		var pageObj = this,
			splitInfo, pageIdx, $pageBody,
			transferOneLowGroup = false;
		
		Runner.Async.loop( this.pages, function( idx, page ) {
			$pageBody = page.$tbody();
			splitInfo = pageObj.getSplitRowPageFit( idx, transferOneLowGroup );
			
			if ( !splitInfo.splitRow ) {
				pageObj.setTotalsDataToPage( idx, pageObj.$summaryHeader );
				pageObj.setTotalsDataToPage( idx, pageObj.$summaryPage );
				pageObj.setTotalsDataToPage( idx, pageObj.$summaryGlobal );
				return false;
			}
			
			pageIdx = pageObj.addPage();
			$pageBody.children().slice( splitInfo.splitRow ).appendTo( pageObj.pages[ pageIdx ].$tbody() );
			
			if ( ( transferOneLowGroup || splitInfo.lowGroupsCount > 1 ) && splitInfo.lowGroupsCount ) {
				pageObj.setTotalsDataToPage( idx, pageObj.$summaryPage );
				transferOneLowGroup = false;
				return;
			}
			
			transferOneLowGroup = true;
		});
	},
	
	/**
	 * Get split row ID and low groups count
	 * @param {number} pageIdx
	 * @param {boolean} returnOnFinedFirstLowGroup		
	 * @return {object}
	 */
	getSplitRowPageFit: function( pageIdx, returnOnFinedFirstLowGroup ) {
		if ( !this.pages[ pageIdx ] ) {
			return;
		}
		
		var pageObj = this,
			pageOffsetTop = this.pages[ pageIdx ].$page.offset().top,
			$rows = this.pages[ pageIdx ].$page.find( "." + this.tableClass + " > TBODY" ).children(),
			lastLowGroupIdx = 0,
			lowGroupsCount = 0,
			splitRow = 0;
		
		$rows.each( function( rowIdx, row ) {
			var $row = $( row );
			
			$row.height( $row.height() + 'px' );
			
			if ( $row.hasClass( "group-spliter-" + pageObj.lowGroup ) ) {
				lastLowGroupIdx = rowIdx;
				lowGroupsCount++;
			}
			
			if ( $row.offset().top + $row.height() + pageObj.summaryPageHeight - pageOffsetTop < pageObj.pageHeight
				&& !( returnOnFinedFirstLowGroup && lowGroupsCount ) ) {
				return;
			}
			
			splitRow = lowGroupsCount > 1 ? lastLowGroupIdx : rowIdx;
			
			return false;
		});
		
		return { 
			lowGroupsCount: lowGroupsCount, 
			splitRow: splitRow 
		};
	},
	
	/**
	 * Copy the report columns out of view port to the next page
	 */
	splitReportTableByColums: function() {
		var pageObj = this,
			groupHeadersClass = this.reportLayout == Runner.pages.constants.TABULAR_LAYOUT ? "table-header" : "group-headers",
			$groupHeaders;
		
		Runner.Async.loop( [null], function() {
			$( "." + groupHeadersClass ).children().each( function( col, cell ) {
				var $cell = $( cell );
				
				$cell.width( $cell.width() + "px" );
				$cell.attr( "data-width", $cell.width() );
			});
			
			$groupHeaders = $( "." + groupHeadersClass ).first().clone();
		});
		
		Runner.Async.loop( this.pages, function( idx, page ) {
			var $cells = [];
			
			if ( !page.$page.find( "." + groupHeadersClass ).children().length ) {
				page.$tbody().prepend( $groupHeaders.clone() );
			}
			
			page.$page.find( "." + groupHeadersClass ).children().each( function( col, cell ) {
				$cells.push( $( cell ) );
			});
			
			Runner.Async.loop( $cells, function( col, $cell ) {
				var newPageId;
				
				if ( pageObj.getLeftOffset( $cell ) + $cell.data( "width" ) < pageObj.pageWidth || $cell.hasClass( pageObj.edgeClass ) ) {
					return;
				}
				
				// all collums out of view port are available through  this.pages array under the next index
				newPageId = pageObj.addPage( idx, true );
				pageObj.copyReportTableColumns( page.$page.find( "." + pageObj.tableClass ),
					pageObj.pages[ newPageId ].$page.find( "." + pageObj.tableClass ),
					( col <= 1 ? 1 : col - 1 ), $groupHeaders.children().length );
					
				return false;
			});
		});
	},
	
	/**
	 * Copy report table columns to the $dstTable jQuery table object passed
	 * @param {jQuery object} $srcTable
	 * @param {jQuery object} $dstTable		
	 * @param {number} startCol
	 * @param {number} columnsCount
	 */
	copyReportTableColumns: function( $srcTable, $dstTable, startCol, columnsCount ) {
		var pageObj = this;
		
		$.each( [ "thead", "tbody" ], function( tagId, tag ) {
			var $rows = $srcTable.children( tag ).children(),
				$rowContainer;
			
			if ( !$rows.length ) {
				return;
			}
			
			// create new row container (TBODY)
			$rowContainer = $( Runner.domShallowCopy( $srcTable.children( tag ).get( 0 ) ) )
				.appendTo( $dstTable );
			
			$rows.each( function( _i, row ) {
				// create new row
				var $dstRow = $( Runner.domShallowCopy( row ) ).appendTo( $rowContainer ),
					$rowCells = $( row ).children();
				
				// move cells
				if ( $rowCells.length < columnsCount ) {
					if ( $rowCells.length > startCol ) {
						$rowCells.slice( startCol ).appendTo( $dstRow );
						$( $rowCells[ startCol - 1 ] ).addClass( pageObj.edgeClass );
						
						$dstRow.children().each( function( cellId, cell ) {
							var $cell = $( cell ),
								hasColspan = $cell.attr( "colspan" ) !== undefined && $cell.attr( "colspan" ) !== false;
							
							if ( hasColspan ) {
								$cell.attr( "colspan", $rowCells.length - startCol );
								
								return false;
							}
						});
					} else {
						$rowCells.each( function( cellId, cell ) {
							var $cell = $( cell ),
								hasColspan = $cell.attr( "colspan" ) !== undefined && $cell.attr( "colspan" ) !== false,
								$newCell;
							
							if ( hasColspan ) {
								$cell.attr( "colspan", startCol - cellId );
								$newCell = $( Runner.domShallowCopy( $cell.get(0) ) );
								$newCell.html( "&nbsp;" )
									.attr( "colspan", columnsCount - startCol )
									.appendTo( $dstRow );
									
								return false;
							}
						});
					}
				} else {
					$rowCells.slice( startCol ).appendTo( $dstRow );
					$( $rowCells[ startCol - 1 ] ).addClass( pageObj.edgeClass );
				}
				
				$rowCells.last().addClass( pageObj.edgeClass );
			});
		});
	},
	
	/**
	 * Set summary rows
	 */
	setTotalsData: function() {
		var	pageObj = this,
			$summaryHeader = $( ".summary-header" ),
			$summaryPage = $( ".summary-page" ),
			$summaryGlobal = $( ".summary-global" );
		
		this.$summaryHeader = $summaryHeader.clone();
		this.$summaryPage = $summaryPage.clone();
		this.$summaryGlobal = $summaryGlobal.clone();
		
		$summaryPage.each( function( idx, elem ) {
			pageObj.summaryPageHeight += $( elem ).height();
		});
		
		$summaryHeader.remove();
		$summaryPage.remove();
		$summaryGlobal.remove();
	},
	
	/**
	 * Set summary data to page
	 * @param {number} pageIdx
	 * @param {jQuery object} $srcElem
	 */
	setTotalsDataToPage: function( pageIdx, $srcElem ) {
		if ( $srcElem.length && this.pages[ pageIdx ] ) {
			this.pages[ pageIdx ].$page.find(  "." + this.tableClass + " > tbody" )
				.append( $srcElem.clone() );
		}
	},

	getContentWidth: function() {
		return $(".rnr-report-gridblock").width();
	}
	

});
Runner.pages.DashboardPage = Runner.extend( Runner.pages.RunnerPage, {
	/**
	 * @type {string}
	 */
	pageType: Runner.pages.constants.PAGE_DASHBOARD,
	
	/** 
	 *  Array of dashboard elements in the form of {elementName, table, type}
	 * @type {array}
	 */
	elements: null,
	
	/** 
	 *  Reference object with various info specific to the element type
	 * @type {object}
	 */
	elementTypeInfo: null,
	
	dynamicPagesData: null,
	
	/**
	 * contains flags visibility
	 * @type {array}
	 */
	elementsVisibility: {},
	
	/**
	 * identifies that details loaded
	 * @type {array}
	 */
	detailsLoadedState: {},
	
	/**
	 * @constructor
	 */
	constructor: function( cfg ) {
		Runner.pages.DashboardPage.superclass.constructor.call(this, cfg);	
		
		this.elements = Runner.pages.PageSettings.getTableData(this.tName, "dashElements");
		this.fillElementTypeInfo();
	},
	
	init: function() {
		Runner.pages.DashboardPage.superclass.init.call( this );
		this.loadElements();

		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	/**
	 * Fills in elementTypeInfo
	 */
	fillElementTypeInfo: function() {
		var constants = Runner.pages.constants;
		if ( this.elementTypeInfo ) {
			return;
		}
		
		this.elementTypeInfo = {};
		this.elementTypeInfo[ constants.DASHBOARD_LIST ] = {pageType: constants.PAGE_LIST, pageRequestMode: "dashlist", pageMode: constants.LIST_DASHBOARD};
		this.elementTypeInfo[ constants.DASHBOARD_CHART ] = {pageType: constants.PAGE_CHART, pageRequestMode: "dashchart", pageMode: constants.LIST_DASHBOARD};
		this.elementTypeInfo[ constants.DASHBOARD_REPORT ] = {pageType: constants.PAGE_REPORT, pageRequestMode: "dashreport", pageMode: constants.LIST_DASHBOARD};
		this.elementTypeInfo[ constants.DASHBOARD_RECORD ] = {pageType: constants.PAGE_EDIT, pageRequestMode: "dashrecord", pageMode: constants.EDIT_DASHBOARD};
		this.elementTypeInfo[ constants.DASHBOARD_SEARCH ] = {pageType: constants.PAGE_SEARCH, pageRequestMode: "dashsearch", pageMode: constants.SEARCH_DASHBOARD};
		this.elementTypeInfo[ constants.DASHBOARD_DETAILS ] = {pageType: constants.PAGE_LIST, pageRequestMode: "dashdetails", pageMode: constants.LIST_DASHDETAILS};
	},
	
	/** 
	 * Loads all the dashboard elements into their respective containers
	 */
	loadElements: function() {
		var pageObj = this;
		
		this.dynamicPagesData = {};
		
		$.each( this.elements, function( ind, dbelem ) {
			pageObj.dynamicPagesData[ dbelem.table ] = pageObj.dynamicPagesData[ dbelem.table ] || {};
			
			if ( dbelem.type === Runner.pages.constants.DASHBOARD_RECORD ) {
				pageObj.loadSingleRecord( dbelem );
				return;
			}
			if ( dbelem.type === Runner.pages.constants.DASHBOARD_DETAILS ) {
				pageObj.loadDetails( dbelem );
				return;
			}
			
			pageObj.loadPage( dbelem );	
		});
	},
	
	/**
	 * fix it
	 * @param {object} dbelem
	 * @param {array} pageTypes
	 * @param {object} additionalPageParams
	 */
	loadSingleRecord: function( dbelem, pageTypes, additionalPageParams ) {
		var pageObj = this;
			
		additionalPageParams = additionalPageParams || {};
		additionalPageParams.openMode = Runner.pages.constants.OPENMODE_TABVIEW;
		
		if ( pageTypes ) {
			pageTypes = $.grep( pageTypes, function( el, idx ) {
				return $.inArray( el, dbelem.tabsPageTypes ) !== -1;
			});
		}
		
		pageTypes = pageTypes || dbelem.tabsPageTypes;
		
		$.each( pageTypes, function( idx, pageType ) {
			additionalPageParams.pageType = pageType;
			
			additionalPageParams.tabSettings = {
				tabIndex: parseInt( idx ),
				tabId: pageType,
				tabLabel: pageObj.getTabLabel(pageType),
				tabControlName: dbelem.elementName,
				activeTab: pageType === dbelem.initialTabPageType
			} 
			
			pageObj.loadPage( dbelem, additionalPageParams );
		});
	},
	
	/**
	 *
	 * @param {string} 
	 * @return {string} 
	 */
	getTabLabel: function(pageType) {
		var _map = {};
		_map[Runner.pages.constants.PAGE_VIEW] = Runner.lang.constants.TEXT_VIEW;
		_map[Runner.pages.constants.PAGE_ADD] = Runner.lang.constants.TEXT_AA_P_ADD;
		_map[Runner.pages.constants.PAGE_EDIT] = Runner.lang.constants.TEXT_EDIT;
		this.getTabLabel = function( pageType ) {
			return _map[pageType];
		};
		return this.getTabLabel( pageType );
	},
	
	/**
	 *
	 * @param {object} dbelem
	 * @param {object} additionalPageParams
	 */
	loadDetails: function( dbelem, additionalPageParams, detailKeys ) {
		var pageObj = this, 
			tables, dkeyParams, params;
			
		additionalPageParams = additionalPageParams || {};
		additionalPageParams.openMode = Runner.pages.constants.OPENMODE_TABVIEW;
		
		additionalPageParams.baseParams = additionalPageParams.baseParams || {};
		additionalPageParams.baseParams["goto"] = additionalPageParams.baseParams["goto"] || 1;
		
		this.resetDetailsLoadState( dbelem );
		
		$.each( dbelem.details , function( ind, details ) {
			pageObj.dynamicPagesData[ details.dDataSourceTable ] = pageObj.dynamicPagesData[ details.dDataSourceTable ] || {};
			
			additionalPageParams.tabSettings = {
				tabIndex: parseInt( ind ),
				tabId: details.dShortTable,
				tabLabel: details.dCaptionTable, 
				tabControlName: dbelem.elementName,
				hideTabsContent: true,
				activeTab: dbelem.initialTabDetailTable === details.dDataSourceTable
			};
			
			additionalPageParams.pageType = details.dType;
			additionalPageParams.tName = details.dDataSourceTable;	
			params = jQuery.extend( true, {}, additionalPageParams );
			
			if ( detailKeys ) {
				jQuery.extend( params.baseParams, detailKeys[ details.dDataSourceTable ] )
				params.baseParams.mastertable = dbelem.table;
			}
			pageObj.loadPage( dbelem, params );
		});
	},
	
	/**
	 * @param {object} dbelem
	 * @param {object} additionalPageParams
	 */
	loadPage: function( dbelem, additionalPageParams ) {	
		var pageParams = this.getDefaultPageParams( dbelem ),
			pageId;		

		additionalPageParams = additionalPageParams || {};
		pageParams = jQuery.extend( true, pageParams, additionalPageParams );
		
		pageId = Runner.pages.PageManager.openPage( pageParams );
		this.setDynamicPageData( pageParams.tName, pageParams.pageType, pageParams.dashElement, pageId );
	},

	/**
	 * @param {object} dbelem	
	 * @return {object}
	 */
	getDefaultPageParams: function( dbelem ) {		
		var params = {
			dashboard: this,
			parentId: this.id,
			pageType: this.getElementPageType( dbelem.type ), 
			pageMode: this.getElementPageMode( dbelem.type ), 
			tName: dbelem.table,
			
			openMode: Runner.pages.constants.OPENMODE_DASHCONTAINER, //
			openContainer: $('#dashelement_' + dbelem.elementName + this.id)[0],
			dashElement: dbelem.elementName,
			dashElementSettings: jQuery.extend(true, {}, dbelem ),
			
			baseParams: {
				parId: this.id,
				table: this.tName,
				dashelement: dbelem.elementName,
				mode: this.getElementPageRequestMode( dbelem.type )
			}
		};
		
		if ( dbelem.type == Runner.pages.constants.DASHBOARD_LIST || dbelem.type == Runner.pages.constants.DASHBOARD_DETAILS ) {
			params.multiRecordPage = true;
		}
		
		return params;
	},
	
	/**
	 * @param {string} type
	 * @return {string}
	 */
	getElementPageType: function( type ) {
		return this.elementTypeInfo[ type ].pageType;
	},
	
	/**
	 * @param {string} type
	 * @return {string}
	 */	
	getElementPageMode: function( type ) {
		return this.elementTypeInfo[ type ].pageMode;
	},
	
	/**
	 * @param {string} type
	 * @return {string}
	 */	
	getElementPageRequestMode: function( type ) {
		return this.elementTypeInfo[ type ].pageRequestMode;
	},

	/**
	 * @param {string} name
	 * @return {object}
	 */	
	getElementByName: function( name ) {
		for (var i = 0; i < this.elements.length; ++i) {
			if ( this.elements[i].elementName == name ) {
				return this.elements[i];
			}
		}
	},
	
	/**
	 * Add a dashboard dynamic page's data 
	 * @param {string} tName
	 * @param {string} pageType
	 * @param {string} elementName
	 * @param {number} pageId
	 */
	setDynamicPageData: function( tName, pageType, elementName, pageId ) {
		if ( typeof this.dynamicPagesData[ tName ] !== "object" ) {
			return;
		}
		
		this.dynamicPagesData[ tName ][ pageType ] = this.dynamicPagesData[ tName ][ pageType ] || {};
		this.dynamicPagesData[ tName ][ pageType ][ elementName ] = pageId;
	},
	
	/**
	 * Get dashboard's dynamic pages' id
	 * @param {string} tName
	 * @param {string} pageType
	 * @param {string} elementName (optional)
	 * @return {array}
	 */
	getDynamicPageIds: function( tName, pageType, elementName ) {
		var pageIds = [],
			pageIdsData, deName;
		
		if ( typeof this.dynamicPagesData[ tName ] !== "object" || typeof this.dynamicPagesData[ tName ][ pageType ] !== "object"  ) {
			return [-1];
		}
	
		if ( elementName !== undefined ) {
			return [ this.dynamicPagesData[ tName ][ pageType ][ elementName ] ];
		}
		
		pageIdsData = this.dynamicPagesData[ tName ][ pageType ];
		for ( deName in pageIdsData ) {
			if ( pageIdsData.hasOwnProperty( deName ) ) {
				pageIds.push( pageIdsData[ deName ] );
			}
		}
		
		return pageIds;
	},
	
	/**
	 * Unregister a dashboard dynamic page
	 * @param {string} tName
	 * @param {string} pageType
	 * @param {string} elementName
	 */
	unregisterDashPage: function( tName, pageType, elementName ) {
		var pageId = this.getDynamicPageIds( tName, pageType, elementName )[0];
		if ( pageId ) {
			Runner.pages.PageManager.unregister( tName, pageId );
		}
	},
	
	/**
	 * Unregister a dashboard dynamic details pages	
	 * @param {array} details
	 * @param {array} details
	 */
	unregisterDashDetailsPage: function( details, elementName ) {
		if ( !details ) {
			return;
		}
		
		for (var i = 0; i < details.length; i++) {
			this.unregisterDashPage( details[i][ "dDataSourceTable" ], details[i][ "dType" ], elementName );
		}
	},
	
	/**
	 * @param {string} table
	 * @param {array} dashTypes
	 * @param {string} elementName (optional)
	 */
	getDashElements: function( table, dashTypes, elementName ) {
		var delements = [];
	
		if ( !this.elements ) {
			return delements;
		}
		
		if ( !Runner.isArray( dashTypes ) ) {
			dashTypes = [ dashTypes ];
		}
		
		$.each( this.elements, function( ind, dbelem ) {
			if ( $.inArray( dbelem.type, dashTypes) !== -1 && dbelem.table === table && (!elementName || dbelem.elementName === elementName) ) {
				delements.push( dbelem );
			}
		});
		
		return delements;
	},
	
	/**
	 * Toggle a dependent element
	 * @param {array} elementSettings
	 * @param {boolean} visible
	 */
	toggleDependentElement: function( elementSettings, visible ) {
		if ( !elementSettings ) {
			return;
		}
		
		// if visible undefined, read flag
		if ( typeof visible === "undefined" ) {
			visible = true;
			if ( elementSettings.elementName in this.elementsVisibility ) {
				visible = this.elementsVisibility[ elementSettings.elementName ];
			}
		}
		
		if ( elementSettings.type == Runner.pages.constants.DASHBOARD_RECORD ) {			
			this.toggleTabsSingleRecord( elementSettings, visible );
			return;
		} 
		
		if ( elementSettings.type == Runner.pages.constants.DASHBOARD_DETAILS ) {			
			if ( visible && !this.allDetailsLoaded( elementSettings.elementName ) ) {
				return;
			}
			
			this.toggleTabsDetails( elementSettings, visible ); 
		}
	},
	
	/**
	 * toggle dependent elements and set visibility flag
	 * @param {object} dependents
	 * @param {boolean} visible
	 */
	toggleDependentElements: function( dependents, visible ) {
		if ( !dependents ) {
			return;
		}
		
		for ( var i = 0; i < dependents.length; ++i ) {
			if ( dependents[i].type !== Runner.pages.constants.DASHBOARD_RECORD && dependents[i].type !== Runner.pages.constants.DASHBOARD_DETAILS ) {
				continue;
			}
			
			// set visibility flag
			this.elementsVisibility[ dependents[i].elementName ] = visible;
			this.toggleDependentElement( dependents[i], visible );
		}
	},
	
	/**
	 * Show/Hide 'view' and 'edit' single record tabs
	 * @param {object} elementSettings
	 * @param {boolean} visible
	 */
	toggleTabsSingleRecord: function( elementSettings, visible ) {
		var $tabsControl = Runner.pages.PageManager.getDashElementTabControl( elementSettings.elementName, this.id ),
			activeTabIdx;
		
		if ( !$tabsControl || !$tabsControl.length || !$tabsControl.data('ui-tabs') ) {
			return;
		}
		
		if ( $.inArray( Runner.pages.constants.PAGE_ADD, elementSettings.tabsPageTypes ) === -1 ) {
			// if the 'add' tab is missed toggle the element's "openContainer"
			$('#dashelement_' + elementSettings.elementName + this.id).toggle( visible );
			return;
		}
		
		// get the active tab's index or use the first tab's index //fix it! ("active" is a zero-based index)
		activeTabIdx = $tabsControl.tabs( "option", "active" ) || $tabsControl.find( "li" ).first().index();
		
		// traverse all tabs and set their visibility
		$.each( elementSettings.tabsPageTypes, function( idx, type ) {
			var $tab = $tabsControl.find( "li[data-rnrtabidx=" + idx + "]" );
			
			if ( type !== Runner.pages.constants.PAGE_ADD ) {
				// toggle 'view' and 'edit' tabs, the 'add' tab is always visible
				$tab.toggle( visible );
			} else if ( !visible || elementSettings.tabsPageTypes.length === 1 ) {
				// if this is the 'add' tab and all other tabs  are hidden or this is a single tab set this tab active
				activeTabIdx = $tab.index();
			}
		});
		
		$tabsControl.tabs( "option", "active", activeTabIdx );	
	},
	
	/**
	 * Show/Hide details tabs
	 * @param {object} elementSettings
	 * @param {boolean} visible
	 */	
	toggleTabsDetails: function( elementSettings, visible ) {
		var $tabsControl = Runner.pages.PageManager.getDashElementTabControl( elementSettings.elementName, this.id ),
			activeTabIdx;
		
		if ( !$tabsControl || !$tabsControl.length || !$tabsControl.data('ui-tabs') ) {
			return;
		}
		
		var	tabIdx = 0; // fix it!
		$.each( elementSettings.details, function( detailId, detail ) {
			tabIdx = detailId;
			return false;
		});		
		
		// get active tab idx, if empty get first tab idx  //fix it! ("active" is a zero-based index)
		activeTabIdx = $tabsControl.tabs( "option", "active" ) || $tabsControl.find( "li[data-rnrtabidx=" + tabIdx + "]" ).first().index();
		
		$.each( elementSettings.details, function( idx, detail ) {
			$tabsControl.find( "li[data-rnrtabidx=" + idx + "]" ).toggle( visible );
		});
		
		if ( visible ) {
			// set active tab as active and show active panel
			$tabsControl.tabs( "option", "active", activeTabIdx );
			$tabsControl.find( ".ui-tabs-panel:eq(" + activeTabIdx + ")" ).show();
		} else {
			// hide all panels
			$tabsControl.find( ".ui-tabs-panel" ).hide();
		}		
	},
	
	/**
	 * Reset details load state
	 * @param {objedt} dbelem
	 */
	resetDetailsLoadState: function( dbelem ) {
		var pageObj = this;
		
		if ( !this.detailsLoadedState[ dbelem.elementName ] ) {
			this.detailsLoadedState[ dbelem.elementName ] = {};
		}
		
		$.each( dbelem.details, function( detailId, detail ) {
			pageObj.detailsLoadedState[ dbelem.elementName ][ detail.dDataSourceTable + detail.dType ] = false;
		});
	},
	
	/**
	 * Return state, that all details for this element loaded
	 * @param {string} elementName
	 * @return {boolean}
	 */
	allDetailsLoaded: function( elementName ) {
		var result = true;
		
		if ( elementName in this.detailsLoadedState ) {
			$.each( this.detailsLoadedState[ elementName ], function( detailName, detailState ) {
				if ( !detailState ) {
					result = false;
					return false;
				}
			});
			
			return result;
		}
		
		return false;
	},
	
	/**
	 * Set detail load state
	 * @param {string} elementName
	 * @param {string} dataSourceTable
	 * @param {string} type
	 * @param {boolean} state
	 */
	setDetailLoadState: function( elementName, dataSourceTable, type, state ) {
		if ( elementName && elementName in this.detailsLoadedState && ( dataSourceTable + type ) in this.detailsLoadedState[ elementName ] ) {
			this.detailsLoadedState[ elementName ][ dataSourceTable + type ] = state;
		}
	}
});
Runner.pages.DashboardPageMobile = Runner.extend( Runner.pages.DashboardPage, {
	
	constructor: function( cfg ) {
		Runner.pages.DashboardPageMobile.superclass.constructor.call( this, cfg );
		
		this.bricksArr = [
			"dashboard_mobile",
			"vmenu_mobile", 
			"tableinfo_dashboard_mobile",
			"search_dashboard_mobile",
			"search_dashboard_m",
			"vmenu",
			"languages",
			"loggedas_mobile",
			"backbutton"
		];
		
		this.bricksArrList = [
			"dashboard_mobile",
			"vmenu_mobile", 
			"tableinfo_dashboard_mobile",
			"search_dashboard_mobile",
			"languages",
			"loggedas_mobile"
		];
	},
	
	init: function() {
		Runner.pages.DashboardPageMobile.superclass.init.call( this );
		
		$( window ).bind('hashchange', $.proxy( this.updatePageAppearance, this) );
		
		if ( !window.location.hash ) {
			window.location.hash = "#list";
		} else {
			this.updatePageAppearance();
		}
		
		this.initBackButton();
	},
	
	/**
	 * Update the page's brick visibility basing on window.location.hash value
	 * It's supposed that 'this' context is instance of Runner.pages.DashboardPageMobile
	 */
	updatePageAppearance: function() {
		if ( window.location.hash == '#search' ) {
			this.showMobileSearchPanel();	
		}
		if ( window.location.hash == '#menu' ) {
			this.showMobileMenu();
		}
		if ( window.location.hash == '#list' ) {
			this.showMobileListPage();
		}
	},
	
	/**
	 * Show the mobile Search panel
	 */
	showMobileSearchPanel: function() {
		if ( window.location.hash !== '#search' ) {
			return;
		}
		
		this.hideBricks( this.bricksArr );
		this.showBricks( ["search_dashboard_m"] );
	},
	
	/**
	 * Show the mobile menu page
	 */
	showMobileMenu: function() {
		if ( window.location.hash !== '#menu' ) {
			return;
		}
		this.hideBricks( this.bricksArr );
		this.showBricks( ["vmenu", "backbutton"] );
		
		Runner.menu.TreeLikeVmenu.prototype.openMenuOnLoad();			
	},
	
	/**
	 * Initialize the 'Back to Dashboard' button
	 */ 
	initBackButton: function() {	
		var pageObj = this;
		$( "#backbutton" ).unbind( "click" ).bind( "click", function(e) {
			pageObj.showMobileListPage();
		});
	},
	
	/**
	 * Show the mobile dashboardpage page
	 */
	showMobileListPage: function() {
		if ( window.location.hash !== '#list' ) {
			return;
		}
		this.hideBricks( this.bricksArr );
		this.showBricks( this.bricksArrList );
	},
});
/**
 * The basic class for dashboard list or detail list page
 */
Runner.pages.ListPageDash = Runner.extend( Runner.pages.ListPage, {
	/**
	 * @type {object}
	 */
	baseParams: null,	
	
	/**
	 * The corresponding dashboard element's name
	 * @type {string}
	 */
	dashElement: null,
	
	/**
	 * @type {boolean}
	 */
	dependentElementsVisible: false,
	
	selectedId: -1,
	
	prefixKeyField: "_selected_key_field",
	
	prefixKeyValue: "_selected_key_value",
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.ListPageDash.superclass.constructor.call(this, cfg);
		
		this.pageCont = $(this.openContainer);
		this.addEvents( "afterPageReady" );
		this.baseParams = this.baseParams || { id: this.pageId };
	},

	/**
	 * Initialize the page
	 */
	init: function() {
		var pageObj = this;
		
		Runner.pages.ListPageDash.superclass.init.call(this);
		
		$( this.gridElem ).removeClass("hoverable");
		
		if ( this.pageMode == Runner.pages.constants.LIST_DASHDETAILS ) {
			return;
		}
		
		if ( this.getDependentElements().length ) {
			this.dependentElementsVisible = !!this.controlsMap.gridRows[0];
			if ( this.controlsMap.gridRows[0] && !this.baseParams.moveToLastRecord ) {
				// if not emty list
				var savedRowId = this.getSavedRowId();
				
				if ( this.isRowInGrid( savedRowId ) ) {
					// select saved record
					this.setSelected( savedRowId );
				} else {
					//	select first record
					this.deleteSavedRowKey();
					this.setSelected( this.controlsMap.gridRows[0].id );
				}
			} else {
				this.deleteSavedRowKey();
			}
			this.dashboard.toggleDependentElements( this.getDependentElements(), this.dependentElementsVisible );
		}
		
		$( this.gridElem ).on( 'click', '[data-record-id]', function() {
			var activeId = $(this).data( 'record-id' );
			
			pageObj.saveRowKey( ( pageObj.inlineAdd || pageObj.inlineEdit ).getRowById( activeId ) );
			pageObj.setSelected( activeId );
		});
	},
	
	/**
	 * Inint Inline Add/Edit basing on page's settings
	 */
	initInline: function() {
		Runner.pages.ListPageDash.superclass.initInline.call();
		
		this.initInlineAdd();
		this.initInlineEdit();
	},
	
	/**
	 * @param {number} recordId
	 */
	setSelected: function( recordId ) {
		if ( this.pageMode == Runner.pages.constants.LIST_DASHDETAILS || this.selectedId == recordId ) {
			return;
		}
		
		this.scrollIntoViewRecord( recordId );
		this.selectedId = recordId;
		$( ".rnr-dbselectedrow", this.gridElem ).removeClass( "rnr-dbselectedrow" );
		$( "[data-record-id=" + recordId + "]", this.gridElem ).addClass( "rnr-dbselectedrow" );
		
		this.loadDependencies();
	},
	
	/**
	 * Set scroll position into view record
	 * @param {number} recordId
	 */
	scrollIntoViewRecord: function( recordId ) {
		var $record = $( "[data-record-id=" + recordId + "]", this.gridElem ),
			$scrollDiv = $( ".rnr-dbelembody", this.pageCont );
		
		if ( !$record || !$scrollDiv ) {
			return;
		}
		
		// if record in viewport
		setTimeout( function() {
			if ( $scrollDiv.offset().top > $record.offset().top || $scrollDiv.offset().top + $scrollDiv.height() < $record.offset().top + $record.height() ) {
				$record.get(0).scrollIntoView();
			}
		}, 500 );
	},
	
	/**
	 * @param {number} recordId
	 * @return {boolean}
	 */
	isRowInGrid: function( recordId ) {
		return !!$( "[data-record-id=" + recordId + "]", this.gridElem ).length;
	},
	
	/**
	 * Return row id by key value
	 * @param keyField
	 * @param keyValue
	 * @return {number}
	 */
	getRowIdByKey: function( keyField, keyValue ) {
		var rows = this.controlsMap.gridRows,
			i;
		
		for (i = 0; i < rows.length; i++) {
			if ( rows[i].keyFields[0] == keyField && rows[i].keys[0] == keyValue ) {
				return rows[i].id;
			}
		}
		return -2;
	},
	
	/**
	 * save row key to cookie
	 */
	saveRowKey: function( row ) {
		set_cookie( this.dashElement + this.prefixKeyField, row.keyFields[0], '', Runner.getCookieRoot() );
		set_cookie( this.dashElement + this.prefixKeyValue, row.keys[0], '', Runner.getCookieRoot() );
	},
	
	/**
	 * get saved row id
	 * @return {number}
	 */
	getSavedRowId: function() {
		var keyField = get_cookie( this.dashElement + this.prefixKeyField ) || '',
			keyValue = get_cookie( this.dashElement + this.prefixKeyValue ) || '';
		
		return this.getRowIdByKey( keyField, keyValue );
	},
	
	/**
	 * delete saved row key from cookie
	 */
	deleteSavedRowKey: function() {
		delete_cookie( this.dashElement + this.prefixKeyField, Runner.getCookieRoot(), '');	
		delete_cookie( this.dashElement + this.prefixKeyValue, Runner.getCookieRoot(), '');
	},
	
	/**
	 * @param {object} row
	 * @param {array} skippedElements
	 */
	loadDependencies: function( row, skippedElementsNames ) {
		var pageObj = this,
			i, selectedRow, dependents,
			params = { 
				rowId: row ? row.id : this.selectedId,
				parentGrid: this,
				baseParams:{} 
			},
			recordParams = jQuery.extend( true, {}, params ),
		
		selectedRow = row || (this.inlineAdd || this.inlineEdit).getRowById( this.selectedId );
		
		if ( selectedRow ) {
			for ( i = 0; i < selectedRow.keys.length; ++i ) {
				recordParams.baseParams[ 'editid' + (i + 1) ] = selectedRow.keys[i];	
			}
		}
		
		dependents = this.getDependentElements();
		
		skippedElementsNames = skippedElementsNames || [];
		
		for ( i = 0; i < dependents.length; ++i ) {
			if ( $.inArray( dependents[i].elementName, skippedElementsNames ) !== -1 ) {
				continue;
			}
			
			if ( dependents[i].type == Runner.pages.constants.DASHBOARD_RECORD ) {
				// unregister current edit, view pages
				this.dashboard.unregisterDashPage( this.tName, Runner.pages.constants.PAGE_EDIT, dependents[i].elementName );
				this.dashboard.unregisterDashPage( this.tName, Runner.pages.constants.PAGE_VIEW, dependents[i].elementName );
				
				this.dashboard.loadSingleRecord( dependents[i], [ Runner.pages.constants.PAGE_EDIT, Runner.pages.constants.PAGE_VIEW ], recordParams );
			} else if ( dependents[i].type == Runner.pages.constants.DASHBOARD_DETAILS ) {
				// unregister current details
				this.dashboard.unregisterDashDetailsPage( dependents[i].details, dependents[i].elementName );
				
				//	read master key values			
				this.dashboard.loadDetails( dependents[i], params, selectedRow.masterKeys );
			} else {
				//unregister a dependant page
				this.dashboard.unregisterDashPage( dependents[i].tName, this.dashboard.getElementPageType( dependents[i].type ), dependents[i].elementName );
				
				this.dashboard.loadPage( dependents[i], jQuery.extend( true, {}, params ) );
			}
		}
	},

	/**
	 * @return {object}
	 */
	getInlineAddParams: function() {
		var params = Runner.pages.ListPageDash.superclass.getInlineAddParams.call( this );
		
		params.dashGridBased = true;
		return params;
	},	
	
	/**
	 * Initialize the inline add functionality
	 */
	initInlineAdd: function() {
		Runner.pages.ListPageDash.superclass.initInlineAdd.call( this );
		
		if ( this.pageMode == Runner.pages.constants.LIST_DASHDETAILS ) {
			return;
		}
		
		this.inlineAdd.on( "afterSubmit", function( vals, fields, keys, rowId, resp, extAddPageObj ) {
			if ( this.selectedId !== rowId ) {
				this.setSelected( rowId );
			} else {
				this.loadDependencies( this.inlineAdd.getRowById( rowId ) ); 
			}
			
			this.dependentElementsVisible = !!this.controlsMap.gridRows[0];
			this.dashboard.toggleDependentElements( this.getDependentElements(), this.dependentElementsVisible );
		}, this );
	},


	/**
	 * @return {object}
	 */
	getInlineEditParams: function() {
		var params = Runner.pages.ListPageDash.superclass.getInlineAddParams.call( this );
		
		params.dashGridBased = true;
		return params;
	},
	
	/**
	 * Initialize the inline edit functionality
	 */
	initInlineEdit: function() {
		Runner.pages.ListPageDash.superclass.initInlineEdit.call( this );
		
		if ( this.pageMode == Runner.pages.constants.LIST_DASHDETAILS || !this.inlineEdit ) {
			return;
		}
		
		this.inlineEdit.on( "afterSubmit", function( vals, fields, keys, rowId, newData, extEditPageObj ) {
			var row = this.inlineEdit.getRowById( rowId ),
				skippedElementsNames = [];
			
			if ( extEditPageObj && extEditPageObj.pageMode === Runner.pages.constants.EDIT_DASHBOARD ) {
				skippedElementsNames.push( extEditPageObj.dashElement );
			}
			
			this.loadDependencies( row, skippedElementsNames );
		}, this);
	},
	
	/**
	 * Initialize the 'Delete selected' button
	 */
	initDeleteButton: function() {
		var submitUrl = Runner.getPageUrl( this.shortTName, this.pageType ),
			pageObj = this;
		
		$("a[id='delete_selected" + this.id + "']").unbind("click").bind("click", function(e) { // ?
			var selBoxes = pageObj.getSelBoxes( pageObj.id ),
				form;
			
			if ( selBoxes.length == 0 || !confirm( Runner.lang.constants.TEXT_DELETE_CONFIRM ) ) {
				return false;
			}
			
			form = new Runner.form.BasicForm({
				standardSubmit: false,
				submitUrl: submitUrl + "?" + $(selBoxes).serialize(),
				method: 'POST',
				id: pageObj.id,
				baseParams: Runner.apply( {a: 'delete', id: pageObj.pageId}, pageObj.baseParams ),
				successSubmit: {
					fn: function( respObj, formObj, fieldControls ) {
						this.pageReloadHn( respObj );
					},
					scope: pageObj
				}
			});
			
			form.submit();
			return false;		
		});	
	},
	
	/**
	 * Check if there are dependent elements in the dashboard, 
	 * so the "selected record" is required.
	 * @return {array}
	 */
	getDependentElements: function() {
		var dependents = this.dashboard.getDashElements( this.tName, [Runner.pages.constants.DASHBOARD_RECORD, Runner.pages.constants.DASHBOARD_DETAILS] );
		
		this.getDependentElements = function() { 
			return dependents;
		};
		
		return dependents;
	},
	
	/**
	 * @param {boolean} next
	 */
	moveNextPrev: function( next ) {
		var i, selectedIdx = null;
		//	find current selected rowInfo index
		for ( i = 0; i < this.controlsMap.gridRows.length; ++i ) {
			if ( this.controlsMap.gridRows[i].id == this.selectedId ) {
				selectedIdx = i
				break;
			}
		}
		
		if ( selectedIdx === null ) {
			return;	
		}
		
		if ( !next && selectedIdx > 0 ) {
			this.setSelected( this.controlsMap.gridRows[ selectedIdx - 1 ].id );
			return;
		} 
		
		if ( next && selectedIdx < this.controlsMap.gridRows.length - 1 ) {
			this.setSelected( this.controlsMap.gridRows[ selectedIdx + 1 ].id );
			return;
		}
		//	load another page
		if ( !next && this.controlsMap.pageNumber > 0 ) {
			this.reload( { goto: this.controlsMap.pageNumber - 1, moveToLastRecord: true } , { moveToLastRecord: true } );
			return;
		}
		
		this.reload( { goto: this.controlsMap.pageNumber + 1, moveToLastRecord: false } , { moveToLastRecord: false } );
	},
	
	/**
	 * @param {object} respObj
	 * @param {object} reloadParams
	 */
	pageReloadHn: function( respObj, reloadParams ) {
		Runner.pages.ListPageDash.superclass.pageReloadHn.call(this, respObj, reloadParams);

		if ( reloadParams && this.controlsMap.gridRows.length ) {
			if ( reloadParams.moveToLastRecord ){
				this.setSelected( this.controlsMap.gridRows[this.controlsMap.gridRows.length - 1].id );
			} else if ( reloadParams.moveToLastRecord === false ) {
				this.setSelected( this.controlsMap.gridRows[0].id );
			}	
		}
	},

	initSearch: Runner.emptyFn,

	initScrollGridBody: Runner.emptyFn,

	afterPageReady: Runner.emptyFn,
});

Runner.pages.EditPageDash = Runner.extend( Runner.pages.EditPage, {
	/**
	 * The dashboard page object
	 */
	dashboard: null,
	
	/**
	 * ListPageDash object that initiated the Edit page loading.
	 */
	parentGrid: null,
	
	/**
	 * The name of the dash element 
	 * where the page is open
	 */
	dashElement: "",
	
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.EditPageDash.superclass.constructor.call( this, cfg );
	},
	
	/**
	 * @return {boolean}
	 */
	checkIfShowDetails: function() {
		return false;
	},	
	
	/**
	 * Initialize the page
	 */	
	init: function() {
		Runner.pages.EditPageDash.superclass.init.call(this);
	},
	
	/**
	 * Open the page corresponding to the next/previous record
	 * @param {Array} keys
	 * @param {Number} step
	 */
	openPrevNextRecordPage: function( keys, step ) {
		if ( this.parentGrid ) {
			this.parentGrid.moveNextPrev( step > 0 );
			return;
		}
		
		var i, params = { 
				baseParams:{} 
			};

		for ( i = 0; i < keys.length; ++i ) {
			params.baseParams[ 'editid' + (i + 1) ] = keys[i];
		}
		
		// unregister current edit, view pages
		Runner.pages.PageManager.unregister( this.tName, this.pageId );
		this.dashboard.unregisterDashPage( this.tName, Runner.pages.constants.PAGE_VIEW, this.dashElement );
		this.dashboard.loadSingleRecord( this.dashboard.getElementByName( this.dashElement ), [ Runner.pages.constants.PAGE_EDIT, Runner.pages.constants.PAGE_VIEW ], params );			
	},
	
	/**
	 * Assign the 'form' property with the new Runner.form.BasicForm object 
	 * reference. Add the form's 'successSubmit' event handler
	 */
	getForm: function() {
		if ( this.form ) {
			return;
		}
		
		Runner.pages.EditorPage.prototype.getForm.call( this );
		
		this.form.on('successSubmit', function( respObj, basicForm, fieldControls ) {
			if ( respObj.success ) {
				var	viewPageId = this.dashboard.getDynamicPageIds( this.tName, Runner.pages.constants.PAGE_VIEW, this.dashElement )[0],
					listPageId = this.dashboard.getDynamicPageIds( this.tName, Runner.pages.constants.PAGE_LIST )[0],
					viewPageObj = Runner.pages.PageManager.getAt( this.tName, viewPageId ),
					// this.parentGrid could not be set
					listPageObj = Runner.pages.PageManager.getAt( this.tName, listPageId ),
					row, keyparams = {}, i;
				
				if ( listPageObj && listPageObj.inlineEdit ) {
					row = listPageObj.inlineEdit.getRowById( listPageObj.selectedId );
					if ( row ) {
						listPageObj.inlineEdit.afterSubmit( row, respObj, this );
					}									
				}
				
				this.pageReloadHn( respObj );
				
				for ( i = 0; i < respObj.keys.length; ++i ) {
					keyparams[ 'editid' + (i + 1) ] = respObj.keys[i];	
				}
				viewPageObj.reload( keyparams );
				
				this.enablePageButtonsAfterSaving();	
				return true;	
			} 
											
			if ( respObj.lockMessage ) {
				$('.rnr-locking').html( respObj.lockMessage ).show();
				return false; // ?
			}
			
			if ( this.hideCaptcha ) {
				$('.captcha_block').remove();
			}
			this.showCaptchaErrMessage( respObj.captcha );

			this.displayHalfPreparedMessage( respObj.message || "" );
			this.showBrick('message');
			
			this.initLoginLink();
			this.enablePageButtonsAfterSaving();			
			return false;			
		}, this);
	},
	
	initDetails: Runner.emptyFn,
	onDetailsSaved: Runner.emptyFn,
	onDetailsSavingFailed: Runner.emptyFn,	
	setRecountFlagForPopup: Runner.emptyFn	
});

Runner.pages.AddPageDash = Runner.extend( Runner.pages.AddPage, {
	/**
	 * @constructor
	 * @param {object} cfg
	 */	
	constructor: function( cfg ) {
		Runner.pages.AddPageDash.superclass.constructor.call(this, cfg);
	},

	/**
	 * @return {boolean}
	 */
	checkIfShowDetails: function() {
		return false;
	},
	
	init: function() {
		Runner.pages.AddPageDash.superclass.init.call( this );	
	},

	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		Runner.pages.AddPageDash.superclass.initButtons.call( this );	
		
		var pageObj = this;
		
		$( "a#resetButton" + this.id ).on("click", function(e) {		
			Runner.controls.ControlManager.resetControlsForTable( pageObj.tName, pageObj.pageType );
			clearTimeout( pageObj.validateTimer ); //?			

			return false; 
		});
	},
	
	/**
	 * Assign the 'form' property with the new Runner.form.BasicForm object 
	 * reference. Add the form's 'beforeSubmit', 'successSubmit', 'submitFailed'
	 * events handlers basing on the page's type and settings
	 */	
	getForm: function() {
		if ( this.form ) {
			return;
		}

		Runner.pages.EditorPage.prototype.getForm.call( this );
				
		this.form.on('successSubmit', function( respObj, basicForm, fieldControls ) {		
			if ( respObj.success ) {
				// this.parentGrid could not be set
				var listPageId = this.dashboard.getDynamicPageIds( this.tName, Runner.pages.constants.PAGE_LIST )[0],
					listPageObj = Runner.pages.PageManager.getAt( this.tName, listPageId );	

				if ( listPageObj && listPageObj.inlineAdd )	{
					listPageObj.inlineAdd.addRowToGrid( respObj, this );
				}	
				
				this.pageReloadHn( respObj );
				return true;	
			} 
			
			if ( respObj.hideCaptcha ) {
				$('.captcha_block').remove();
			}
			this.showCaptchaErrMessage( respObj.captcha );

			if ( respObj.message ) {
				this.displayHalfPreparedMessage( respObj.message );
				this.showBrick('message');
				
				this.initLoginLink();
			} 	
			
			this.enablePageButtonsAfterSaving();
			return false;	
		}, this);
	},
	
	/**
	 * Check if the page's form must use the standard submit process
	 * @return Boolean
	 */
	isSubmitStandard: function() {
		return false;
	},
	
	initDetails: Runner.emptyFn,
	onDetailsSaved: Runner.emptyFn,
	onDetailsSavingFailed: Runner.emptyFn,
	isInlineAddContentChanged: Runner.emptyFn
});


Runner.pages.CheckboxesPage = Runner.extend( Runner.pages.ListPage, {
	/**
	 * Count of current functions wich waiting for AJAX result and set disable state for controls
	 */
	disableCounter: 0,
	/**
	 * List of table colemn headers checkboxes
	 * {array}
	 */
	columnHeaders: null,
	/**
	 * List of table rows headers 
	 * {array}
	 */
	rowHeaders: null,
	/**
	 * List of actions to send to the ug_group via AJAX
	 * {array}
	 */
	ajaxActions: null,
	/**
	 * Checkboxes id postfix (for the group value in RightsPage)
	 * {string}
	 */
	cbxPostfix: '',
	/**
	 * Left (row) checkboxes name prefix
	 * {string}
	 */
	rowCbxPrefix: '',
	/**
	 * Dummy array. Filling only in RightsPage, where represent a list of existing groups
	 * {array} 
	 */
	groups: [''],
	/**
	 * List of real tables or users names
	 * {array}
	 */
	realValues: null,
	/**
	 * List of default values (rights or membership)
	 * {array}
	 */
	defaultValues: {},
	
	constructor: function(cfg) {
		this.ajaxActions = {};
		this.columnHeaders = [];
		Runner.pages.CheckboxesPage.superclass.constructor.call(this, cfg);	
	},
	
	init: function() {
		Runner.pages.CheckboxesPage.superclass.init.call(this);
		
		this.realValues = Runner.pages.PageSettings.getTableData(this.tName, "realValues");
		this.initGeneralControls();
	},
	
	/**
	 * initGeneralControls
	 * Init all general controls
	 */
	initGeneralControls: function() {
		var pageObj = this;
		
		$('#saveBtn').click( function(e) {
			if ( !Runner.isDisabledButton(this) ) {	
				pageObj.saveStateToDB( pageObj.saveCheckboxesState() );
			}
			return false;
		});
		
		$('#resetBtn').click( function(e) {
			if ( !Runner.isDisabledButton(this) ) {	
				pageObj.resetCheckboxes(); 
			}
			return false;
		});
	},
	
	/**
	 * initOrdinaryCheckboxes
	 * Set checked state and bind handlers with all ordinary checkboxes
	 * or one concret checkbox if param passed
	 * @param {object} checkbox to bind handler
	 */
	initOrdinaryCheckboxes: function(checkbox) {
		var pageObj = this, 
			saveState = function() {	
				pageObj.checkRowAndColumn(); 
			};
			
		if (checkbox != undefined) {
			$(checkbox).click(saveState);
			return;
		} 
		
		for (var g = 0; g < pageObj.groups.length; g++) {
			$.each(pageObj.rowHeaders, function(rIndex, rValue) {
				var cbName = '_' + rIndex + '_' + pageObj.groups[g];
				$.each(pageObj.columnHeaders, function(key, cheader) {
					if ($('#cb' + cheader + cbName).attr('id') != undefined) {
						$('#cb' + cheader + cbName).click(saveState);
					}
				});
			});
		}	
	},
	
	/**
	 * initRowCheckboxes
	 * Set checked state and bind handlers with left checkboxes (for the all rights of table) 
	 */
	initRowCheckboxes: function() {
		var pageObj = this, 
			rowclick = function() {	
				var chkBox = this;
				$.each(pageObj.columnHeaders, function(key, cheader) {
					$('#cb' + cheader + '_' + $(chkBox).attr('id') + '_' + pageObj.cbxPostfix).each(function() {
						if (this.style.display != 'none') { 
							this.checked = $(chkBox).prop('checked');
						}
					});
				});	
				pageObj.checkRowAndColumn();
			};
		$('input:checkbox[name^="' + this.rowCbxPrefix + '"]').each(function() {
			$(this).click(rowclick);
		});
	},
	
	/**
	 * initHeadCheckboxes
	 * Set checked state and bind handlers with top checkboxes (for the one right to all tables) 
	 */
	initHeadCheckboxes: function() {
		// Handler for head (top) checkbox in a column
		var pageObj = this, 
			headclick = function() {
				var $chkBox = $(this);	
				
				$('input[id^=' + $chkBox.attr('id') + '_]:visible'). prop('checked', $chkBox.prop('checked'));
				pageObj.checkRowAndColumn();
			};
			
		$.each(this.columnHeaders, function(key, cheader) {
			$('#cb' + cheader).click(headclick);
		});
	},
		
	/**
	 * saveStateToDB
	 * Save all current changes in database
	 * @param {array} array of current values
	 */
	saveStateToDB: function( valuesSet ) {
		var pageObj = this;
		
		$('input:checkbox').prop('disabled', true);
		this.disableControls(true);
		
		Runner.runnerAJAX( Runner.getPageUrl('ug_group'), {
				state: JSON.stringify(valuesSet),
				realValues: JSON.stringify(pageObj.rowHeaders),
				a: this.ajaxActions.saveState
			},
			function(respObj) {
				if (!respObj.success) {
					pageObj.replaceBrickContentHTMLWith('message', respObj.error);
					pageObj.showBrick('message');
				} else {
					pageObj.hideBrick('message');
					pageObj.defaultValues = pageObj.saveCheckboxesState();
				}
				$('input:checkbox').prop('disabled', false);
				pageObj.disableControls(false);
			});
	},
	
	/**
	 * checkRowAndColumn
	 * Set check/uncheck state for the row(left) and column (top) checkboxes
	 */
	checkRowAndColumn: function() {
		if (this.disableCounter > 1) {
			return;
		}	
		var pageObj = this, 
			colsState = [], 
			rowsState = [];
		for (var i = 0; i < this.columnHeaders.length; i++) {
			$.each(this.rowHeaders, function(rIndex, rValue) {
				// Set default values
				if (colsState[i] == undefined) {
					colsState[i] = [pageObj.columnHeaders[i], true];
				}
				if (rowsState[rIndex] == undefined) {
					rowsState[rIndex] = true;
				}
				var cbxName = '#cb' + pageObj.columnHeaders[i] + '_' + rIndex + '_' + pageObj.cbxPostfix;
				if ($(cbxName).attr('id') != undefined	&& !$(cbxName).prop('checked')) {
					colsState[i][1] = rowsState[rIndex] = false;
				}
			});
		}
		$.each(colsState, function(key, cstate) {
			$('#cb' + cstate[0]).prop('checked', this[1]);
		});
		$.each(rowsState, function(key, rstate) {
			$('input:checkbox[name="' + pageObj.rowCbxPrefix + key + '"]:eq(0)').prop('checked', rstate);
		});
	}
});
Runner.pages.MembersPage = Runner.extend( Runner.pages.ListPage, {
		
	pageType: Runner.pages.constants.PAGE_ADMIN_MEMBERS,
	
	users: {},
	
	groups: {},
	
	fields: {},
	
	modifiedUsers: {},
	
	searchList: [],
	
	usersFilterState: "all",
	
	isSortTypeAscending: true,
	
	constructor: function(cfg) {
		Runner.pages.MembersPage.superclass.constructor.call(this, cfg);
		
		this.users = Runner.pages.PageSettings.getTableData(this.tName, "usersList");
		this.groups = Runner.pages.PageSettings.getTableData(this.tName, "groupsList");
		this.fields = Runner.pages.PageSettings.getTableData(this.tName, "fieldsList");
	},
	
	init: function() {
		Runner.pages.MembersPage.superclass.init.call(this);
	
		this.initCheckboxes();
		this.initColumnHeaders();
		this.initRowHeaders();
		this.initSearchBox();
		this.initModifiedFilter();
		this.initSort();
		this.initSave();
		this.initReset();
		this.initChooseColumns();
		this.updateRowHeaderStates();
		this.updateColHeaderStates();
	},
	
	/**
	 * Handle grid checkboxes clicks
	 */ 
	initCheckboxes: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$( ".adminMembersTable" ).on( "click", "td:has(.rnr-checkbox:not(.columnheader):not(.rowheader))", function( e ) {
			// checkbox end cell
			var $checkbox = $( e.target ).add( $( e.target ).find( ".rnr-checkbox" ) ).filter( ".rnr-checkbox" ),
				userid = $checkbox.attr( "data-userid" ),
				group = $checkbox.attr( "data-group" ),
				newchecked = $checkbox.attr( "data-checked" ) == "1" ? 0 : 1,
				newUserState = {};
			
			// if checkbox disabled and checked (state 3)
			if ( pageObj.users[ userid ][ "groups" ][ group ] == 3 ) {
				return;
			}
			
			newUserState[ group ] = newchecked;
			pageObj.updateModifiedState( newUserState, userid );
			pageObj.updateRowHeaderState( userid );
			pageObj.updateColHeaderStates();
			pageObj.updateRowModifiedState( userid );
			pageObj.updateControlsState();
			
			$checkbox.attr( "data-checked", newchecked );
			return false;
		});
	},
	
	/**
	 * Handle clicks on the checkboxes in column headers
	 */
	initColumnHeaders: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$( ".adminMembersTable" ).on( "click", ".columnheader", function(e) {
			var $checkbox = $( e.target ),
				group = $checkbox.data( "group" ),
				newchecked = $checkbox.attr( "data-checked" ) == "1" ? 0 : 1;
			
			$( ".adminMembersTable" ).find( "[id^=box" + group + "]:visible" ).each( function() {
				var $checkbox = $( this );
					userid = $checkbox.data( "userid" );
					newUserState = {};
				
				// if checkbox disabled and checked (state 3)
				if ( pageObj.users[ userid ][ "groups" ][ group ] == 3 ) {
					return;
				}
				
				newUserState[ group ] = newchecked;
				$checkbox.attr( "data-checked", newchecked );
				pageObj.updateModifiedState( newUserState, userid );
				pageObj.updateRowHeaderState( userid );
				pageObj.updateRowModifiedState( userid );
			});
			
			pageObj.updateColHeaderStates();
			pageObj.updateControlsState();
			return false;
		});
	},
	
	/**
	 *	Handle clicks on the checkboxes in row headers - near user names
	 */
	initRowHeaders: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$( ".adminMembersTable" ).on( "click", ".rowheader", function( e ) {
			var $checkbox = $( e.target ),
				newchecked = $checkbox.attr( "data-checked" ) == "1" ? 0 : 1,
				userid = $checkbox.data( "userid" ),
				newUserState = {};
			
			$.each( pageObj.groups, function( groupId, groupName ) {
				// if checkbox disabled and checked (state 3)
				if ( pageObj.users[ userid ][ "groups" ][ groupId ] == 3 || !pageObj.isVisibleField( groupId ) ) {
					return;
				}
				$( "#box" + groupId + userid ).attr( "data-checked", newchecked );
				newUserState[ groupId ] = newchecked;
			});
			
			pageObj.updateModifiedState( newUserState, userid );
			pageObj.updateColHeaderStates();
			pageObj.updateRowHeaderState( userid );
			pageObj.updateRowModifiedState( userid );
			pageObj.updateControlsState();
			return false;
		});
	},
	
	/**
	 * Updates the modifiedUsers object
	 */
	updateModifiedState: function( newGroupsStates, userId ) {
		var pageObj = this,
			savedUserGroupsStates = this.users[ userId ][ "groups" ],
			userName = this.users[ userId ][ "userName" ],
			modifiedUserGroupsStates = this.modifiedUsers[ userName ] || {};
		
		$.each( newGroupsStates, function( group, newGroupState ) {
			if ( typeof savedUserGroupsStates[ group ] !== 'undefined' && savedUserGroupsStates[ group ] != newGroupState ) {
				modifiedUserGroupsStates[ group ] = newGroupState;
			} else {
				delete modifiedUserGroupsStates[ group ];
			}
		});
		
		if ( !$.isEmptyObject( modifiedUserGroupsStates ) ) {
			this.modifiedUsers[ userName ] = modifiedUserGroupsStates;
		} else {
			delete this.modifiedUsers[ userName ];
		}
	},
	
	/**
	 * Sets proper state to the tri-state checkbox in the row header. 
	 */	
	updateRowHeaderState: function( userId ) {
		var	pageObj = this,
			$checkbox = $( '#rowbox' + userId ),
			savedStates = this.users[ userId ][ "groups" ],
			userName = this.users[ userId ][ "userName" ],
			modifiedStates = this.modifiedUsers[ userName ] || {},
			unsavedState = $.extend( {}, savedStates, modifiedStates ),
			summState = 0,
			count = 0;
		
		// get state row box
		$.each( unsavedState, function( group, state ) {
			if ( !pageObj.isVisibleField( group ) ) {
				return;
			}
			
			// if checkbox disabled and checked (state 3) convert to checked (state 1)
			state = state == 3 ? 1 : state;
			summState += state;
			count++;
		});
		
		if ( summState == 0 ) { // none checked
			$checkbox.attr("data-checked", 0);
		} else if ( summState == count ) { // all checked
			$checkbox.attr("data-checked", 1);
		} else { // partially checked
			$checkbox.attr("data-checked", 2);
		}
	},
	
	/**
	 * Runs updateRowHeaderState for all rows
	 */
	updateRowHeaderStates: function() {
		var pageObj = this;
		
		$.each( this.users, function( userId, userInfo ) {
			pageObj.updateRowHeaderState( userId );
		});
	},
	
	/**
	 * Sets proper state to the tri-state checkbox in the column header. 
	 */	
	updateColHeaderStates: function() {
		var pageObj = this,
			colBoxStates = {};
		
		// init colBoxStates
		$.each( pageObj.groups, function( groupId, groupName ) {
			colBoxStates[ groupId ] = { "summState": 0, "count": 0 };
		});
		
		// get states column boxs
		$.each( this.users, function( userId, userInfo ) {
			if ( userInfo[ "visible" ] ) {
				var	unsavedGroups = $.extend({}, userInfo[ "groups" ], pageObj.modifiedUsers[ userInfo[ "userName" ] ]); // unsaved state
				
				$.each( unsavedGroups, function( group, state ) {
					// if checkbox disabled and checked (state 3) convert to checked (state 1)
					state = state == 3 ? 1 : state;
					colBoxStates[ group ][ "summState" ] += state;
					colBoxStates[ group ][ "count" ]++;
				});
			}
		});
		
		// set states column boxs
		$.each( colBoxStates, function( group, state ) {
			var $colBox = $( "#colbox" + group );
			
			if ( state[ "summState" ] == 0 ) { // none checked
				$colBox.attr( "data-checked", 0 );
			} else if ( state[ "summState" ] == state[ "count" ] ) { // all checked
				$colBox.attr( "data-checked", 1 );
			} else { // partially checked
				$colBox.attr( "data-checked", 2 );
			}
		});
	},
	
	/**
	 * Yellow colors the row with the given user.
	 */
	updateRowModifiedState: function( userId ) {
		var pabeObj = this,
			userName = this.users[ userId ][ "userName" ];
			modifiedGroups = this.modifiedUsers[ userName ] || {},
			savedGroups = this.users[ userId ][ "groups" ],
			userModified = false;
		
		$.each( savedGroups, function( group, state ) {
			var groupModified = group in modifiedGroups;
			
			// update cells color
			$( "#cell" + group + userId ).toggleClass( "rights-modified", groupModified );
			userModified = userModified || groupModified;
		});
		
		// update username cell color
		$( "#cellusername" + userId ).toggleClass( "rights-modified", userModified );
		$( "#cellDisplayName" + userId ).toggleClass( "rights-modified", userModified );
		$( "#cellEmail" + userId ).toggleClass( "rights-modified", userModified );
	},
	
	/**
	 * Handle search box input
	 */
	initSearchBox: function() {
		var pageObj = this;
		
		$("#adminMembersSearch").on("input", function() {
			pageObj.searchList = $( this ).val().trim().toUpperCase().match(/[^\s]+/g) || [];
			pageObj.showHideRows();
		});
	},
	
	/**
	 *	Refreshes the users list - displays and hides every single row there
	 */
	showHideRows: function() {
		var pageObj = this;
		
		$.each( this.users, function( userId, userInfo ) {
			pageObj.toggleElement( $("#usernamerow" + userId ), pageObj.isUserDisplayed( userId ) );
		});
		
		this.updateColHeaderStates();
	},
	
	/**
	 * Checks wheter the user shoud be displayed according to the current filtering criteria
	 */
	isUserDisplayed: function( userId ) {
		var pageObj = this,
			show = true, i,
			userName = this.users[ userId ][ "userName" ] || "";
			upperCaseUserName = userName.toUpperCase() ,
			upperCaseDisplayUserName = (this.users[ userId ][ "displayUserName" ] || "").toUpperCase(),
			upperCaseEmailUser = (this.users[ userId ][ "emailUser" ] || "").toUpperCase(),
			allModifiedGroupsVisible = false;
		
		if ( this.searchList.length ) {
			show = false;
			for (i = this.searchList.length - 1; !show && i >= 0 ; --i) {
				show = this.searchList[i] && ( upperCaseUserName.indexOf( this.searchList[i] ) >= 0 || upperCaseDisplayUserName.indexOf( this.searchList[i] ) >= 0 || upperCaseEmailUser.indexOf( this.searchList[i] ) >= 0 );
			}
		}
		
		if ( userName in this.modifiedUsers ) {
			$.each( this.modifiedUsers[ userName ], function( groupId, groupState ) {
				allModifiedGroupsVisible = allModifiedGroupsVisible || pageObj.isVisibleField( groupId );
			});
		}
		
		//	check modified filter state
		show = show && ( this.usersFilterState == 'all' || ( this.usersFilterState == 'modified' && userName in this.modifiedUsers && allModifiedGroupsVisible ) );
		this.users[ userId ][ "visible" ] = show;
		
		return show;
	},
	
	/** 
	 * Hide element with inline display style 
	 * Delete inline display style to show
	 */
	toggleElement: function( $elem, show ) {
		if ( !show ) {
			$elem.hide();
		} else {
			$elem.css( 'display', '' );
		}
	},
	
	/**
	 * Handle all/modified rows dropdown. Filter users by their modified state.
	 */
	initModifiedFilter: function() {
		var pageObj = this;
		
		( new Runner.linkSelectControl( $("#linkselectFilter").get(0) ) ).change( function() {
			pageObj.usersFilterState = this.val();
			pageObj.showHideRows();
		});
	},
	
	/**
	*	set sort icon
	*/
	setSortIcon: function( $link ) {
		// delete all sort icons
		$( "#userNameSort" ).removeAttr( "data-icon" );
		$( "#displayNameSort" ).removeAttr( "data-icon" );
		$( "#EmailSort" ).removeAttr( "data-icon" );
		$.each( this.groups, function( groupId, groupName ) {
			$( "#colsort" + groupId ).removeAttr( "data-icon" );
		});
		
		// set icon for current link
		$( $link ).attr( "data-icon", this.isSortTypeAscending ? "sortasc" : "sortdesc" );
	},
	
	/**
	 * sort
	 */
	sort: function( $link, field ) {
		var $firstRow = $( ".adminMembersTable" ).find( "tr.rnr-row:first" ),
			$insertRow, rowid, group,
			orderedUsers = [],
			pageObj = this;
		
		// init sort array and variables
		$.each( this.users, function( userId, userInfo ) {
			// concat orderedUsers and modifiedUsers
			userInfo[ "groups" ] = $.extend( {}, userInfo[ "groups" ], pageObj.modifiedUsers[ userInfo[ "userName" ] ] );
			userInfo = $.extend( {}, {"userId": userId}, userInfo );
			orderedUsers.push( userInfo );
		});
		
		// toggle sort type ascending/descending
		this.isSortTypeAscending = !this.isSortTypeAscending;
		this.setSortIcon( $link );
		group = $( $link ).data( "group" );
		
		// sorting
		orderedUsers.sort( function( a, b ) {
			var result = 0;
			
			if ( group ) {	// sort by group
				a = a[ "groups" ][ group ] || 0;
				b = b[ "groups" ][ group ] || 0;
			} else {	// sort by field (uername, email or display username)
				a = a[ field ];
				b = b[ field ];
			}
			
			if ( a > b ) {
				result = pageObj.isSortTypeAscending ? 1 : -1;
			} else if ( b > a ) {
				result = pageObj.isSortTypeAscending ? -1 : 1;
			}
			
			return result;
		});
		
		// print result
		$.each( orderedUsers, function( idx, userInfo ) {
			rowid = "usernamerow" + userInfo[ "userId" ];
			
			if ( $firstRow.attr( "id" ) != rowid && userInfo[ "visible" ] ) {
				$insertRow = $( "#" + rowid );
				$firstRow.after( $insertRow );
				$firstRow = $insertRow;
			}
		});
	},
	
	/**
	 *	init sort link
	 */
	initSort: function() {
		var pageObj = this;
		
		// click on link sort by user name
		$( "#userNameSort" ).on( "click", function() {
			pageObj.sort( this, 'userName' );
		});
		
		// click on link sort by display name
		$( "#displayNameSort" ).on( "click", function() {
			pageObj.sort( this, 'displayUserName' );
		});
		
		// click on link sort by email
		$( "#EmailSort" ).on( "click", function() {
			pageObj.sort( this, 'emailUser' );
		});
		
		// click on link sort by group
		$.each( this.groups, function( groupId, groupName ) {
			$( "#colsort" + groupId ).on( "click", function() {
				pageObj.sort( this );
			});
		});
	},
	
	/**
	 * Save everything
	 */
	initSave: function() {
		var pageObj = this;
		
		$( "#saveBtn" ).on( "click", function() {
			if ( Runner.isDisabledButton( this ) ) {
				return false;
			}
			
			pageObj.disableControls();
			
			$.ajax({
				type: "POST", 
				data: {
					values: JSON.stringify( pageObj.modifiedUsers ),
					a: 'saveMembers'
				},
				dataType: "json",
				error: function( jqXHR, textStatus, errorThrown ) {
					pageObj.displayMessage( textStatus + ' ' + errorThrown, true, true );
					pageObj.updateControlsState();
				},
				success: function( _respObj ) {
					var respObj = _respObj || { error:"Error. Null response" };
					
					if ( !respObj.success ) {
						pageObj.displayMessage( respObj.error, true, true );
						pageObj.updateControlsState();
						return false;
					}
					
					// update data
					$.each( pageObj.modifiedUsers, function( userName, groups ) {
						var userId = pageObj.getUserIdByUserName( userName );
						
						pageObj.users[ userId ][ "groups" ] = $.extend( {}, pageObj.users[ userId ][ "groups" ], groups );
						delete pageObj.modifiedUsers[ userName ];
						pageObj.updateRowModifiedState( userId );
					});
					pageObj.updateControlsState();
				}
			});
			
			return false;
		});
	},
	
	disableControls: function() {
		Runner.addDisabledClass( $('#resetBtn') );
		Runner.addDisabledClass( $('#saveBtn') );
		this.setPageModified( false );
	},

	enableControls: function() {
		Runner.delDisabledClass( $('#resetBtn') );
		Runner.delDisabledClass( $('#saveBtn') );
		this.setPageModified( true );
	},
	
	updateControlsState: function() {
		if ( $.isEmptyObject( this.modifiedUsers ) ) {
			this.disableControls();
		} else {
			this.enableControls();
		}
	},
	
	/**
	 * Reset everything to saved values
	 */
	initReset: function() {
		var pageObj = this;
		
		$( "#resetBtn" ).click( function() {
			if ( Runner.isDisabledButton( this ) ) {
				return false;
			}
			
			$.each( pageObj.modifiedUsers, function( userName, groups ) {
				var userId = pageObj.getUserIdByUserName( userName );
				
				$.each( groups, function( groupId, state ) {
					state = state ? 0 : 1;
					$( "#box" + groupId + userId ).attr( "data-checked", state );
				});
				delete pageObj.modifiedUsers[ userName ];
				pageObj.updateRowModifiedState( userId );
				pageObj.updateRowHeaderState( userId );
			});
			pageObj.updateColHeaderStates();
			pageObj.updateControlsState();
			return false;
		});
		
		this.updateControlsState();
	},
	
	/**
	 * @param {string} userName
	 * @return {number} user ID
	 */
	getUserIdByUserName: function( userName ) {
		var userId = 0;
		
		$.each( this.users, function( idx, userInfo ) {
			if ( userInfo[ "userName" ] == userName ) {
				userId = idx;
				return false;
			}
		});
		return userId;
	},
	
	/**
	* Open fly window "choose columns"
	*/
	initChooseColumns: function() {
		var pageObj = this,
			args = {
				modal: true,
				centered: true,
				headerContent: Runner.lang.constants.AA_CHOOSE_COLUMNS_TO_DIPLAY,
				bodyContent: ''
			};
		
		$( '#chooseColumnsButton' ).on( 'click', function( e ) {
			Runner.pages.PageManager.createFlyWin( args, false, $.proxy( pageObj.flyWinHandler, pageObj ) );
			return false;
		});
	},
	
	/**
	* Add button to fly window
	* @param {YUI3 Panel} win
	* @param {string} label
	* @param {string} name
	* @param {function} action
	*/
	addButtonToFlyWin: function( win, label, name, action ) {
		if ( !win ) {
			return;
		}
		
		win.addButton({
			label: label,
			name: name,
			template: "<a />",
			classNames: "rnr-button",
			section: Runner.Y.WidgetStdMod.BOTTOM,
			action: action
		});
	},
	
	/**
	 * Select all/none checkbox to fly win
	 * @param {number} State
	 * @param {array} modifiedFields
	 */
	selectAllNoneToFlyWin: function( State, modifiedFields ) {
		$.each( this.fields, function( idx, fieldInfo ) {
			$( "#" + idx + "fieldCheckbox" ).attr( "data-checked", State );
			modifiedFields[ idx ] = { "visible": State };
		});
	},
	
	/**
	 * Fly window handler
	 * @param {YUI3 Panel} win
	 */
	flyWinHandler: function( win ) {
		var pageObj = this,
			modifiedFields = {},
			$rows = $( "<div></div>" );
			
		if ( !win ) {
			return false;
		}
		
		// init rows checkboxes
		$.each( this.fields, function( idx, fieldInfo ) {
			var $row = $( '<a class="chooseColumnsLink"></a>' ).text( " " + fieldInfo[ "caption" ] ), 
				$checkBox = $( '<span class="rnr-checkbox rowheader" id="' + idx + 'fieldCheckbox"></span>' )
					.attr( "data-checked", fieldInfo[ "visible" ] )
					.prependTo( $row );
			
			// on row or checkbox click
			$row.on( "click", function() {
				var newChecked = $checkBox.attr( "data-checked" ) == "1" ? 0 : 1;
				
				$checkBox.attr( "data-checked", newChecked );
				modifiedFields[ idx ] = { "visible": newChecked };
			}).appendTo( $rows );
		});
		
		// add rows to body content
		$rows.appendTo( win.bodyNode.getDOMNode() );				
		
		// add button select all
		this.addButtonToFlyWin( win, Runner.lang.constants.SELECT_ALL, "selectAll", function( e ) {
			pageObj.selectAllNoneToFlyWin( 1, modifiedFields );
		});
		
		// add button select none
		this.addButtonToFlyWin( win, Runner.lang.constants.AA_SELECT_NONE, "selectNone", function( e ) {
			pageObj.selectAllNoneToFlyWin( 0, modifiedFields );
		});
		
		// add button ok
		this.addButtonToFlyWin( win, Runner.lang.constants.AA_OK, "ok", function( e ) {
			$.each( modifiedFields, function( idx, fieldInfo ) {
				var fieldName = pageObj.fields[ idx ][ "name" ],
					sortLink = idx === "0" ? $( "#displayNameSort" ) : $( "#colsort" + fieldName );
				
				// update fields array
				pageObj.fields[ idx ] = $.extend( {}, pageObj.fields[ idx ], fieldInfo );
				
				// hide or show fields
				pageObj.toggleElement( $( "#tdsort" + fieldName ), fieldInfo[ "visible" ] );
				pageObj.toggleElement( $( "#tdbox" + fieldName ), fieldInfo[ "visible" ] );
				pageObj.toggleElement( $( "[id^=cell" + fieldName + "]" ), fieldInfo[ "visible" ] );
				
				// if sort set on hidden field
				if ( sortLink.attr( "data-icon" ) ) {
					// toggle sort type ascending/descending
					pageObj.isSortTypeAscending = !pageObj.isSortTypeAscending;
					pageObj.sort( $( "#userNameSort" ), 'userName' );
				}
			});
			
			pageObj.updateRowHeaderStates();
			pageObj.showHideRows();
			win.destroy( true );
		});
		
		// add button cancel
		this.addButtonToFlyWin( win, Runner.lang.constants.CANCEL, "cancel", function( e ) {
			win.destroy( true );
		});
		
		Runner.pages.PageManager.correctYUIWindowSize( win, true );
	},
	
	/**
	 * check field visible
	 * @param {string} fieldName
	 * @return {boolean}
	 */
	isVisibleField: function( fieldName ) {
		var visible = false;
		
		$.each( this.fields, function( idx, fieldInfo ) {
			if ( fieldInfo[ "name" ] == fieldName && fieldInfo[ "visible" ] == 1 ) {
				visible = true;
				return false;
			}
		});
		
		return visible;
	}
});
/**
 * The base class for a rights page
 */
Runner.pages.RightsPage = Runner.extend( Runner.pages.ListPage, {
	/**
	 * Type of the page 
	 */	
	pageType: Runner.pages.constants.PAGE_ADMIN_RIGHTS,
	
	/**
	 * Text message for adding new group alert
	 * {string}
	 */
	TEXT_AA_ADD_NEW_GROUP: Runner.lang.constants.AA_ADD_NEW_GROUP,
	
	/**
	 * Text message for renaming new group alert
	 * {string}
	 */
	TEXT_AA_RENAMEGROUP: Runner.lang.constants.AA_RENAMEGROUP,
	
	/**
	 * Index of renaming position in the groups list
	 * {integer}
	 */
	renameidx: -1,
	
	/**
	 * List of existing groups
	 * {array}
	 */
	groups: null,

	/**
	 * List of existing tables
	 * {array}
	 */
	tables: null,
	
	/**
	 * Set of mask chars
	 * {object}
	 */
	masks: {},
	
	modifiedRights: {},
	
	shortTables: {},
	
	tablesFilterState: "all",
	
	SEARCHLIST: [],
	
	menuOrderedTables: null,

	alphaOrderedTables: null,
	
	disabledMode: false,
	
	allExpanded: false, 
	
	orderMethod: 'menu',
	
	constructor: function(cfg) {
		var pageObj = this;
		Runner.pages.RightsPage.superclass.constructor.call(this, cfg);
		
		this.groups = Runner.pages.PageSettings.getTableData(this.tName, "groups");
		this.savedRights = Runner.pages.PageSettings.getTableData( this.tName, "rights" );
		this.tables = Runner.pages.PageSettings.getTableData( this.tName, "tables" );
		this.pageMasks = Runner.pages.PageSettings.getTableData( this.tName, "pageMasks" );
		this.menuOrderedTables = Runner.pages.PageSettings.getTableData( this.tName, "menuOrderedTables" );
		this.alphaOrderedTables = Runner.pages.PageSettings.getTableData( this.tName, "alphaOrderedTables" );
		
		//	fill table short to full table name lookup object
		jQuery.each( this.tables, function(table) {
			pageObj.shortTables[ this[0] ] = table;
		});

	},
	
	init: function() {
		Runner.pages.RightsPage.superclass.init.call(this);

		Runner.addDisabledClass( $('#resetBtn') );
		Runner.addDisabledClass( $('#saveBtn') );
		$('.group').prop('disabled', false);
		
		this.initMasks();
		this.initSearchBox();
		this.initGroupsList();
		this.initSelGroup();
		this.initColumnHeaders();
		this.initRowHeaders();
		this.initCheckboxes();
		this.initRightsControls();
		this.initModifiedFilter();
		this.initOrderControl();
		this.initExpandAll();
		this.initExpandCollapseControls();
		this.initSave();
		this.initReset();
		this.initCopyPermissions();
		this.showHideRows();
	},
	
	/**
	 * initSelGroup
	 * Set attributes and properties
	 */
	initSelGroup: function() {
		var groupCount = 0;
		
		jQuery.each(this.groups, function() {
			++groupCount;
		});
		
		$('.group').attr('size', groupCount);
		
		if ( !$('.group :selected') ) {
			$('.group :first').prop('selected', true);
		}
	},
	
	/**
	 * Fill the masks object
	 */
	initMasks: function() {
		this.masks = {
			add: 'A',
			edt: 'E',
			del: 'D',
			lst: 'S',
			exp: 'P',
			imp: 'I',
			adm: 'M'
		}
	},
	
	/**
	 * initRightsControls
	 * Bind handlers with controls 
	 */
	initRightsControls: function() {
		var pageObj = this;
		
		$('#saveGroupBtn').click( function() {
			pageObj.save();
			return false;
		});
		
		$('#addGroupBtn').click( function(e) {
			if ( Runner.isDisabledButton( this ) ) {	
				return false;
			}
			
			pageObj.disableGroupButtons( true );
			
			$('.group').prop('disabled', true);
			$('.rnr-ugaddarea').show();
			
			$('.groupname').focus()
				.val( pageObj.makename( Runner.lang.constants.AA_GROUP_NEW ) );
				
			$('.gmessage').html( pageObj.TEXT_AA_ADD_NEW_GROUP );
			
			pageObj.renameidx = -1;
			
			return false;
		});
		
		$('#delGroupBtn').click( function(e) {
			if ( !Runner.isDisabledButton( this ) ) {	
				pageObj.deletegroup(); 
			}
			return false; 
		});
		
		$('#renGroupBtn').click( function(e) {
			var	selectedIdVal = this.currentGroup || $('.group option:selected').val(),
				selectedHtmlVal = pageObj.groups[ selectedIdVal ];
				
			if ( Runner.isDisabledButton(this) || selectedIdVal < 0  ) {	
				return false;
			}
			
			pageObj.disableGroupButtons( true );
			$('.group').prop('disabled', true);
			$('.rnr-ugaddarea').show();
			$('.groupname').focus()
				.val( selectedHtmlVal );
				
			$('.gmessage').html( pageObj.TEXT_AA_RENAMEGROUP );
			
			pageObj.renameidx = $('.group')[0].selectedIndex;
			
			return false;
		});
		
		$('.groupname').keydown( function(e) {
			if ( e.keyCode != 13 ) { 
				return; 
			} 
			pageObj.save(); 
			return false;
		});
		
		$('#cancelBtn').click(function() {
			pageObj.hideBrick('message');
			$('.rnr-ugaddarea').hide(); 
			$('.group').prop('disabled', false);
			
			pageObj.disableGroupButtons( false );
			
			if ( pageObj.renameidx >= 0 ) {
				$('.groupname').val('');
			}
		});
	},
	
	/**
	 * Disable 'Add', 'Del', 'Rename' buttons or enable it according to param
	 * @param {boolean} isDisable
	 */	
	disableGroupButtons: function( isDisable ) {
		if ( isDisable ) {
			Runner.addDisabledClass( $('#addGroupBtn') );
			Runner.addDisabledClass( $('#delGroupBtn') );
			Runner.addDisabledClass( $('#renGroupBtn') );
			Runner.addDisabledClass( $('#copyPermissions') );
		} else {
			Runner.delDisabledClass( $('#addGroupBtn') );
			Runner.delDisabledClass( $('#copyPermissions') );
			$('#addGroupBtn').prop('disabled', isDisable);
			this.setButtonsActiveState();
		}
	},
	
	/**
	 * Set state for Delete and Rename buttons according to selected group
	 */
	setButtonsActiveState: function() {
		if ( $('.group :selected').val() < 0 ) {
			Runner.addDisabledClass( $('#delGroupBtn') );
			Runner.addDisabledClass( $('#renGroupBtn') );
		} else {
			Runner.delDisabledClass( $('#delGroupBtn') );
			Runner.delDisabledClass( $('#renGroupBtn') );
			//class hover not init. reinit buttons
			this.initRunnerButtons();
			$('.groupname').val( this.groups[ $('.group :selected').val() ] );
		}
	},
	
	/**
	 * Delete selected group
	 */
	deletegroup: function() {
		var pageObj = this, 
			id = $('.group :selected').val(),
			ajaxParams = {
				id: id,
				a: 'del'				
			};
		
		if ( id < 0 ) {
			return;
		}
		
		if ( !confirm( Runner.lang.constants.AA_DELETEGROUP + " " + this.groups[ id ] + '?' ) ) { 
			return;
		}
		
		Runner.runnerAJAX( Runner.getPageUrl('ug_group'), ajaxParams, function( respObj ) {
			var groupCount = 0,
				newId;
			
			if ( !respObj.success ) {
				pageObj.replaceBrickContentHTMLWith('message', 'Error deleting record!');
				pageObj.showBrick('message'); 
				return;
			}
			
			pageObj.hideBrick('message');
			
			if ( !pageObj.groups.hasOwnProperty( id ) ) {
				pageObj.groups = Runner.apply( {}, pageObj.groups );
			} 
			delete pageObj.groups[ id ];
			
			if ( !pageObj.modifiedRights.hasOwnProperty( id ) ) {
				pageObj.modifiedRights = Runner.apply( {}, pageObj.modifiedRights );
			} 			
			delete pageObj.modifiedRights[ id ];
			
			newId = $('.group :selected').prev().val();
			
			$('.group :selected').remove();
			
			if (newId) {
				$(".group [value='" + newId + "']").prop('selected', true);
			} else {
				$('.group :first').prop('selected', true);
			}
			
			$('.group').trigger('change');
			pageObj.updateGroupsModifiedStates();
		});
	},
	
	/**
	 * Reset everything to saved values
	 */
	initReset: function() {
		var pageObj = this;
		
		$('#resetBtn').click( function() {
			if ( Runner.isDisabledButton( this ) ) {
				return false;
			}
			
			pageObj.modifiedRights = {};
			pageObj.groupListChange();
			pageObj.updateGroupsModifiedStates();
			return false;
		})
	},

	disableControls: function() {
		this.disabledMode = true;
		this.setPageModified( false );
		Runner.addDisabledClass( $('#resetBtn') );
		Runner.addDisabledClass( $('#saveBtn') );
	},

	enableControls: function() {
		this.disabledMode = false;
		this.setPageModified( true );
		Runner.delDisabledClass( $('#resetBtn') );
		Runner.delDisabledClass( $('#saveBtn') );
	},
	
	/**
	 * Save everything
	 */
	initSave: function() {
		var pageObj = this;
		
		$('#saveBtn').click( function(e) {
			if ( Runner.isDisabledButton( this ) ) {
				return false;
			}
			
			pageObj.disableControls();
			pageObj.hideMessage();
			
			$.ajax({
				type: "POST", 
				data: {
					values: JSON.stringify( pageObj.modifiedRights ),
					a: 'saveRights'
				},
				dataType: "json",
				error: function( jqXHR, textStatus, errorThrown ) {
					pageObj.displayMessage( textStatus + ' ' + errorThrown, true, true );
					pageObj.enableControls();
				},
				success: function( _respObj ) {
					var respObj = _respObj || { error:"Error. Null response"};
					if ( !respObj.success ) {
						pageObj.displayMessage( respObj.error, true, true );
						pageObj.enableControls();
						return;
					}
					//	merge modifiedRights into savedRights
					jQuery.each( pageObj.modifiedRights, function( group, permissionsObj ) {
						jQuery.each( permissionsObj, function( table, perm ) {
							if ( typeof pageObj.savedRights[ table ] == 'undefined' ) {
								pageObj.savedRights[ table ] = {};
							}
							pageObj.savedRights[ table ][ group ] = perm;
						});
					});
					
					pageObj.modifiedRights = {};
					pageObj.groupListChange();
					pageObj.updateGroupsModifiedStates();
					pageObj.disabledMode = false;
				}
			});
			return false;
		});
	},
	
	/**
	 * Make a name for a new group
	 * @param {string} groupName	The name of the previous group 
	 */
	makename: function( groupName ) {
		var n = 1,
			gr = $('.group option'),
			tgroupName = groupName,
			found;
			
		while (1) {
			found = false;
			jQuery.each( this.groups, function( groupId, groupName ) {
				if ( groupName == tgroupName ) {
					found = true;
					return false;
				}
			});
			if ( !found ) {
				return tgroupName;
			}
			tgroupName = groupName + n;
			n++;
		}
	},
	
	/**
	 * Save new group or save new name for the existing group
	 */
	save: function() {
		var pageObj = this,
			i, name, ajaxParams;
		
		for (i = 0; i < $('.group option').length; i++) {
			if ( this.groups[ $('.group option:eq(' + i + ')').val() ] == $('.groupname').val() && this.renameidx != i ) {
				pageObj.replaceBrickContentHTMLWith('message', 'Group with such name is allready exist!');
				pageObj.showBrick('message');
				return;
			}
		}
		
		if ( this.renameidx == -1 ) { // if add
			name = $('.groupname').val();
			ajaxParams = {
				name: name,
				a: 'add'
			};
			
			Runner.runnerAJAX( Runner.getPageUrl('ug_group'), ajaxParams, function( respObj ) {
				var groupCount = 0,	id;
				
				if (!respObj.success) {
					pageObj.replaceBrickContentHTMLWith('message', 'Error adding group!');
					pageObj.showBrick('message');
					return;
				}
				
				pageObj.hideBrick('message');
				$('.rnr-ugaddarea').hide();

				id = respObj.id; 
				pageObj.groups[ id ] = name;
				
				$('<option value="' + id + '">' + name + '</option>')
					.appendTo( $('.group') )
					.prop('selected', true);
				
				jQuery.each( pageObj.groups, function() {
					++groupCount;
				});
				
				$('.group').attr('size', groupCount);
				$('.group').trigger('change');
				$('.groupname').val('');
				$('.group').prop('disabled', false);
				
				pageObj.disableGroupButtons( false );
			});
			return;	
		}
		
		// if rename
		this.renameidx = -1;
		if ( this.groups[ $('.group :selected').val() ] == $('.groupname').val() ) {
			this.saveEnd();
			return;
		}
		
		ajaxParams = {	
			id: $('.group :selected').val(),
			name: $('.groupname').val(),
			a: 'rename'
		}
		
		Runner.runnerAJAX( Runner.getPageUrl('ug_group'), ajaxParams, function( respObj ) {
			if ( !respObj.success ) {
				pageObj.replaceBrickContentHTMLWith('message', 'Error renaming group!');
				pageObj.showBrick('message');
				return;
			}
			
			pageObj.groups[ $('.group :selected').val() ] = $('.groupname').val();
			$('.group :selected').html( $('.groupname').val() );
			pageObj.updateGroupModifiedState( $('.group :selected').val() );
			pageObj.saveEnd();
		});
	},
	
	/**
	 * Restore controls state after save
	 */
	saveEnd: function() {
		this.hideBrick('message');
		
		$('.rnr-ugaddarea').hide();
		$('.groupname').val('');
		$('.group').prop('disabled', false);
		
		this.disableGroupButtons(false);
	},
	
	/**
	 * Handle grid checkboxes clicks
	 */ 
	initCheckboxes: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$(".rightsTable").on("click", "td:has(.rnr-checkbox:not(.columnheader):not(.rowheader))", function( e ) {
			var $checkbox = $(e.target).add( $(e.target).find(".rnr-checkbox") )
					.filter( ".rnr-checkbox" ),
				checked = $checkbox.attr("data-checked") == "1",
				newchecked = checked ? "0" : "1",
				shortTable = pageObj.getTableNameFromBox( $checkbox.attr("id") ),
				table = pageObj.shortTables[ shortTable ],
				modifiedMask;
				
			if ( pageObj.disabledMode ) {
				return false;
			}
			
			if ( 0 == $checkbox.length ) {
				return;
			}
			
			$checkbox.attr("data-checked", newchecked);
			//	update modified state
			modifiedMask = pageObj.updateModifiedState( pageObj.readTablePermissionsFromGrid( shortTable ), shortTable );
			
			pageObj.updateRowModifiedState( shortTable, modifiedMask );
			pageObj.updateRowHeaderState( table );
			pageObj.updateColHeaderStates();
			pageObj.updateGroupsModifiedStates();
			
			return false;
		});
	},
	
	/**
	 * Handle clicks on the checkboxes in column headers
	 */
	initColumnHeaders: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$(".rightsTable").on("click", ".columnheader", function(e) {
			var $checkbox = $(e.target),
				perm = $checkbox.data("perm"),
				checked = $checkbox.attr("data-checked") == "1",
				newchecked = checked ? "0" : "1";

			if ( pageObj.disabledMode ) {
				return;
			}
			
			$(".rightsTable").find("[id^=box" + perm + "]:visible").each( function() {
				var shortTable = pageObj.getTableNameFromBox( this.id ),
					table = pageObj.shortTables[ shortTable ];
				
				//	no checkbox allowed ?
				if ( pageObj.pageMasks[ pageObj.shortTables[ shortTable ] ].indexOf( perm ) == -1 ) {
					return;
				}

				$( this ).attr("data-checked", newchecked);
				
				modifiedMask = pageObj.updateModifiedState( pageObj.readTablePermissionsFromGrid( shortTable ), shortTable );
				pageObj.updateRowModifiedState( shortTable, modifiedMask );
				pageObj.updateRowHeaderState( table );
			});
			
			pageObj.updateGroupsModifiedStates();
			$checkbox.attr("data-checked", newchecked);
		});
	},
	
	/**
	 *	Handle clicks on the checkboxes in row headers - near table names
	 */
	initRowHeaders: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$(".rightsTable").on("click", ".rowheader", function(e) {
			var $checkbox = $(e.target),
				checked = $checkbox.attr("data-checked") == "1",
				newchecked = checked ? "0" : "1",
				shortTable = $checkbox.data("table"),
				table = pageObj.shortTables[ shortTable ];
				
			if ( pageObj.disabledMode ) {
				return;
			}
				
			jQuery.each( pageObj.pageMasks[ table ].split(""), function() {
				pageObj.getBoxObj(this, shortTable)
					.attr("data-checked", newchecked);
			});
			
			$checkbox.attr("data-checked", newchecked);

			modifiedMask = pageObj.updateModifiedState( pageObj.readTablePermissionsFromGrid( shortTable ), shortTable );
			pageObj.updateRowModifiedState( shortTable, modifiedMask );
			pageObj.updateRowHeaderState( table );
			pageObj.updateColHeaderStates();
			pageObj.updateGroupsModifiedStates();
			
			return false;
		});
	},

	groupListChange: function() {
		var pageObj = this;
		
		this.currentGroup = $('.group :selected').val();
		
		//	update all checkboxes
		jQuery.each( this.tables, function( table ) {
			var tableRights = pageObj.getTableActivePermissions( table, pageObj.currentGroup ),
				shortName = this[0];
				
			jQuery.each( pageObj.masks, function( right, identifier ) {
				var checked = tableRights.indexOf( identifier ) > -1 ? "1" : "0";
				
				pageObj.getBoxObj(identifier, shortName)
					.attr("data-checked", checked);
			});
			
			pageObj.updateRowModifiedState( shortName, pageObj.getTableModifiedMask( table ) );
		});
		
		// apply modified filters
		this.updateRowHeaderStates();
		this.showHideRows();
	},
	
	/**
	 * Handle group list selection changes 
	 */
	initGroupsList: function() {
		var pageObj = this;
		
		// Handler for group list selected index changing
		$('.group').on('change', function(e) {
			pageObj.groupListChange();
			pageObj.setButtonsActiveState();
		});
		
		$('.group').change();
	},
	
	updateGroupHasVisibleItemsFlag: function( menuItem ) {
		var pageObj = this;
		
		menuItem.hasVisibleItems = false;
		if ( !menuItem.items ) {
			return;
		}
		
		jQuery.each( menuItem.items, function() {
			var subitem = pageObj.menuOrderedTables[ this ];
			
			pageObj.updateGroupHasVisibleItemsFlag( subitem );
			if ( subitem.table && pageObj.tables[ subitem.table ].visible || subitem.hasVisibleItems ) {
				menuItem.hasVisibleItems = true;
			}
		});
	},
	
	updateAllHasVisibleItemsFlags: function() {
		var pageObj = this;
		
		jQuery.each( this.menuOrderedTables, function() {
			if ( typeof this.parent === 'undefined' ) {
				pageObj.updateGroupHasVisibleItemsFlag( this );
			}
		});
	},
	
	/**
	 * Checks whether the item should be displayed according to groups expanded/collapsed state
	 */
	isItemInExpandedSet: function( menuItem ) {
		if ( typeof menuItem.parent === 'undefined' ) {
			return true;
		}
		
		if ( this.menuOrderedTables[ menuItem.parent ].collapsed ) {
			return false;
		}
		
		return this.isItemInExpandedSet( this.menuOrderedTables[ menuItem.parent ] );
	},
	
	/**
	 *	Refreshes the table list - displays and hides every single row there
	 */
	showHideRows: function() {
		var pageObj = this,
			displayGroupControls = false,
			indentTables = false,
			$table = $(".rightsTable");
		
		// apply search and modified filter, fill visible flag in tables
		jQuery.each( pageObj.tables, function( tableName, table ) {
			table.showOnModifiedMode = false;
			table.visible = pageObj.isTableDisplayed( tableName );
		});
		
		if ( this.orderMethod != 'menu' || this.tablesFilterState != 'all' ) {
			//	just show all tables with visible flag and hide those without it
			jQuery.each( pageObj.tables, function( tableName, table ) {
				var shortTable = table[ 0 ];
				pageObj.toggleElement( $("#row_" + shortTable), table.visible );
				table.showOnModifiedMode = table.visible;
			});
			
			//	hide non-table groups
			jQuery.each( pageObj.menuOrderedTables, function( idx ) {
				if ( this.table ) {
					return;
				}
				pageObj.toggleElement( pageObj.getGroupRow(idx), false );
			});	
		} else if ( !this.SEARCHLIST.length ) {
			//	show or hide according to group expanded state
			indentTables = true;
			jQuery.each( pageObj.menuOrderedTables, function( idx ) {
				if ( this["items"] ) {
					displayGroupControls = true;
				}
				pageObj.toggleElement( pageObj.getGroupRow( idx ), pageObj.isItemInExpandedSet( this ) );
			});
		} else {
			//	Search + menu ordered. 
			//	Display found elements with their parents
			this.updateAllHasVisibleItemsFlags();
			indentTables = true;
			
			jQuery.each( pageObj.menuOrderedTables, function( idx ) {
				var display = this.hasVisibleItems || this.table && pageObj.tables[ this.table ].visible;
				
				pageObj.toggleElement( pageObj.getGroupRow( idx ), display );
			});
		}
		
		pageObj.updateColHeaderStates();
		$("#expandAll").toggle( displayGroupControls );		
		$table.toggleClass( "groupcontrols", displayGroupControls );
		$table.toggleClass( "indenttables", indentTables );
	},
	
	/**
	 * Handle search box input
	 */
	initSearchBox: function() {
		var pageObj = this;
		
		$("#tableRightsSearch").on("input", function() {
			pageObj.SEARCHLIST = $(this).val().trim().toUpperCase().match(/[^\s]+/g) || [];
			pageObj.showHideRows();
		});
	},
	
	/**
	 * Returns grid checkbox jQuery object by permission and table name
	 * @param {string} perm
	 * @param {string} shortTable
	 * @retrun {jQuery object}
	 */
	getBoxObj: function( perm, shortTable ) {
		return $("#box" + perm + shortTable);
	},
	
	/**
	 * Receives permission state for the table read from checkboxes, say "AESP"
	 * Updates the modifiedRights object
	 * Compares it to the saved table permissions, say "DES"
	 * Returns the string with the list of modified permissions - "AP"
	 * @param {string} perm
	 * @param {string} shortTable
	 * @param {string} _group (optional)
	 * @return {string}
	 */
	updateModifiedState: function( perm, shortTable, _group ) {
		var group = _group || this.currentGroup,
			table = this.shortTables[ shortTable ],
			savedPerm = this.getTableSavedPermissions( table, group ),
			modifiedMask = this.comparePermissions( perm, savedPerm );

		//	update modifiedRights
		this.modifiedRights[ group ] = this.modifiedRights[ group ] || {};
	
		if ( modifiedMask ) {
			this.modifiedRights[ group ][ table ] = perm;
		} else {
			delete this.modifiedRights[ group ][ table ];
		}
		
		return modifiedMask;
	},
	
	/**
	 * Reads table permissions from the checkboxes in the grid and returns the permission mask: "ADES"
	 * @param {string} shortTable
	 * @return {string}
	 */
	readTablePermissionsFromGrid: function( shortTable ) {
		var pageObj = this,
			mask = "";
			
		jQuery.each( this.masks, function( right, identifier ) {
			if ( pageObj.getBoxObj(identifier, shortTable).attr("data-checked") == 1 ) {
				mask = mask + identifier;
			}
		});
		
		return mask;
	},
	
	/**
	 * Returns the set of saved permissions for the given table
	 * @param {string} table
	 * @param {string} _group (optional)
	 * @return {string}
	 */
	getTableSavedPermissions: function( table, _group ) {
		var group = _group || this.currentGroup;
		
		return ( this.savedRights[ table ] ? this.savedRights[ table ][ group ] : "" ) || "";
	},
	
	/**
	 * Returns the current (unsaved) set of permissions for the given table
	 * @param {string} table
	 * @param {string} _group (optional)
	 * @return {string}	 
	 */
	getTableActivePermissions: function( table, _group ) {
		var group = _group || this.currentGroup,
			modRights = this.modifiedRights[group],
			modifiedMask;
	
		if ( typeof modRights != "undefined" ) {
			modifiedMask = modRights[table];
			
			//	attention!! modifiedMask == ""  is a valid rights mask
			if ( typeof modifiedMask != "undefined") {
				return modifiedMask;
			}
		}
		
		return this.getTableSavedPermissions(table, group);
	},

	/**
	 * Colors the row with the given table.
	 * Cells appearing in modifiedMask become yellow.
	 * @param {string} shortTable
	 * @param {string} modifiedMask
	 */
	updateRowModifiedState: function( shortTable, modifiedMask ) {
		var $tableCell = $("#tblcell" + shortTable),
			tableModified = false;
		
		jQuery.each( this.masks , function( right, identifier ) {
			var $cell = $("#cell" + identifier + shortTable);
			
			$cell.toggleClass( "rights-modified", modifiedMask.indexOf( identifier ) > -1 );
			tableModified = tableModified || modifiedMask.indexOf( identifier ) > -1;
		});

		$tableCell.toggleClass("rights-modified", tableModified);
	},
	
	/**
	 * Read short table name from grid checkbox ID
	 * @param {string} _boxId
	 * @return {string}
	 */
	getTableNameFromBox: function( _boxId ) {
		var boxId = _boxId || "";
		
		return boxId.substring( 4 );
	},

	/**
	 * Handle all/modified rows dropdown. Filter tables by their modified state.
	 */
	initModifiedFilter: function() {
		var pageObj = this;
		
		( new Runner.linkSelectControl( $("#linkselectFilter").get(0) ) ).change( function() {
			pageObj.tablesFilterState = this.val();
			pageObj.showHideRows();
		});
	},
	
	
	/**
	 * Find which table permissions are modified (unsaved). Returns mask with modified permissions
	 * @param {string} table
	 * @param {string} _group (optional)
	 * @return {string}		 
	 */
	getTableModifiedMask: function( table, _group ) {
		return this.comparePermissions( 
			this.getTableSavedPermissions( table, _group ), 
			this.getTableActivePermissions( table, _group ) 
		);
	},
	
	/**
	 * Compares two permission masks. Returns the difference.
	 */
	comparePermissions: function( perm, savedPerm ) {
		var modifiedMask = "";
		
		jQuery.each(this.masks, function( right, identifier ) {
			if ( ( savedPerm.indexOf( identifier ) > -1 ) != ( perm.indexOf( identifier ) > -1 ) ) {
				modifiedMask = modifiedMask + identifier;
			}
		});
		return modifiedMask;
	},
	
	/**
	 * Checks whether there are any unsaved permissions for the given group
	 * @param {string} _group (optional)
	 * @return {boolean}	 
	 */
	areGroupPermissionsModified: function( _group ) {
		var group = _group || this.currentGroup,
			modRights = this.modifiedRights[ group ];
		
		if ( typeof modRights == 'undefined' ) {
			return false;
		}
		
		return !jQuery.isEmptyObject( modRights );
	},
	
	/**
	 * Marks group as modified in the group list
	 * @param {string} _group (optional)	 
	 */
	updateGroupModifiedState: function( _group ) {
		var group = _group || this.currentGroup,
			modified = this.areGroupPermissionsModified( group ),
			$option = $( '.group' ).find( '[value='+ group +']' ),
			label;

		label = this.groups[ group ];
		$option.text( modified ? label + ' (*)' : label );
	},
	
	/**
	 * Run updateGroupModifiedState for each group
	 */
	updateGroupsModifiedStates: function() {
		var pageObj = this, 
			isAnyModified = false;
		
		jQuery.each( this.groups, function( group, groupName ) {
			isAnyModified = isAnyModified || pageObj.areGroupPermissionsModified( group );
			pageObj.updateGroupModifiedState( group );
		});
		
		this.setPageModified( isAnyModified );
		Runner.toggleDisabledClass( $('#resetBtn'), !isAnyModified );
		Runner.toggleDisabledClass( $('#saveBtn'), !isAnyModified );
	},

	/**
	 * Sets proper state to the tri-state checkbox in the row header. 
	 *  checked when all boxes in a row a checked, unchecked when unchecked, mixed when mixed
	 * @param {string} table
	 */	
	updateRowHeaderState: function( table ) {
		var $checkbox = $('#rowbox' + this.tables[ table ][0] ),
			tableRights = this.getTableActivePermissions( table ),
			pageMask = this.pageMasks[ table ], 
			diff = this.comparePermissions(pageMask, tableRights);
		
		if ( tableRights && !diff ) { // all checked
			$checkbox.attr("data-checked", "1");
		} else if ( !tableRights && pageMask ) { // none checked
			$checkbox.attr("data-checked", "0");
		} else if ( tableRights && diff ) { // partially checked
			$checkbox.attr("data-checked", "2");
		} else { // no permission possible
			$checkbox.attr("data-checked", "-1");
		}
	},
	
	/**
	 * Runs updateRowHeaderState for all rows
	 */
	updateRowHeaderStates: function() {
		var pageObj = this;
		
		jQuery.each( this.tables, function( table ) {
			pageObj.updateRowHeaderState( table );
		});
	},
	
	/**
	 * Checks wheter the table shoud be displayed according to the current filtering criteria.
	 * Modified/unmodified, searching by names etc
	 * @param {string} table
	 * @return {boolean}
	 */
	isTableDisplayed: function( table ) {
		var CAPTION, TABLE, i,
			show = true;
		
		if ( this.SEARCHLIST.length != 0 ) {
			show = false;
			CAPTION = this.tables[ table ][1].toUpperCase();
			TABLE = table.toUpperCase();
			for (i = this.SEARCHLIST.length - 1; !show && i >= 0 ; --i) {
				show = this.SEARCHLIST[i] && ( TABLE.indexOf( this.SEARCHLIST[i] ) >= 0 || CAPTION.indexOf( this.SEARCHLIST[i] ) >= 0 );
			}
		}
		
		//	check modified filter state
		return show && ( this.tablesFilterState == 'all' || this.getTableModifiedMask( table ) != "" || ( this.tablesFilterState == 'modified' && this.tables[ table ].showOnModifiedMode ) );
	},

	/**
	 * Sets proper state to the tri-state checkbox in the column header. 
	 * Counts displayed rows only.
	 * Sets it checked when all boxes in a column a checked, unchecked when unchecked, mixed when mixed
	 */	
	updateColHeaderStates: function() {
		var pageObj = this,
			colBoxStates = {A:-1, D:-1, E:-1, S:-1, P:-1, I:-1, M:-1};
					
		jQuery.each( this.tables, function( table ) {
			var tableRights, pageMask, finish = true;
			if ( !pageObj.isTableDisplayed( table ) ) {
				return;
			}
			
			tableRights = pageObj.getTableActivePermissions( table ),
			pageMask = pageObj.pageMasks[ table ];
			jQuery.each( colBoxStates, function( perm, state ) {
				/*
				 *	Some magic follows. 
				 *	2 - mixed state of a checkbox - when both checked and unchecked values present
				 *	0 - unchecked
				 *	1 - checked
				 * 	-1 - initial and empty state - when there are no checkboxes to represent. 
				 */
				if ( state == 2 ) {
					return;
				}
				
				finish = false; //	see the comment below
				if ( pageMask.indexOf(perm) == -1 ) {
					return;
				}
				
				if ( tableRights.indexOf(perm) == -1 ) {
					if ( state == -1 ) {
						colBoxStates[ perm ] = 0;
					} else if ( state == 1 ) {
						colBoxStates[ perm ] = 2;
					}
				} else {
					if ( state == -1 ) {
						colBoxStates[perm] = 1;
					} else if ( state == 0 ) {
						colBoxStates[perm] = 2;
					}
				}
			});
			
			if ( finish ) { // all permissions are in mixed state (2), exit
				return false;
			}
		});
		
		jQuery.each( colBoxStates, function( perm, state ) {
			$("#colbox" + perm).attr("data-checked", state);
		});
	},
	
	orderTablesAlphabetically: function() {
		var $row = $(".rightsTable").find("tr.rnr-row:first"),
			idx = 0,
			table, $insertRow, rowid;
			
		while( $row.length ) {
			if ( idx >= this.alphaOrderedTables.length) {
				break;
			} else {
				table = this.alphaOrderedTables[idx];
				rowid = "row_" + this.tables[ table ][0];
				if ( $row.get(0).id != rowid ) {
					$insertRow = $("#" + rowid);
					$insertRow.insertBefore( $row );
					$row = $insertRow;
				}
			}
			++idx;
			$row = $row.next();
		}
		this.showHideRows();
	},
	
	orderTablesAsMenu: function() {
		var $row = $(".rightsTable").find("tr.rnr-row:first"),
			idx = 0,
			table, title, id, $insertRow, rowid;
			
		while ( $row.length && idx < this.menuOrderedTables.length ) {
			if ( idx >= this.menuOrderedTables.length ) {
				break;
			}
			
			table = this.menuOrderedTables[ idx ].table;
			if ( table ) {
				rowid = "row_" + this.tables[ table ][0];
			} else {
				rowid = "grouprow_" + idx;
			}
			if ( $row.get(0).id != rowid ) {
				$insertRow = $("#" + rowid);
				$insertRow.insertBefore( $row );
				$row = $insertRow;
			}
			++idx;
			$row = $row.next();
		}
		this.showHideRows();
	},
	
	initOrderControl: function() {
		var pageObj = this;
		
		( new Runner.linkSelectControl( $("#linkselectOrder").get(0) ) ).change( function() {
			pageObj.orderMethod = this.val();
			if ( pageObj.orderMethod == 'menu' ) {
				pageObj.orderTablesAsMenu();
			} else {
				pageObj.orderTablesAlphabetically();
			}
		});
		
		$('#orderTables').change( function() {
			pageObj.orderMethod = $(this).val();
			if ( pageObj.orderMethod == 'menu' ) {
				pageObj.orderTablesAsMenu();
			} else {
				pageObj.orderTablesAlphabetically();
			}
		});
		
	},
	
	initExpandAll: function() {
		var pageObj = this;
		
		$("#expandAll").on('click', function(e) {
			jQuery.each( pageObj.menuOrderedTables, function( groupId ) {
				if ( !this.items ) {
					return;
				}
				pageObj.expandGroup( groupId, !pageObj.allExpanded);
			});
			
			pageObj.allExpanded = !pageObj.allExpanded;
			$(this).text( pageObj.allExpanded ? Runner.lang.constants.TEXT_COLLAPSE_ALL : Runner.lang.constants.TEXT_EXPAND_ALL );
		});
	},

	getGroupRow: function( groupId ) {
		var table = this.menuOrderedTables[ groupId ].table;
		
		return table ? $("#row_" + this.tables[ table ][ 0 ]) : $("#grouprow_" + groupId);
	},
	
	expandGroup: function( groupId, toExpand ) {
		var pageObj = this,
			$tr = this.getGroupRow( groupId ),
			menuItem = pageObj.menuOrderedTables[groupId];
			
		menuItem.collapsed = !toExpand;
		$tr.find(".rnr-expandCollapse").attr( "data-state", toExpand ? "open" : "closed");
		this.showHideRows();
	},

	initExpandCollapseControls: function() {
		var pageObj = this;
		
		//	click on a checkbox or its parent
		$(".rightsTable").on("click", "tr:has(.rnr-expandCollapse)", function( e ) {
			var $target = $(e.target);
				$tr = $target.closest("tr"),
				groupId = $tr.data("groupid") || 0,
				toExpand = ( pageObj.menuOrderedTables[ groupId ].collapsed == true );
				
			pageObj.expandGroup( groupId, toExpand );
		});
	},
	
	copyGroupPermissions: function( from ) {
		var pageObj = this;
		
		jQuery.each( this.tables, function( table ) {
			var shortTable = this[0],
				rights = pageObj.getTableActivePermissions( table, from ),
				modifiedMask = pageObj.updateModifiedState( rights, shortTable );
		});
		
		this.updateGroupsModifiedStates();
		$('.group').change();
	},
	
	initCopyPermissions: function() {
		var pageObj = this,
			args = {
				modal: true,
				centered: true,
				headerContent: Runner.lang.constants.AA_COPY_PERMISS_FROM,
				bodyContent: '<div id=groupCopySelector></div>'
			};
			
		$('#copyPermissions').on('click', function(e) {
			if ( Runner.isDisabledButton( this ) ) {	
				return false;
			}
			
			Runner.pages.PageManager.createFlyWin( args, false, function( win ) {
				var $list = $("#groupCopySelector");

				//	fill in groups list
				jQuery.each( pageObj.groups, function( groupId, groupName ) {
					var groupLink = $('<a class="groupCopyLink" href=#></a>')
						.text( groupName )
						.data('groupid', groupId);
						
					if ( groupId < 0) {
						groupLink.prependTo($list);
					} else {
						groupLink.appendTo($list);
					}
				});

				$list.on('click', 'a', function( e ) {
					pageObj.copyGroupPermissions( $(e.target).data('groupid') );
					win.destroy();
					return false;
				});
				
				Runner.pages.PageManager.correctYUIWindowSize( win, true );
			});
			return false;
		});
	},
	
	/** 
	 * Hide element with inline display style 
	 * Delete inline display style to show
	 * @param {jQuery elem} $elem
	 * @param {boolean} show
	 */
	toggleElement: function( $elem, show ) {
		if ( !show ) {
			$elem.hide();
		} else {
			$elem.css( 'display', '' );
		}
	}
});

Runner.linkSelectControl = ( function() {
	var _constructor = function( element ) {
		var _self = this, dispValue;
		//	fix input		
		if ( !(this instanceof _constructor) ) {
			return new _constructor( element );
		}
			
		this.$elem = $(element);
		this.$displayElem = this.$elem.find('.rnr-linkselect-display');
		this.$list = this.$elem.find('.rnr-linkselect-list');
		//	set initial value
		this.value = "";
		dispValue = this.$displayElem.text();
		this.$options = this.$elem.find('.rnr-linkselect-item');
		this.$options.each( function() {
			if ( dispValue == $(this).text() ) {
				$(this).attr("data-selected", "true");
				_self.value = $(this).data("value");
				return false;
			}
		});

		//	add mouse handlers		
		this.$elem.click( ".rnr-linkselect-item", function( e ) { 
			return _constructor.prototype.clickHandler.call( _self, e.target ); 
		});
		
		this.$elem.mouseover(function() {
			_self.$list.css('display', '');
		});
		
		return this;
	};
	
	// add change handler 
	_constructor.prototype.change = function( handler ) {
		var _self = this;
		this.$elem.change( function() { 
			handler.apply(_self, arguments); 
		});
	};

	// get value
	_constructor.prototype.val = function( ) {
		return this.value;
	};

	// click handler 
	_constructor.prototype.clickHandler = function( item ) {
		var $item = $(item);
		if ( typeof $item.attr('data-selected') != 'undefined' ) {
			return;
		}
		this.$options.removeAttr('data-selected');
		$item.attr('data-selected', 'true');
		this.value = $item.data('value');
		this.$displayElem.text( $item.text() );
		this.$elem.change();
		this.$list.hide();
	};
	
	return _constructor;
}());

Runner.pages.MembersPageAD = Runner.extend( Runner.pages.ListPageCommon, {
		
	pageType: Runner.pages.constants.PAGE_ADMIN_MEMBERS,
	
	rows: null,
	
	constructor: function(cfg) {
		Runner.pages.MembersPageAD.superclass.constructor.call(this, cfg);
		this.baseParams.id = this.pageId;
		this.bricksForReload = ["grid", "message", "pagination"];
		this.rows = this.controlsMap.gridRows;
	},

	destructor: function() {
		Runner.pages.MembersPageAD.superclass.destructor.call(this);
		this.pageCont = null;
		$('.group').prop('disabled', false);
		this.parObj.disableGroupButtons( false );
	},	
	
	init: function() {
		Runner.pages.ListPageFly.superclass.init.call(this);
		this.initButtons();
		this.initRows();
	},
	
	/**
	 * @param {object} row
	 */
	initAddGrLink: function( row ) {
		var pageObj = this;
		
		row.addGrLink = $('#iAddLink' + row.id).bind("click", function(e) {
			pageObj.addToGroup( row );
			return false;
		});
	},
	
	getSelections: function() {
		var selBoxesArr = [];
		$('input[type=checkbox][id^=check][name^=selection]:checked').each( function() {
			selBoxesArr.push( $(this) );
		});
		return selBoxesArr;
	},
	
	/**
	 * @param {object} row
	 */
	initCheckBoxGr: function( row ) {
		var pageObj = this;
		
		row.checkBoxGr = $('#check' + this.id + '_' + row.id).bind("click", function(e) {
			var selBoxesArr = pageObj.getSelections(),
				$addSelBtn = $('#addSelBtn');
			
			if ( selBoxesArr.length && Runner.isDisabledButton( $addSelBtn ) ) {
				Runner.delDisabledClass( $addSelBtn );
			} else if ( !selBoxesArr.length && !Runner.isDisabledButton( $addSelBtn ) ) {
				Runner.addDisabledClass( $addSelBtn );
			}
		});
	},
	
	initHeaderCheckBox: function() {
		var pageObj = this;
		
		$('.chooseAll' + pageObj.id).unbind("click").bind("click", function(e) {
			//set checked/unchecked for all checkbox in grid rows
			$('input[type=checkbox][id^=check' + pageObj.id + '_]').prop('checked', this.checked);

			//set checked/unchecked for all chooseAll checkboxes
			$('input[type=checkbox][id^=chooseAll_' + pageObj.id + ']').prop('checked', this.checked);

			var selBoxesArr = pageObj.getSelections(),
				$addSelBtn = $('#addSelBtn');
			
			if ( selBoxesArr.length && Runner.isDisabledButton( $addSelBtn ) ) {
				Runner.delDisabledClass( $addSelBtn );
			} else if ( !selBoxesArr.length && !Runner.isDisabledButton( $addSelBtn ) ) {
				Runner.addDisabledClass( $addSelBtn );
			}
			
		});
	},
	
	/**
	 * @param {object} row
	 */ 
	initRow: function( row ) {
		this.initAddGrLink( row );
		this.initCheckBoxGr( row );
	},
	
	initRows: function() {
		for (var i = 0; i < this.rows.length; i++) {
			this.initRow( this.rows[i] );
		}
	},
	
	getRowById: function(rowId) {
		for (var i = 0; i < this.rows.length; i++) {
			if (this.rows[i].id === rowId) {
				return this.rows[i]; 
			}
		}
		return false;
	},
	
	initButtons: function() {
		var pageObj = this,
			$addSelBtn = $('#addSelBtn').unbind('click').click( function(e) {
				if ( !Runner.isDisabledButton(this) ) {	
					pageObj.addSelectedToGroup();	
				}
				return false;
			});
		
		Runner.addDisabledClass( $addSelBtn );
	},
	
	/**
	 * Resize don't use on the list lookup
	 */
	initResize: Runner.emptyFn,

	initSearch: function() {
		this.searchController = new Runner.search.SearchController({
			id: this.pageId,
			tName: this.tName,
			fNamesArr: this.controlsMap.search.allSearchFields,
			shortTName: this.shortTName,
			usedSrch: this.controlsMap.search.usedSrch,
			panelSearchFields: this.controlsMap.search.panelSearchFields,
			ajaxSubmit: true,
			useSuggest: false,
			pageType: this.pageType
		});
		
		this.searchController.init( this.controlsMap.search.searchBlocks );
		this.searchController.srchForm.baseParams = this.baseParams;
		
		this.searchController.srchForm.on("beforeSubmit", function(form) {
			this.preparePageForReloading( this.win.bodyNode.getDOMNode() );
		}, this);
		
		this.searchController.on('afterSearch', function(respObj, srchController, srchForm) {
			Runner.stopLoading( this.win.bodyNode.getDOMNode() );
			this.pageReloadHn( respObj );
			this.searchController.toggleShowAll( this.searchController.usedSrch )
		}, this);
		
		this.searchController.srchForm.on('submitFailed', function() {
			Runner.stopLoading( this.win.bodyNode.getDOMNode() );
		}, this);
		
	},
	
	initInline:  Runner.emptyFn,

	/**
	 * Initialize the pagination block
	 * The 'pagination' brick  are not replaced after ajax reloading
	 * so it doesn't need reinitializing in pageReloadHn	 
	 */		
	initPagination: function() {
		var pageObj = this;	
		
		$.each( this.getBrickObjs('pagination'), function( index, brick ) {
			brick.elem.bind("click", function(e) {	
				Runner.Event.prototype.stopEvent(e);
				
				var $target = $(e.target),
					url;
					
				if ( !$target.is("a") ) {
					return;
				}
				
				if ( !Runner.isMobile ) {
					pageObj.preparePageForReloading();
				}
				
				url = Runner.pages.getUrl( pageObj.tName, pageObj.pageType, {} ) + "?goto=" + $target.attr("pageNum");
				
				Runner.runnerAJAX( url, pageObj.baseParams, function( respObj ) {
					pageObj.pageReloadHn( respObj )
				});
			});
		});
	},
	
	/**
	 * The page's after ajax reloading handler
	 * @param {Object} respObj
	 */	
	pageReloadHn: function( respObj ) {
		Runner.stopLoading( this.win.bodyNode.getDOMNode() );
		
		if ( respObj.success ) {
			Runner.setIdCounter( respObj.idStartFrom );
			
			// replace bricks			
			this.replaceBricksHTMLWith( this.getBricksHtml(respObj.html) );
			
			// set controlsMap
			this.controlsMap = respObj.controlsMap[ this.tName ][ this.pageType ][ this.pageId ];
			this.rows = this.controlsMap.gridRows;
			
			this.initButtons();
			this.initRows();
			this.initHeaderCheckBox();
			
			this.searchController.usedSrch = this.controlsMap.search.usedSrch;			
			this.searchController.toggleShowAll( this.searchController.usedSrch );
		} else {
			this.win.set('bodyContent', "REQUEST FAILED");
		}
	},
	
	addSelectedToGroup: function() {
		var row, i,
			pageObj = this,
			selBoxesArr = this.getSelections();	
		
		for (i = 0; i < selBoxesArr.length; i++) {
			row = pageObj.getRowById( parseInt( selBoxesArr[i].val(), 10 ) );
			if ( row ) {
				pageObj.addToGroup( row );
			}
		}
		
		pageObj.destructor();
		this.parObj.disableGroupButtons( false );
	},
	
	addToGroup: function( obj ) {
		var elemVal = obj.keys['name'],
			pageObj = this;
		
		if (elemVal == '') {
			return;
		}
		
		for (var groupId in pageObj.parObj.groups ) {
			if ( pageObj.parObj.groups[ groupId ] == elemVal ) {
				pageObj.replaceBrickContentHTMLWith('message', 'Group with such name is allready exist!');
				pageObj.showBrick('message');
				return;
			}
		}
		
		Runner.runnerAJAX( Runner.getPageUrl('admin_admembers', 'list'), {
				name: elemVal,
				a: 'addgr'
			},
			function( ret ) {
				var id = ret.id,
					groupCount = 0;
				
				if (!ret.success) {
					pageObj.replaceBrickContentHTMLWith('message', 'Error adding group!');
					pageObj.showBrick('message');
					return;
				}

				pageObj.parObj.groups[ id ] = elemVal;
				pageObj.hideBrick('message');
								
				$('<option value="' + id + '">' + elemVal + '</option>')
					.appendTo( $('.group') )
					.prop('selected', true);

				jQuery.each( pageObj.parObj.groups, function() {
					++groupCount;
				});
				
				$('.group').attr('size', groupCount);
				$('.group').trigger('change');
				$('.groupname').val('');
					
				$('input[type=checkbox][id^=check][name^=selection][value=' + obj.id + ']').hide();
				obj.addGrLink.hide();	
			}
		);
	}
});
Runner.pages.RightsPageAD = Runner.extend( Runner.pages.RightsPage, {
	/**
	 * initRightsControls
	 * Bind handlers with controls 
	 */
	initRightsControls: function() {
		var pageObj = this;
		
		$('#addGroupBtn').click( function(e) {
			if ( Runner.isDisabledButton( this ) ) {	
				return false;
			}
			
			pageObj.disableGroupButtons( true );
			$('.group').prop('disabled', true);
			pageObj.renameidx = -1;
			
			var pageParams = {
				tName: "admin_admembers",
				pageType: Runner.pages.constants.PAGE_LIST, 
				pageMode: Runner.pages.constants.MEMBERS_PAGE,
				parObj: pageObj,
				modal: true,
				baseParams: {
					table: "admin_admembers"
				}
			};
			Runner.pages.PageManager.openPage( pageParams );
			
			return false;
		});
		
		$('#delGroupBtn').click( function(e) {
			if ( !Runner.isDisabledButton( this ) ) {	
				pageObj.deletegroup(); 
			}
			return false; 
		});
	},
});
Runner.pages.ExportPage = Runner.extend( Runner.pages.RunnerPage, {
		
	pageType: Runner.pages.constants.PAGE_EXPORT,
	
	constructor: function(cfg) {
		Runner.pages.ExportPage.superclass.constructor.call(this, cfg);	
		this.submitUrl = Runner.pages.getUrl( this.tName, this.pageType );
	},
	
	init: function() {
		Runner.pages.ExportPage.superclass.init.call( this );	
		this.initButtons();
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	initButtons: function() {
		var pageObj = this;
		$("a[id=saveButton" + this.id + "]").bind("click", function(e) {
			pageObj.form = new Runner.form.BasicForm({
				submitUrl: pageObj.submitUrl,
				standardSubmit: true,
				method: 'POST',
				id: pageObj.pageId,
				baseParams: { 
					type: $('input[type=radio][name=type]:checked').val(),
					records: $('input[type=radio][name=records]:checked').val()
				}
			});
			
			pageObj.form.submit();
			pageObj.form.destructor();
			pageObj.form = null;
			
			return false;
		});	
	}
});
/**
 * The import page class
 */
Runner.pages.ImportPage = Runner.extend( Runner.pages.RunnerPage, {
	/**
	 * The current page type
	 * @type {string}
	 */		
	pageType: Runner.pages.constants.PAGE_IMPORT,

	/**
	 * URL where to submit import forms
	 * @type {string}
	 */
	submitUrl: "",	
		
	/**
	 * A flag indicating if a file or raw text is being imported
	 * @type {boolean}
	 */
	fileImport: true,

	/**
	 * A flag indicating if CSV type preview is applied 
	 * for importing data
	 * @type {boolean}
	 */
	CSVPreview: false,
	
	/**
	 * An object containing the import fields labels data
	 * @type {object}
	 */
	importFieldsLabels: {},
	
	/**
	 * An object containing data on correspondence
	 * between the import fields and table preview columns
	 * @type {object}
	 */
	columnsListData: null,	
	
	/**
	 * An object containing the jQuery objects 
	 * representing preview controls
	 * @type {object}
	 */	
	previewControls: null,
	
	/**
	 * An object representing the 'Upload file' button	
	 * @type {jQuery object} 
	 */
	$fileUploadButton: null,
	
	/**
	 * An object representing the 'Copy and paste Text' button	
	 * @type {jQuery object} 
	 */
	$textInsertButton: null,
	
	/**
	 * An object representing the 'Back' button		
	 * @type {jQuery object} 
	 */	
	$backButton: null,
	
	/**	
	 * An object representing the 'Import data' button	
	 * @type {jQuery object} 
	 */	
	$importButton: null,
	
	/**
	 * An object representing the 'Continue' button		
	 * @type {jQuery object} 
	 */		
	$continueTextImport: null,
	
	/**
	 * The flag indicating if the html5 File API is using 
	 * to upload a user's import file
	 * @type {boolean}
	 */
	fileUploaderSupported: false,
	
	/**
	 * The hidden file input element that is used
	 * to upload import files via File API
	 * @type {jQuery object}
	 */
	$hiddenFileInput: null,
	
	/**
	 * An object representing a drag-n-drop area 
	 * using to upload import files via File API
	 * @type {jQuery object}
	 */
	$dropZone: null,
	
	/**
	 * The import page's modes
	 * @type {object}
	 */
	modeConstants: {
		DATA_CHOOSING: 0,
		PREVIEW: 1,
		RESULTS: 2
	},
	
	/**
	 * The current import page's mode
	 * @type {number}
	 */
	importPageMode: 0,
	
	/**
	 * The hash to store import settings 
	 * with cookies
	 * @type {string}
	 */
	settingsHash: "",

	/**
	 * The list of fields identified as Dates in source excel file 
	 * in a form of an object: {Field1: true}
	 * @type {object}
	 */
	excelDateFields: {},
	
	
	/**
	 * @constructor
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		this.previewControls = {};
		
		Runner.pages.ImportPage.superclass.constructor.call( this, cfg );	
		
		this.importPageMode = this.modeConstants.DATA_CHOOSING;
		
		this.importFieldsLabels = Runner.pages.PageSettings.getTableData(this.tName, "importFieldsLables");
		this.submitUrl = Runner.pages.getUrl( this.tName, this.pageType );
		this.fileUploaderSupported = this.isAutoFileUploadSupported();		
	},
	
	/**
	 * Initialize the page's functionality
	 */
	init: function() {
		Runner.pages.ImportPage.superclass.init.call( this ) ;	
		
		this.initFileUploader();
		this.initButtons();
		
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},

	/**
	 * Check if the html5 File API and drag-n-drop functionality are supported by the browser
	 * return {boolean}
	 */
	isAutoFileUploadSupported: function() {
		var div = document.createElement('div'),
			dndSupport = 'draggable' in div || ('ondragstart' in div && 'ondrop' in div),
			xhr2Support = 'XMLHttpRequest' in window && 'withCredentials' in new XMLHttpRequest();
			
		return !!window.File && !!window.FileList && !!window.FormData && xhr2Support && dndSupport;
	},
	
	/**
	 * Initialize Import page buttons
	 */
	initButtons: function() {
		var pageObj = this;

		this.$fileUploadButton = $("a[id='uploadImportFile" + this.id + "']").on("click", function(e) {
			if ( pageObj.fileUploaderSupported ) {
				pageObj.$hiddenFileInput.trigger('click');
			} else {
				pageObj.showImportPreview();
			}
			
			return false;	
		});	
			
		this.$textInsertButton = $("a[id='switchToTextInsertion" + this.id + "']").on("click", function(e) {
			pageObj.switchToTextInput();
			return false;
		});
		
		this.$backButton = $( "a[id='backTo" + this.id + "']").on("click", function(e) {			
			pageObj.backToDataChoosing();	
			return false;
		});
		
		this.$continueTextImport = $( "a[id='continueTextImport" + this.id + "']").on("click", function(e) {
			if ( !Runner.isDisabledButton( this ) ) {
				$(this).hide();
				pageObj.showImportPreview();
			}
			return false;	
		});	
			
		this.$importButton = $("a[id='importButton" + this.id + "']").on("click", function(e) {	
			if ( !Runner.isDisabledButton( this ) ) {
				$(this).hide();
				pageObj.$backButton.hide();
			
				pageObj.importData();
			}
			return false;
		});		
		
		$("a[id='backToList" + this.id + "']").on("click", function(e) {		
			window.location.href = Runner.pages.getUrl( pageObj.tName, Runner.pages.constants.PAGE_LIST ) + "?a=return";
			return false;	
		});
	},
	
	/**
	 * Switch the page's appearance 
	 * to allow user to choose an importing data
	 */
	backToDataChoosing: function() {	
		if ( this.importPageMode === this.modeConstants.DATA_CHOOSING && !this.fileImport ) {
			this.switchToFileChoosing();	
		} else if ( this.importPageMode === this.modeConstants.PREVIEW ) {
			this.hideBrick("import_preview");
			this.$importButton.hide();
			
			if ( !this.fileImport ) {
				this.switchToTextInput();
			} else {
				this.switchToFileChoosing();
			}
		}
		
		this.importPageMode = this.modeConstants.DATA_CHOOSING;
	},

	/**
	 * Change the page's appearance 
	 * to allow user to choose a file to import
	 */
	switchToFileChoosing: function() {
		this.fileImport = true;
		
		this.showBrick("importheader_text");
		this.showBrick("importfields");	

		this.hideBrick("import_rawtext_control");
		
		this.toggleDropZone( false );
		
		this.$continueTextImport.hide();
		this.$backButton.hide();		
	},
	
	/**
	 * Change the page's appearance 
	 * to allow user to insert a csv content
	 */
	switchToTextInput: function() {
		this.fileImport = false;
		
		this.hideBrick("importheader_text");
		this.hideBrick("importfields");	
		this.showBrick("import_rawtext_control");
		
		this.$continueTextImport.show();
		this.$backButton.show();

		this.initTextArea();	
	},
	
	/**
	 * Initialize a text area control
	 */
	initTextArea: function() {
		if ( this.fileImport ) {
			return;
		}
		
		var $continueButton = this.$continueTextImport,
			$textArea;
		
		$textArea = $("#importText" + this.id)
			.on("keyup", function(e) {
				if ( Runner.isAcceptableKeyCode(e) ) {
					Runner.toggleDisabledClass( $continueButton, $textArea.val().trim() === "" );
				}
			})
			.on("change", function(e) {
				Runner.toggleDisabledClass( $continueButton, $textArea.val().trim() === "" );
			})
            .bind('paste', function(e){ 
				Runner.toggleDisabledClass( $continueButton, false ); 
			})
			.val("");
		
		this.initTextArea = function() {
			if ( !this.fileImport ) {
				Runner.toggleDisabledClass( $continueButton, $textArea.val().trim() === "");
				$textArea.focus();
			}		
		};
		
		this.initTextArea();
	},
	
	/**
	 * Initialize the file uploader controls
	 */
	initFileUploader: function() {
		if ( !this.fileUploaderSupported ) {
			// show the standard file input control to upload a user's import file
			$("#importUploadFallback" + this.id).show();
			return;
		}
		
		this.initDropZone();
		this.initHiddenFileInput();		
	},
	
	/**
	 * Initialize the drag-n-drop zone area 
	 */
	initDropZone: function() {		
		var pageObj = this;
		
		this.$dropZone = $("#importDropzone" + this.id, this.pageCont)		
			.on('drop', function(e) {
				if ( !pageObj.fileImport || pageObj.importPageMode !== pageObj.modeConstants.DATA_CHOOSING ) {
					return false;
				}
				
				var dataTransfer = e.originalEvent.dataTransfer,
					files = dataTransfer.files;
				
				pageObj.showImportPreview( files );
				pageObj.$dropZone.hide();				
				
				return false;
			})
			.on('click', function(e) {
				if ( pageObj.fileImport && pageObj.importPageMode === pageObj.modeConstants.DATA_CHOOSING ) {
					pageObj.$hiddenFileInput.trigger('click');
				}
				return false;
			});
			
		$( this.pageCont )
			.on('dragenter', function(e) {
				if ( pageObj.fileImport && pageObj.importPageMode === pageObj.modeConstants.DATA_CHOOSING  ) {
					pageObj.toggleDropZone( true );
				}
				return false;
			})		
			.on('dragover', function(e) {		
				return false;			
			})
			.on('drop', function(e) {
				setTimeout( function() {
					if ( pageObj.fileImport && pageObj.importPageMode === pageObj.modeConstants.DATA_CHOOSING ) {
						pageObj.toggleDropZone( false );
					}
				}, 400 );
				
				return false;
			});		
	},

	/**
	 * Toggle the dropzone interface
	 * @param {boolean} toggler
	 */ 
	toggleDropZone: function( toggler ) {
		if ( !this.fileUploaderSupported ) {
			return;
		}		
		
		this.$dropZone.toggle( toggler );
		
		this.$fileUploadButton.toggle( !toggler );
		this.$textInsertButton.toggle( !toggler );
		this.toggleBrick("importheader_text", !toggler);
	},
	
	/**
	 * Set up the fidden file imput element 
	 * that is used to upload import files via File API
	 */
	initHiddenFileInput: function() {
		var pageObj = this;
			
		if ( this.$hiddenFileInput && this.$hiddenFileInput.length ) {
			this.$hiddenFileInput.remove();
		}
		
		this.$hiddenFileInput = $('<input type="file" id="hiddenImpotFile' + this.id + '"></input>')
			.css('visibility', 'hidden')
			.appendTo( this.pageCont )	
			.on('change', function(e) {
				pageObj.showImportPreview( this.files );
				pageObj.initHiddenFileInput();
			});
	},	
	
	/**
	 * A wrapper for methods that show an import file/text preview
	 * using different types of data transport
	 * @param {FileList} files
	 */
	showImportPreview: function( files ) {
		this.importPageMode = this.modeConstants.PREVIEW;
		
		this.$importButton.show();
		this.$backButton.show();
		
		if ( this.fileImport && this.fileUploaderSupported ) {
			this.showImportPreviewUsingXHR( files );
			return;
		}
		
		this.showImportPreviewUsingIframe();
	},
	
	/**
	 * Show the import preview table and preview settings 
	 * for a file being uploaded via File API 
	 * @param {FileList} files
	 */
	showImportPreviewUsingXHR: function( files ) {
		if ( !this.fileUploaderSupported || !files || !files.length ) {
			return;
		}
		
		var formData = new FormData(), 
			pageObj = this;
		
		formData.append("useXHR", true);
		formData.append("id", this.pageId);
		formData.append("a", "importPreview");
		formData.append("importType", "file");
		formData.append( "importFile" + this.id, files[0] );
		
		$.ajax( {
			url: this.submitUrl,
			data: formData,
			type: "POST", 
			dataType: "json",
			processData: false,
			contentType: false,
			success: function( respObj ) {
				pageObj.processPreviewData( respObj );
			}		
		} );
	},
	
	/**
	 * Show the import preview table and preview settings
	 */
	showImportPreviewUsingIframe: function() {
		var pageObj = this,
			importFormParams = {
				baseParams: {
					id: this.pageId,
					a: "importPreview", 
					importType: this.fileImport ? "file" : "text"
				}
			};
		
		if ( this.fileImport ) {
			// add the file input element to the form
			importFormParams.addElems = [ $("#importFile" + this.id) ];
		} else {
			importFormParams.baseParams["importText"] = $("#importText" + this.id).val();
		}
		
		Runner.submitRunnerFormInIframe( this.submitUrl, importFormParams, function( respObj, formObj, fieldControls ) {
			pageObj.processPreviewData( respObj );
		});		
	},
	
	/**
	 * Fill in this.excelDateFields
	 * @param {object} respObj
	 */
	readExcelDateFieldsFromPreviewData: function( previewData ) {
		var i;
		this.excelDateFields = {};
		for( i = 0; i< previewData.fieldsData.length; ++i )
		{
			if( previewData.fieldsData[i].dateTimeType )
				this.excelDateFields[ previewData.fieldsData[i].fName ] = true;
		
		}
	},
	/**
	 * Process the preview data obtained
	 * @param {object} respObj
	 */
	processPreviewData: function( respObj ) {
		var previewData = respObj.previewData;
		
		if ( !previewData || Runner.isArray( previewData ) && !previewData.length ) { 
			// show the message
			return;
		}
		
		this.showBrick("import_preview");
		
		this.hideBrick("import_rawtext_control");
		this.hideBrick("importheader_text"); 
		this.hideBrick("importfields");
		
		this.generateSettingsHash( previewData );
		this.readExcelDateFieldsFromPreviewData( previewData );
		this.adjustPreviewSettings( previewData );
		this.initPreviewSettingsControls( previewData );	
		this.showPreviewData( previewData );
	},
	
	/**
	 * Generate the hash to store or 
	 * to retrieve import settings with cookies
	 * @param {object} previewData
	 * @return {string}
	 */
	generateSettingsHash: function( previewData ) {
		var firstLineData = previewData.CSVPreview ? this.getCSVTableData( [ previewData.CSVlinesData[0] ], previewData.delimiter ) : previewData.tableData[0],
			fieldsData = previewData.fieldsData || [],
			hashObj = { 
				cols: firstLineData.length 
			};		
			
		if ( !fieldsData.length ) { // if some columns names corresponds to the import fields
			hashObj["names"] = firstLineData;
		}
		
		this.settingsHash = Runner.md5( JSON.stringify( hashObj ) );
	},
	
	/**
	 * Adjust the preview settings data basing on
	 * the previously stored with cookies 
	 */
	adjustPreviewSettings: function( previewData ) {	
		var settingsCookie = get_cookie( "import_" + this.settingsHash ),
			storedSettings;
			
		if ( settingsCookie ) {
			storedSettings = JSON.parse( settingsCookie );
			
			previewData.useHeadersLine = storedSettings.useHeadersLine;
			previewData.fieldsData = storedSettings.importFieldsData;	
			
			if( storedSettings.dateFormat != "" )
				previewData.dateFormat = storedSettings.dateFormat;
			if ( previewData.CSVPreview ) {
				previewData.delimiter = storedSettings.delimiter;
			}			
		}
	},
	
	/**
	 * Initialize preview settings controls	
	 * @param {object} previewData
	 */
	initPreviewSettingsControls: function( previewData ) {		
		$("#dateFormatSettings" + this.id).toggle( !!previewData.dateFormat );
	
		this.previewControls["dateFormat"] = !previewData.dateFormat ? null : $("#importDateFormat" + this.id)
			.val( previewData.dateFormat );
		
		this.initHeaderInFirstLineControl( previewData.useHeadersLine );
		
		this.CSVPreview = previewData.CSVPreview;
		this.initCSVPreviewSettingsControls( previewData );
	},
	
	/**
	 * Initialize a checkbox indicating 
	 * if the first preview line represents table headers
	 * It should be initialized once
	 * @param {boolean} useHeadersLine (optional)
	 */
	initHeaderInFirstLineControl: function( useHeadersLine ) {
		var pageObj = this, 
			checked = useHeadersLine === undefined ? true : !useHeadersLine;
		
		this.previewControls["headersLineIsNotUsed"] = $("#columnsInFirstLine" + this.id)
			.prop("checked", checked)
			.on("change", function(e) {
				var toggler = $(this).prop("checked"),
					$headersTableRow = $("tr:first", "#importPreviewBodyTable" + pageObj.id);
				
				// change a background color for the column headers' line 
				$headersTableRow.toggleClass("rnr-import-disabled", toggler);
				pageObj.adjustImportPreviewButtons();
			});

		this.initHeaderInFirstLineControl = Runner.emptyFn;		
	},
	
	/**
	 * Initialize preview settings controls
	 * @param {object} previewData	 
	 */
	initCSVPreviewSettingsControls: function( previewData ) {
		$("#delimiterSettings" + this.id).toggle( !!this.CSVPreview );
		
		if ( !this.CSVPreview ) {
			return;
		}
		
		var pageObj = this,
			delimiter = previewData.delimiter || ",",
			$matchedRadio = $(".importDelimiters", this.pageCont).filter( function() {
					return this.value === delimiter;
				}).prop("checked", true);
		
		this.previewControls["customDelimiter"] = $("#customDelimiter" + this.id);
		
		this.previewControls["delimiters"] = $(".importDelimiters", this.pageCont)
			.unbind("change")
			.on("change", function(e) {
				var updatedPreviewData = $.extend( {}, previewData ),
					$radio = $(this),
					radioValue = $radio.val();
				
				updatedPreviewData.delimiter = radioValue !== "other" ? radioValue : pageObj.previewControls["customDelimiter"].val();	
				updatedPreviewData.fieldsData = pageObj.columnsListData;
				
				if ( updatedPreviewData.delimiter ) {	
					pageObj.showPreviewData( updatedPreviewData );
				}
			});
		
		if ( !$matchedRadio.length ) {
			$(".importDelimiters[value='other']", this.pageCont).prop("checked", true);
			this.previewControls["customDelimiter"].val( delimiter );
		}
	},
	
	/**
	 * Show the preview table data and initialize its controls
	 * @param {object} previewData	
	 */
	showPreviewData: function( previewData ) {
		if ( !previewData.tableData && !previewData.CSVlinesData ) {
			return;
		}
				
		var tableData = previewData.CSVPreview ? this.getCSVTableData( previewData.CSVlinesData, previewData.delimiter ) : previewData.tableData,
			fieldsData = previewData.fieldsData || [],
			dateFormat = previewData.dateFormat;
		
		this.setPreviewTableMarkup( tableData, fieldsData, dateFormat );
		this.initPreviewTableControls();

		if ( tableData.length === 1 && $.isEmptyObject( this.columnsListData ) ) {
			this.previewControls["headersLineIsNotUsed"].prop("checked", false);
		}
		
		this.adjustImportPreviewButtons( tableData.length );
	},
	
	/**
	 * @param {number} numberOfRows
	 */
	adjustImportPreviewButtons: function( numberOfRows ) {
		if ( numberOfRows === undefined ) {
			numberOfRows = $("tr", "#importPreviewBodyTable" + this.id).length;
		}
		
		Runner.toggleDisabledClass( this.$importButton, 
			!numberOfRows || numberOfRows === 1 && this.previewControls["headersLineIsNotUsed"].is(":checked") || $.isEmptyObject( this.columnsListData ) );
	},

	/**
	 * Set the import preview markup to the DOM
	 * @param {array} tableData
	 * @param {object} fieldsData
	 * @param {string} dateFormat
	 */	
	setPreviewTableMarkup: function( tableData, fieldsData, dateFormat ) {
		var $table = $( '#importPreviewBodyTable' + this.id ),
			$importGridHead = $( "#importGridHead" + this.id ),
			$tableHead = $( '<thead></thead>' ),
			$tableBody = $( '<tbody></tbody>' ),
			i, j, $tr, rowData, cellValue, headerName, headersColumn, $headTable;			
		
		for (j = 0; j < tableData[0].length; j++) {
			$('<th class="prvcell import-column-' + j + '"></th>')
				.html( this.getImportFieldsSelectMarkup( j, fieldsData[j] ? fieldsData[j].fName : '' ) )
				.appendTo( $tableHead );
		}
		
		for (i = 0; i < tableData.length; i++) {
			$tr = $('<tr></tr>');
			rowData = tableData[i];
			headersColumn = i === 0 && this.previewControls["headersLineIsNotUsed"].is(":checked");			
			
			if ( headersColumn ) {
				$tr.addClass("rnr-import-disabled");
			}
			
			for (j = 0; j < rowData.length; j++) {
				cellValue = rowData[j];
				if ( !headersColumn && cellValue && fieldsData[j] && this.excelDateFields[ fieldsData[j].fName ] && fieldsData[j].requireFormatting ) {
					cellValue = this.getDateFormattedValue( cellValue, dateFormat );
				}
				
				$('<td class="prvcell import-column-' + j + '"></td>').text( cellValue ).appendTo( $tr );
			}
			
			$tr.appendTo( $tableBody );
		}

		$table.children().remove();
		
		$table
			.append( $tableHead )
			.append( $tableBody );
		
		// set cells width
		$table.find( "th,td" ).each( function( cellId, cell ) {
			var $cell = $( cell ),
				unroundedWidth = window.getComputedStyle( $cell[0] ).width; // will return an unrounded calculation
			
			$cell.css( {
				"width": unroundedWidth,
				"min-width": unroundedWidth,
				"max-width": unroundedWidth
			});
			
			if ( $cell.is( "th" ) ) {
				$( "select", $cell ).css( "width", "100%" );
			}
		});
		
		$headTable = $( Runner.domShallowCopy( $table.get( 0 ) ) );
		$importGridHead.empty().height( $tableHead.height() ).append( $headTable );
		$headTable.attr( "id", "importPreviewHeadTable" + this.id ).css( "position", "absolute" ).append( $tableHead );
		
		$headTable.offset( { left: $table.offset().left } );
		$table.parent().scroll( function( e ) {
			$headTable.offset( { left: $table.offset().left } );
		});
	},
	
	/**
	 * Initalize the preview table controls
	 */
	initPreviewTableControls: function() {
		var pageObj = this,
			$previewTable = $('#importPreviewBodyTable' + this.id),
			// the import fields selectors
			$importcolumnsSelectors = $(".importColumnSelector", this.pageCont);
		
		this.columnsListData = {};
		
		$importcolumnsSelectors.on("change", function(e) {
			var	$select = $(this),
				currValue = $select.val(),
				idx = $select.data("idx");

			$(".import-column-" + idx, $previewTable)
				.toggleClass("rnr-import-disabledColumn", currValue === "" );	
				
			if ( currValue === "" ) {
				delete pageObj.columnsListData[ idx ];
				pageObj.adjustImportPreviewButtons();
				return false;
			}
			
			pageObj.columnsListData[ idx ] = { fName: currValue };
			pageObj.adjustImportPreviewButtons();
			
			$importcolumnsSelectors.not( this )
				.filter( function() {
					return $(this).val() === currValue;
				})
				.val( "" )
				.trigger("change");			
		});
		
		$importcolumnsSelectors.each( function(idx, select) {
			var currValue = $(this).val();
			
			$(".import-column-" + idx, $previewTable)
				.toggleClass("rnr-import-disabledColumn", currValue === "" );	
			
			if ( currValue !== "" ) {
				pageObj.columnsListData[ idx ] = { fName: $(this).val() };
			}
		});
	},
	
	/**
	 * Get a table-like data array basing on CSV lines data
	 * @param {array} lines
	 * @param {string} delimiter
	 * @return {array}
	 */
	getCSVTableData: function( lines, delimiter ) {
		var tableData = [], i;
		
		for (i = 0; i < lines.length; i++) {
			tableData.push( this.parceCSVLine( lines[i], delimiter ) );
		}
		
		return tableData;
	},
	
	/**
	 * Parse a CSV-like string with a prticular delimiter into an array
	 * @param {string} line
	 * @param {string} delimiter
	 * @return {array} 
	 */
	parceCSVLine: function( line, delimiter ) {
		if ( typeof line !== "string" ) {
			return [];
		}
		
		if ( line.charAt( line.length - 1 ) === '\n' ) {
			// remove \n at the end of the line
			line = line.slice(0, -1);
		}
		
		if ( !line.length ) {
			return [];
		}
		
		var currentChar, i, 
			cellValue = '', 
			quoted = false,
			cells = [];
			
		for (i = 0; i < line.length; i++) {
			currentChar = line.charAt( i );
			
			if ( currentChar === '"' ) {
				if ( !quoted ) {
					quoted = true;
				} else {
					if ( line.charAt( i + 1 ) === '"' ) {
						i = i + 1;
					} else {
						quoted = false;
					}
				}
				continue;
			}
			
			if ( currentChar === delimiter && !quoted ) {
				cells.push( cellValue );
				cellValue = '';
			} else {
				cellValue += currentChar;
			}
		}
		
		cells.push( cellValue );
		return cells;
	},
	
	/**
	 * @param {number} dateValue	A time stamp value in seconds
	 * @param {string} dateFormat
	 * @return {string}
	 */
	getDateFormattedValue: function( dateValue, dateFormat ) {
		if ( isNaN( parseInt(dateValue, 10) ) ) {
			return dateValue;
		}
		
		var date = new Date( dateValue * 1000 ),
			day = date.getDate(),
			month = date.getMonth() + 1,
			year = date.getFullYear(),
			formattedValue = dateFormat;
		
		formattedValue = formattedValue.replace(/yyyy/i, year);
		formattedValue = formattedValue.replace(/yy/i, year);
		formattedValue = formattedValue.replace(/MM/i, month < 10 ? '0' + month : month);
		formattedValue = formattedValue.replace(/M/i, month);
		formattedValue = formattedValue.replace(/dd/i, day < 10 ? '0' + day : day);
		formattedValue = formattedValue.replace(/d/i, day);
		
		return formattedValue;
	},
	
	/**
	 * Get markup for the preview dropdowns
	 * @param {number} idx
	 * @param {string} headerName
	 * @return {string}
	 */
	getImportFieldsSelectMarkup: function( idx, headerName ) {
		var optionsList = this.getImportFieldsOptions( headerName );
		
		return '<select class="importColumnSelector" data-idx="' + idx + '" id="importColumn' + idx + '">' + optionsList + '</select>';
	},
	
	/**
	 * Get a murkup for the preview dropdowns' options
	 * @param {string} headerName
	 * @return {string}
	 */	
	getImportFieldsOptions: function( headerName ) {
		var options = [ '<option value=""></option>' ],
			selectedAttr;	
		
		$.each( this.importFieldsLabels, function( fieldName, fieldLabel ) {
			selectedAttr = fieldName === headerName ? 'selected="selected"' : '';
			options.push( '<option value="' + fieldName + '" ' + selectedAttr + '>' + fieldLabel + '</option>' );
		});
		
		return options.join();
	},
	
	/**
	 * Get the user dateTime format
	 * @return {string}
	 */
	getImportDateFormat: function() {
		var $dateFomat = this.previewControls["dateFormat"];
		return $dateFomat && $dateFomat.length ? $dateFomat.val() : "";
	},
	
	/**
	 * Check if to use the headers' line data
	 * @return {boolean}
	 */
	isHeadersLineUsed: function() {
		return !this.previewControls["headersLineIsNotUsed"].prop("checked");
	},

	/**
	 * Get the delimiter for CSV-like import data
	 * @return {string}
	 */
	getImportDelimiter: function() {
		if ( !this.CSVPreview ) {
			return;
		} 	
		
		var	delimiter = this.previewControls["delimiters"]
				.filter(":checked").val();
		
		if ( delimiter === "other" ) {
			delimiter = this.previewControls["customDelimiter"].val();
		}
		
		return delimiter || ","; 
	},
	
	/**
	 * @return {object}
	 */
	getImportFieldsData: function() {
		return this.columnsListData;
	},
	
	/**
	 * Import data basing on user import settings
	 */
	importData: function() {		
		var pageObj = this,
			importData = {
				CSV: this.CSVPreview,
				delimiter: this.getImportDelimiter(),
				useHeadersLine: this.isHeadersLineUsed(),
				dateFormat: this.getImportDateFormat(),
				importFieldsData: this.getImportFieldsData()
			}, 
			ajaxParams = {
				a: "importData",
				importData: JSON.stringify( importData )
			};
			
		// show the fake progress
		this.showBrick("import_process");
		$("#importProgress" + this.id)
			.append( Runner.getLoadingBlock( Runner.lang.constants.IMPORT_PROCESSING_RECORDS ) );
		
		this.saveImportSettings( importData );
		
		Runner.runnerAJAX( this.submitUrl, ajaxParams, function( respObj, formObj, fieldControls ) {			
			pageObj.importPageMode = pageObj.modeConstants.RESULTS;
			
			$("#reportText" + pageObj.id).html( respObj.reportText );
			
			pageObj.showBrick("import_results");
			pageObj.hideBrick("import_preview");
			pageObj.hideBrick("import_process");
			
			pageObj.initalizeReportResultButtons( respObj.unprocessedRecordsNumber > 0 );
		});
	},
	
	/**
	 * Store the current import settings with cookies
	 * @param {object} importData
	 */
	saveImportSettings: function( importData ) {
		set_cookie( "import_" + this.settingsHash, JSON.stringify( importData ), '', Runner.getCookieRoot() );		
	},
	
	/**
	 * Initialize the report buttons
	 * @param {boolean} hasNotImportedRecords
	 */
	initalizeReportResultButtons: function( hasNotImportedRecords ) {
		var pageObj = this,
			saveReportSelectorBase = hasNotImportedRecords ? 'saveErrorReport' : 'saveReport';
		
		$("a[id='newImport" + this.id + "']").on("click", function(e) {		
			window.location.href = Runner.pages.getUrl( pageObj.tName, Runner.pages.constants.PAGE_IMPORT );
			return false;	
		}).show();
		
		$("a[id='" + saveReportSelectorBase + this.id + "']").on("click", function(e) {
			Runner.runnerAJAX( pageObj.submitUrl, { a: "downloadReport" }, function( respObj, formObj, fieldControls ) {
				//process errors
			});
			return false;
		}).show();
	
		if ( hasNotImportedRecords ) {
			$(".errorReportButtons" + pageObj.id).show();
			
			$("a[id='saveUnprocessedData" + this.id + "']").on("click", function(e) {
				Runner.runnerAJAX( pageObj.submitUrl, { a: "downloadUnprocessed" }, function( respObj, formObj, fieldControls ) {
					//process errors
				});
				return false;	
			});
		}
	}
});
Runner.pages.RegisterPage = Runner.extend( Runner.pages.RunnerPage, {
	
	submitUrl: "",
	
	registred: false,
	
	/**
	 * The name of the Password field
	 * @type {String}
	 */
	passFieldName: "",
	
	/**
	 * The name of the Username field (login)
	 * @type {String}
	 */
	userFieldName: "",
	
	/**
	 * The name of the User email field
	 * @type {String}
	 */
	emailFieldName: "",
	
	fileFieldsCount: 0,
	
	form: null,
	
	upploadErrorHappened: false,
	
	/**
	 * The object containig pairs a field name, a field control for
	 * teh passFieldName, userFieldName, emailFieldName fields if they are set fot the page
	 * @type {object}
	 */
	controls: {},
	
	/**
	 * The object cashing the Submit button's jQuery object 
	 * @type {object}
	 */
	saveButton: {},
	
	/**
	 * @constructor 
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		Runner.pages.RegisterPage.superclass.constructor.call(this, cfg);
		
		this.submitUrl = Runner.getPageUrl( Runner.pages.constants.PAGE_REGISTER );
		this.addEvents("beforeSave");
	},
	
	/**
	 *
	 */
	init: function() {
		Runner.pages.RegisterPage.superclass.init.call( this );
		
		if ( this.beforeSave ) {
			this.on( {'beforeSave': this.beforeSave} );
		}

		this.initFields();		
		this.initButtons();
		this.initControlEvents();
		this.addValidation();		
		
		if ( this.openMode === Runner.pages.constants.OPENMODE_POPUP ) {
			this.on('windowSizeCorrected', this.setFirstFocus);
		} else {
			this.setFirstFocus();
		}
		
		this.initPreValidation();
		
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	/**
	 * Assign the passFieldName, userFieldName, emailFieldName properties 
	 * with actual fields names and get their controls
	 */
	initFields: function() {
		var i, fName, realFieldName,
			fields = ["passFieldName", "userFieldName", "emailFieldName"];
		
		for (i = 0; i < fields.length; i++) {
			fName = fields[i];
			
			//get the actual database field's name
			realFieldName = Runner.pages.PageSettings.getTableData(this.tName, fName);	
					
			this[fName] = realFieldName;
			if (realFieldName) {
				this.controls[realFieldName] = Runner.getControl(this.pageId, realFieldName);	
			}
		}	
	},
	
	/**
	 * Add the 'IsEmail' validation to the emailFieldName field's control.
	 * Add the 'DenyDuplicated' validation and the custom validation failed message to the userFieldName field's control.
	 * Add the 'CheckStrongPassword' validation to the passFieldName field's control.
	 * Add the 'IsRequired' validation to the passFieldName, userFieldName, emailFieldName fields's control.
	 */
	addValidation: function() {
		var ctrlName, ctrl,
			ctrlEmail = this.controls[ this.emailFieldName ], 
			ctrlLogin = this.controls[ this.userFieldName ],
			ctrlPass = this.controls[ this.passFieldName ];
		
		if (ctrlEmail) {
			ctrlEmail.valueElem.attr('autocomplete', 'off');
			ctrlEmail.addValidation('IsEmail');
			ctrlEmail.addValidation('DenyDuplicated');
			ctrlEmail.customValidationFailedMessages['DenyDuplicated'] = {
				message: Runner.lang.constants.TEXT_INLINE_EMAIL_ALREADY1
					+ "&nbsp;<i>%value%</i>&nbsp;" 
					+ Runner.lang.constants.TEXT_INLINE_EMAIL_ALREADY2,
				messageType: 'Text'
			}
		}
			
		if (ctrlLogin) {
			ctrlLogin.valueElem.attr('autocomplete', 'off');
			ctrlLogin.addValidation('DenyDuplicated');
			ctrlLogin.customValidationFailedMessages['DenyDuplicated'] = {
				message: Runner.lang.constants.TEXT_INLINE_USERNAME_EXISTS1
					+ "&nbsp;<i>%value%</i>&nbsp;" 
					+ Runner.lang.constants.TEXT_INLINE_USERNAME_EXISTS2,
				messageType: 'Text'
			}
		}
		
		if ( ctrlPass && Runner.pages.PageSettings.getGlobalData("pwdStrong") ) {
			ctrlPass.addValidation('CheckStrongPassword');
		}
		
		for (ctrlName in this.controls) {
			ctrl = this.controls[ ctrlName ];	
			if (!ctrl) {
				continue;
			}
			
			if ( !ctrl.isSetValidation('IsRequired') ) {
				ctrl.addValidation('IsRequired');
			}
		}
	},
	
	/**
	 * Initialize the page's buttons
	 */
	initButtons: function() {
		var pageObj = this;
		
		this.saveButton = $("a[id=saveButton" + this.id + "]").bind("click", function(e) {
			var arrcntrl = Runner.controls.ControlManager.getAt(pageObj.tName),
				button = $(this),
				ctrl, index;
			
			button.addClass('disabled')
			pageObj.upploadErrorHappened = false;
			pageObj.fileFieldsCount = 0;
			
			for (index = 0; index < arrcntrl.length; index++) {
				ctrl = arrcntrl[index];
				
				if (ctrl.editFormat == Runner.controls.constants.EDIT_FORMAT_FILE && ctrl.filesToUploadCount > 0) {				
					pageObj.fileFieldsCount++;
					ctrl.errorHappened = false;
					ctrl.uploadForm.bind('fileuploadstopped', { ctrl: ctrl }, function(e, data) {
						pageObj.fileFieldsCount--;
						button.unbind('fileuploadstopped');
						if (e.data.ctrl.errorHappened) {
							pageObj.upploadErrorHappened = true;
							pageObj.callErrorHn();
						} else {
							pageObj.callSaveHn();
						}	
					});
					$(".btn-primary.start", ctrl.uploadForm).click();
				} 
			}
			
			if ( pageObj.fileFieldsCount < 1 ) {
				pageObj.callSaveHn();
			}
			
			return false;
		}); 
	},
	
	/**
	 * Error handler for fileuploadstopped event
	 */
	callErrorHn: function() {
		if (this.fileFieldsCount < 1) {
			this.saveButton.removeClass('disabled');
		}
	},
	
	/**
	 * Save handler for save button click event
	 */
	callSaveHn: function() {	
		if ( this.upploadErrorHappened || this.fileFieldsCount > 0 ) {
			return;
		}
				
		var form,
			pageObj = this;
		
		form = this.form || new Runner.form.BasicForm({
			id: this.pageId,
			method: 'POST',
			submitUrl: this.submitUrl,
			isFileUpload: true,
			standardSubmit: this.openMode !== Runner.pages.constants.OPENMODE_POPUP, 
			baseParams: {
				btnSubmit: "Register", 
				id: this.pageId, 
				onFly: this.openMode === Runner.pages.constants.OPENMODE_POPUP ? 1 : 0
			},
			fieldControls: Runner.controls.ControlManager.getAt(this.tName),
			beforeSubmit: {
				fn: function(formObj) {
					return this.fireEvent("beforeSave", formObj, formObj.fieldControls, this);
				},
				scope: this
			},
			successSubmit: {
				fn: function(respObj, basicForm, fieldControls) {
					var $procToLogin;
					
					if (respObj.html) {
						this.registred = true;
						this.win.set('bodyContent', respObj.html);
						
						$("a[id=closeWindowRegister]")
							.bind("click", function(e) {
								pageObj.openLoginPageOnPopUpClose();
								return false;
							})
							.show();
							
						$procToLogin = $("a[id=ProceedToLogin]").hide();
						if ( $procToLogin.length ) {
							this.saveButton.hide();
						} else {
							Runner.delDisabledClass( this.saveButton );
						}
					}
				},
				scope: this
			},
			validationFailed: {
				fn: function(formObj, fieldControls) {
					Runner.delDisabledClass( this.saveButton );
				},
				scope: this
			},
			submitFailed: {
				fn: function( response, formObj, fieldControls ) {
					Runner.delDisabledClass( this.saveButton );
				},
				scope: this
			},
		});
		this.form = form;
		this.setPageModified(false);
		form.submit();
	},
		
	/**
	 * Add the "password" and "confirm" field's "on blur" handlers, checking if their values are the same,
	 */
	initControlEvents: function() {
		var confirmCtrl = Runner.controls.ControlManager.getAt(this.tName, this.id, 'confirm'),
			passCtrl = this.controls[ this.passFieldName ];
		
		if (confirmCtrl) {
			passCtrl.on('blur', function(e) {
				if ( this.getValue() != confirmCtrl.getValue() && confirmCtrl.getValue() != "" ) {	
					confirmCtrl.markInvalidWidthCusttomMessages( "notMatchPasswords", [Runner.lang.constants.PASSWORDS_DONT_MATCH] );
					confirmCtrl.setValue('');
					confirmCtrl.setFocus();
					return;
				}
				confirmCtrl.clearInvalid();
			});
			
			confirmCtrl.on('blur', function(e) {
				if ( this.getValue() != passCtrl.getValue() ) {
					this.markInvalidWidthCusttomMessages( "notMatchPasswords", [Runner.lang.constants.PASSWORDS_DONT_MATCH] );
					this.setValue('');
					passCtrl.setValue('');
					passCtrl.setFocus();
					return;
				}
				this.clearInvalid();			
			});
		}
	},
	
	/**
	 * Marks the "username", "password" and/or "confirm" fields as invalid basing on fields error messages
	 */
	initPreValidation: function() {
		var invalidControls = [],
			userErrorMessage = Runner.pages.PageSettings.getTableData(this.tName, "msg_userError"),
			emailErrorMessage = Runner.pages.PageSettings.getTableData(this.tName, "msg_emailError"),
			passwordErrorMessage = Runner.pages.PageSettings.getTableData(this.tName, "msg_passwordError");
			
		if (userErrorMessage !== "") {
			this.controls[this.userFieldName].markInvalidWidthCusttomMessages( "userErrorMessage", [userErrorMessage] );
			invalidControls.push(this.controls[this.userFieldName]);
		}
		if (emailErrorMessage !== "") {
			this.controls[this.emailFieldName].markInvalidWidthCusttomMessages( "emailErrorMessage", [emailErrorMessage] );
			invalidControls.push(this.controls[this.emailFieldName]);
		}
		if (passwordErrorMessage !== "") {
			this.controls[this.passFieldName].markInvalidWidthCusttomMessages( "passwordErrorMessage", [passwordErrorMessage] );
			invalidControls.push(this.controls[this.passFieldName]);
		}
		this.setFirstFocus(this.id, invalidControls);
	},

	/**
	 *
	 */
	openLoginPageOnPopUpClose: function( notRedirect, hostPage ) {
		var	pageObj = this,
			user = this.registred ? this.controls[ this.userFieldName ].getValue() : '',
			pass = this.registred ? this.controls[ this.passFieldName ].getValue() : '';

		this.openLoginPage( user, pass, function() {
				pageObj.close();
			}, notRedirect, hostPage );
	}	
});
Runner.pages.ChangePwdPage = Runner.extend( Runner.pages.RunnerPage, {
	/**
	 * Form object
	 * @type {Object}
	 */
	form: null,
	/**
	 * Fields list
	 * @type {Object}
	 */
	fields: null,
	/**
	 * Submit URL string for form action
	 * @type {String}
	 */
	submitUrl: "",
	/**
	 * The object contain pairs a field name, a field control 
	 * for the oldPass, newPass and confirm fields 
	 * @type {object}
	 */
	controls: {},
	/**
	 * The object cashing the Submit button's jQuery object 
	 * @type {object}
	 */
	saveButton: {},
	/**
	 * The name of the Old Password field
	 * @type {String}
	 */
	oldPassFieldName: "oldpass", 
	/**
	 * The name of the New Password field
	 * @type {String}
	 */
	newPassFieldName: "newpass",
	/**
	 * The name of the Confirm Password field
	 * @type {String}
	 */
	confirmFieldName: "confirm",
		
	constructor: function(cfg) {
		Runner.pages.ChangePwdPage.superclass.constructor.call(this, cfg);
		this.fields = [this.oldPassFieldName, this.newPassFieldName, this.confirmFieldName];
		this.submitUrl = Runner.getPageUrl(Runner.pages.constants.PAGE_CHANGEPASS);
		this.addEvents("beforeSave");
	},
	
	init: function() {
		Runner.pages.ChangePwdPage.superclass.init.call(this);
		if (this.beforeSave) {
			this.on({'beforeSave': this.beforeSave});
		}

		this.initFields();		
		this.initButtons();
		this.initControlEvents();
		this.addValidation();		
		this.initPreValidation();
		
		this.setFirstFocus();
		this.fireEvent('afterInit', this, this.proxy, this.id);
	},
	
	/**
	 * Assign the passFieldName, userFieldName properties 
	 * with actual fields names and get their controls
	 */
	initFields: function() {
		for (var i = 0; i < this.fields.length; i++) {
			this.controls[this.fields[i]] = Runner.getControl(this.pageId, this.fields[i]);	
		}	
	},
	
	initButtons: function() {
		var pageObj = this;
		
		this.saveButton = $("a[id=saveButton" + this.id + "]").bind("click", function(e) {
			$(this).addClass('disabled')
			pageObj.callSaveHn();
			return false;
		}); 
	},
	
	callSaveHn: function() {
	
		var form = this.form || new Runner.form.BasicForm({
			id: this.pageId,
			method: 'POST',
			submitUrl: this.submitUrl,
			standardSubmit: true, 
			useMultipart: true,
			fieldControls: Runner.controls.ControlManager.getAt(this.tName),
			baseParams: {
				btnSubmit: "Change", 
				id: this.pageId, 
			},
			beforeSubmit: {
				fn: function(formObj) {
					return this.fireEvent("beforeSave", formObj, formObj.fieldControls, this);
				},
				scope: this
			},
			validationFailed: {
				fn: function(formObj, fieldControls) {
					Runner.delDisabledClass( this.saveButton );
				},
				scope: this
			},
			submitFailed: {
				fn: function( response, formObj, fieldControls ) {
					Runner.delDisabledClass( this.saveButton );
				},
				scope: this
			},
		});
		this.form = form;
		this.setPageModified(false);
		form.submit();
	},
	
	errorHn:function(row) {
		this.saveButton.removeClass('disabled');
	},
	
	/**
	 * Add the "new password" and "confirm password" field's "on blur" handlers, checking if their values are the same,
	 */
	initControlEvents: function() {
		
		var confirmCtrl = this.controls[ this.confirmFieldName ],
			newPassCtrl = this.controls[ this.newPassFieldName ];
			
		newPassCtrl.on('edited', function(e) {
			if ( this.getValue() != confirmCtrl.getValue() && confirmCtrl.getValue() != "" ) {	
				confirmCtrl.markInvalidWidthCusttomMessages( "notMatchPasswords", [Runner.lang.constants.PASSWORDS_DONT_MATCH] );
				confirmCtrl.setValue('');
				confirmCtrl.setFocus();
				return;
			}
			confirmCtrl.clearInvalid();
		});
		
		confirmCtrl.on('edited', function(e) {
			if ( this.getValue() != newPassCtrl.getValue() ) {
				this.markInvalidWidthCusttomMessages( "notMatchPasswords", [Runner.lang.constants.PASSWORDS_DONT_MATCH] );
				this.setValue('');
				newPassCtrl.setValue('');
				newPassCtrl.setFocus();
				return;
			}
			this.clearInvalid();			
		});		
	},
	
	/**
	 * Add the 'CheckStrongPassword' validation to the passFieldName field's control.
	 * Add the 'IsRequired' validation to the fields's control.
	 */
	addValidation: function() {
		var ctrlName, ctrl,
			newPassCtrl = this.controls[ this.newPassFieldName ];
		
		if ( newPassCtrl && Runner.pages.PageSettings.getGlobalData("pwdStrong") ) {
			newPassCtrl.addValidation('CheckStrongPassword');
		}
		
		for (ctrlName in this.controls) {
			ctrl = this.controls[ ctrlName ];	
			if (!ctrl) {
				continue;
			}
			
			if ( !ctrl.isSetValidation('IsRequired') ) {
				ctrl.addValidation('IsRequired');
			}
		}
	},
	
	/**
	 * Marks the fields as invalid basing on server error messages
	 */
	initPreValidation: function() {
		var passwordErrorMessage = Runner.pages.PageSettings.getTableData(this.tName, "msg_passwordError");
			
		if (passwordErrorMessage !== "") {
			this.controls[ this.newPassFieldName ].markInvalidWidthCusttomMessages( "passwordErrorMessage", [passwordErrorMessage] );
		}
	}	
});

/**
 * Search form controller. Need for submit form in advanced and panel mode
 */
Runner.search.SearchForm = Runner.extend( Runner.util.Observable, {	
	/**
	 * Id of page, used when page loades dynamicly
	 * @type {number}
	 */
	id: -1,
	
	/**
	 * Name of table for which instance of class was created
	 * @type {string}
	 */
	tName: "",

	/**
	 * Short table name, used for create urls
	 */
	shortTName: "",
	
	/**
	 * @type {string}
	 */
	pageType: "",

	/**
	 * Indicator. 
	 * True when simple search edit box get focus 
	 * @type {Boolean}
	 */
	usedSrch: false,
	
	/**
	 * @type {boolean}
	 */
	useSuggest: false,
	
	/**
	 * Type of search: panel on list, or advanced search page
	 * @type {string}
	 */
	searchType: "panel",

	/**
	 * Array of the search fields
	 */
	fNamesArr: [],
	
	/**
	 * @type {object}
	 */
	baseParams: {},

	/**
	 * Indicator showing if the search is required to show data
	 */
	isSearchRequired: false,
	
	/**
	 * Array containing the names of the required Search panel fields
	 * @param {Array}
	 */
	requiredSearchFields: null,
	
	/**
	 * jQuery obj
	 * @type {object} 
	 */
	srchForm: null,
	
	/**
	 * ctrls map. Used for indicate which index conected with which search ctrl
	 * @type {object}
	 */
	ctrlsShowMap: {},

	ajaxSubmit: false,
		
	optCombosArr: [],
	
	/**
	 * Array of user fields ojects
	 */
	searchFields: null,

	/**
	 * Search button object
	 * @type {jQuery object}
	 */
	searchButton: null,
	
 	/**
	 * jQuery obj of top radio with conditions
	 * @type {object}
	 */
	conditionRadioTop: null,
 
	/**
	 * The simple search edit box
	 * @type {jQuery object}
	 */
	smplSrchBox: null,
	
	/**
	 * jQuery object representing the page's DOM element allowing 
	 * to chose the search option ('Contains', 'Equals', etc.)
	 * @type {jQuery object} 
	 */
	simpleSrchTypeCombo: null,
	
	/**
	 * jQuery object representing the page's DOM element allowing 
	 * to chose a particular search field or the 'Any field' option 
	 * @type {jQuery object} 
	 */	
	simpleSrchFieldsCombo: null,
 
 
	/**
	 * Override parent contructor
	 * Add interaction with server
	 * @param {object} cfg
	 */
	constructor: function( cfg ) {
		this.fNamesArr = [];
		this.ctrlsShowMap = {};
		this.baseParams = {};
		this.searchFields = {};
		this.optCombosArr = [];
		this.requiredSearchFields = [];
		// copy properties from cfg to controller obj
		Runner.apply( this, cfg );

		Runner.search.SearchForm.superclass.constructor.call(this, cfg);

		// radio with contion choose or|and
		this.conditionRadioTop = $('input:radio[name=srchType' + this.id + ']');	
		 // Set the Simple search panel's search input elem
		this.smplSrchBox = $('#ctlSearchFor' + this.id);
		
		this.simpleSrchTypeCombo = $('#simpleSrchTypeCombo' + this.id);
		this.simpleSrchFieldsCombo = $('#simpleSrchFieldsCombo' + this.id);
		
		this.addEvents('beforeSearch', 'afterSearch');
	},

	init: function( ctrlsBlocks ) {
		this.initControlBlocks( ctrlsBlocks ); 
		this.initSearchFields();
		this.initSearchFieldsHandlers();
		this.initForm();
		this.initButtons();
	},

	/**
	 * Initialize the page's search form
	 */
	initForm: function() { 	
		this.srchForm = new Runner.form.BasicForm({
			id: this.id,
			addRndVal: false,
			isSearchForm: true,
			initImmediately: true,
			submitUrl: this.getSubmitUrl(),
			standardSubmit: !this.ajaxSubmit,
			baseParams: this.baseParams || {},
			method: this.ajaxSubmit ? "POST" : "GET"
		});
		
		this.srchForm.on('successSubmit', function( respObj ) {
			this.fireEvent('afterSearch', respObj, this, this.srchForm);
		}, this);
		
	},
	
	/**
	 * Returns the submit url for the form
	 * @description For the webreports' reports and charts it returns the URL in form of "dreport.ext"/"dcahrt.ext".
	 * For the report, chart and print pages It returns the URL in form of "<tableName>_repor.ext", "<tableName>_chart.ext", "<tableName>_print.ext".
	 * For all other pages it returns "<tableName>_list.ext".
	 * @return {String}
	 */
	getSubmitUrl: function() {
		//this.searchTableName is set for the search panel activated by adding the "searchpanel" brick to the page's layout 
		//It sets the real search table's name for the non table page's search panels 
		var tName = this.searchTableName || this.tName,
			pageType = this.pageType;
		
		//prepare tName, pageType params for the BasicForm's submitUrl generation		
		if ( this.pageType === Runner.pages.constants.PAGE_DREPORT || this.pageType === Runner.pages.constants.PAGE_DCHART ) {
			tName = "";
		} else if ( this.pageType !== Runner.pages.constants.PAGE_REPORT && this.pageType !== Runner.pages.constants.PAGE_CHART 
			&& this.pageType !== Runner.pages.constants.PAGE_PRINT && this.pageType !== Runner.pages.constants.PAGE_DASHBOARD 
			&& this.pageType !== Runner.pages.constants.PAGE_SEARCH ) {
			pageType = Runner.pages.constants.PAGE_LIST;
		}		
		
		return Runner.pages.getUrl( tName, pageType );	
	},

	/**
	 * Add on "change" handler to search fields search 
	 * options dropdowns. Add the corresponding dorpdown's 
	 * jQuery object to optCompoArr array.
	 * @param {number} recId
	 * @param {string} fName
	 * @param {Array} map
	 */
	initCombo: function( recId, fName, map ) {
		var comboId = this.getComboId( fName, recId ),
			$combo = $("#" + comboId),
			tName = this.tName,
			controller = this;	
			
		$combo.bind("change", function(e) {	
			var setEmpty = this.value === 'Empty' || this.value === 'NOT Empty',
				ctrl0 = Runner.controls.ControlManager.getAt( tName, recId, fName, 0 ),
				ctrl1;
			
			ctrl0.updateAppearance( this.value );
			
			ctrl0.toggle( !setEmpty );	
			controller.toggleSearhButtonStatus();
			
			if ( map.length === 2 ) {
				ctrl1 = Runner.controls.ControlManager.getAt( tName, recId, fName, 1 );
			}		
			if ( ctrl1 ) {
				ctrl1.toggle( this.value === 'Between' || this.value === 'NOT Between' );
			}	
		});
		
		this.optCombosArr.push( $combo );
	},
	
	/**
	 * Init common search page's buttongs
	 */
	initButtons: function() {				
		this.searchButton = $("a#searchButton" + this.id);
		this.initSearchButtonStatus();		
	},
		
	/**
	 * @param {Array} ctrlsBlocks
	 */
	initControlBlocks: function( ctrlsBlocks ) {
		for (var i = 0; i < ctrlsBlocks.length; i++) {
			this.addRegCtrlsBlock( ctrlsBlocks[i].fName, ctrlsBlocks[i].recId, ctrlsBlocks[i].ctrlsMap );
				
			if ( this.isSearchPanelInflexible ) { //is invoked for the Search Panel only
				//add the field's search option for the inflexible Search panel's field
				this.inflexSearchOptions[ ctrlsBlocks[i].fName ] = ctrlsBlocks[i].inflexSearchOption;
			}
		}
	},
	
	/**
	 * Look over all search field controls and 
	 * set search fields handlers using these controls
	 */
	initSearchFieldsHandlers: function() {
		var fName, recId, ctrlIndices, i, ctrl;
		
		for (fName in this.ctrlsShowMap) {
			for (recId in this.ctrlsShowMap[ fName ]) {
				ctrlIndices = this.ctrlsShowMap[ fName ][ recId ];
				
				for (i = 0; i < ctrlIndices.length; i++) {
					ctrl = Runner.controls.ControlManager.getAt( this.tName, recId, fName, ctrlIndices[i] );
					this.initSearchField( ctrl );
				}	
			}
		}
	},
	
	/**
	 * Init Search Suggest, add search field's object to the SearchFields, 
	 * set disablings/enabling Search button handlers for a required field
	 * @param {Object} ctrl
	 */	
	initSearchField: function( ctrl ) {
		if ( !ctrl ) {
			return;
		}

		if ( ctrl.ctrlInd === 0 && !ctrl.cached ) {
			//invoke "addSearchField" for the first control only
			//as far as It creates a new one Search Field instance
			//that then represents both the first and seconds controls
			this.addSearchField( ctrl.fieldName, ctrl.id );
		}
		this.initSuggest( ctrl );
		this.setHandlerForRequiredField( ctrl );
	},
	
	/**
	 * Init Seatch Suggest 
	 * @param {Object} ctrl
	 */
	initSuggest: function( ctrl ) {		
		if ( !this.useSuggest || !ctrl.useSearchSuggests() ) {
			return;
		}

		var searchController = this,
			$searchSuggestDiv = $("#search_suggest");
			
		//adjust the markup
		if ( !$searchSuggestDiv.length ) {
			$searchSuggestDiv = $('<div id="search_suggest"></div>').appendTo('body');
		}
		
		$searchSuggestDiv.addClass("search_suggest");
		
		ctrl.on('keyup', function(e) {	
			if ( !Runner.isAcceptableKeyCode(e) || !ctrl.implySuggests() ) {
				return;
			}

			if ( searchController.submitTimeout ) {
				clearTimeout( searchController.submitTimeout );
			}			

			searchController.submitTimeout = setTimeout( function() {			
				var srchTypeComboId = searchController.getComboId( searchController.tName, searchController.id ),
					srchTypeCombo = $('#' + srchTypeComboId),
					suggestUrl = Runner.getPageUrl( 'searchsuggest', '', 'table=' + searchController.shortTName );
			
				searchSuggest_new(e, ctrl, srchTypeCombo, 'advanced', suggestUrl);
			}, 700);
		});
		
		ctrl.on('keydown', function(e) {
			searchController.listenEvent( e, this.valueElem.get(0) );
		});
	},	
	
	/**
	 * Listen keyboard events in searchSuggest mode 
	 * @param {obj} oEvent
	 * @param {obj} oElement
	 */
	listenEvent: function( oEvent, oElement ) {		
		var searchController = this,
			iKeyCode = (window.event || oEvent).keyCode;
		
		switch ( iKeyCode ) {
			case 38: //up arrow
				if ( this.useSuggest ) {
					moveUp( oElement );
				}
			break;
			case 40: //down arrow
				if ( this.useSuggest ) {
					moveDown( oElement );
				}
			break;
			case 13: //enter
				if ( this.useSuggest ) {
					DestroySuggestDiv();
				}
				if ( !Runner.isDisabledButton( searchController.searchButton ) ) {
					searchController.submitSearch();
				}
			break;
			case 9:
				if ( this.useSuggest ) {
					DestroySuggestDiv();
				}
		}
	},
	
	/**
	 * Fill the search form with the saved search's params 
	 * and submit the form. The standart submit is used even
	 * for the pages with ajax search functionality
	 * @param {Object} searchParams
	 * It may contains: 
	 *	 'qs' The simple search params
	 *	 'q' The search panel's params	
	 *	 'f' The filters' params	
	 *	 'criteria' The search panel's criterion
	 */	
	submitSavedSearch: function( searchParams ) {
		this.ajaxSubmit = false;
		this.srchForm.baseParams = {};
		this.srchForm.standardSubmit = true; 
	
		var q = searchParams['q'], 
			qs = searchParams['qs'], 
			f = searchParams['f'], 
			criterion = searchParams['criteria'];
			
		this.fireEvent('beforeSearch', this, this.srchForm);
		this.srchForm.clearForm();
		this.srchForm.searchSubmit = true;	
		
		//add the Simple Search params to the form
		if ( qs !== undefined && qs !== '' ) {
			this.srchForm.addToForm( 'qs', qs );
			this.srchForm.addToSearchForm( 'qs', encodeURIComponent( qs ) );
		}	
		
		//add the Search panel params to the form
		if ( q !== undefined && q !== '' ) {
			this.srchForm.addToForm( 'q', q );
			this.srchForm.addToSearchForm( 'q', encodeURIComponent( q ) );
		}		
		
		//add the filters' params to the form
		if ( f !== undefined && f !== '' ) {
			this.srchForm.addToForm( 'f', f );
			this.srchForm.addToSearchForm( 'f', encodeURIComponent( f ) );
		}
		
		//add the search panel's criterion to the form
		if ( criterion && criterion !== 'and' ) {
			this.srchForm.addToForm( 'criteria', criterion );
			this.srchForm.addToSearchForm( 'criteria', encodeURIComponent( criterion ) );
		}

		if ( qs === '' && this.ajaxSubmit ) {
			this.srchForm.addToForm( 'q', '' );
		}

		//add the Cross table report's params to the form
		this.addCrossParams();
		
		this.srchForm.addToForm( 'savedSearch', true );
		this.srchForm.addToSearchForm( 'savedSearch', true );
		
		this.usedSrch = true;
		this.srchForm.submit();
	},
	
	/**
	 * Fill the search form params and submit it 
	 */
	submitSearch: function() {
		var simpleQuery;
	
		this.fireEvent('beforeSearch', this, this.srchForm);
		this.srchForm.clearForm();
		this.srchForm.searchSubmit = true;	

		//add the Simple Search params to the form
		simpleQuery = this.addSimpleQueryParams();
		//add the Search panel params to the form
		this.addAdvansedQueryParams( simpleQuery );
		//add the filters' params to the form
		this.addFilterParams();
		//add the search panel's criterion to the form
		this.addCriteriaParam();
		
		//add the Cross table report's params to the form
		this.addCrossParams();
		
		this.prepareForSearchSubmit();
		this.srchForm.submit();
	},

	/**
	 * Prepare search controller props for submit
	 */
	prepareForSearchSubmit: function() {
		this.usedSrch = true;
	},
	
	/**
	 * Add simple search params to the form
	 * @return {string}
	 */
	addSimpleQueryParams: function() {
		var i, valSeparator = '~', 
			simpleQuery = '', simpleQueryEncoded = '',
			simpleSrchTypeComboVal = this.simpleSrchTypeCombo.val(),
			simpleQueryArr = [ this.searchEscape( this.smplSrchBox.val() || "", true ), '', '' ];
		
		// for simple search with combos
		simpleQueryArr[1] = this.searchEscape( this.simpleSrchFieldsCombo.val() || "", true );
			
		//default combo value
		if ( simpleSrchTypeComboVal == 'Contains' ) {
			simpleSrchTypeComboVal = "";
		} else {
			simpleSrchTypeComboVal = Runner.pages.constants.SEARCH_OPTIONS[ simpleSrchTypeComboVal ];
		}
		simpleQueryArr[2] += simpleSrchTypeComboVal || "";
		
		for (i = simpleQueryArr.length - 1; i >= 0; i--) {
			simpleQuery = simpleQueryArr[i] + (simpleQuery == '' ? '' : valSeparator) + simpleQuery;
			simpleQueryEncoded = encodeURIComponent( simpleQueryArr[i] ) + (simpleQueryEncoded == '' ? '' : valSeparator) + simpleQueryEncoded;
		}
		
		if ( simpleQuery != '' ) {
			this.srchForm.addToForm('qs', simpleQuery);
			this.srchForm.addToSearchForm('qs', simpleQueryEncoded);
		}
	
		return simpleQuery;
	}, 
	
	/**
	 * Add a criteria param to the form
	 */
	addCriteriaParam: function() {
		var criterion = this.getSearchCriterion();
		
		if ( criterion !== 'and' ) {
			this.srchForm.addToForm( 'criteria', criterion );	
			this.srchForm.addToSearchForm( 'criteria', encodeURIComponent( criterion ) );		
		}
	},
	
	/**
	 * Get the search criterion
	 * @return {string}
	 */	 
	getSearchCriterion: function() {
		return this.conditionRadioTop.length ? this.conditionRadioTop.filter(':checked').val() : 'and';
	},
	
	/**
	 * Add search panel's and search page's params to the form
	 * @param {string} simpleQuery
	 */
	addAdvansedQueryParams: function( simpleQuery ) {
		var queryParams = this.getSearchControlsQueryParams(),
			query = queryParams['query'],
			queryEncoded = queryParams['queryEncoded'];
		
		if ( query != '' ) {
			this.srchForm.addToForm( 'q', query );
			this.srchForm.addToSearchForm( 'q', queryEncoded );	
			return;
		} 
		
		if ( simpleQuery == '' && this.ajaxSubmit ) {
			this.srchForm.addToForm( 'q', '' );
		}	
	},
	
	/**
	 * @return {object}
	 */
	getSearchControlsQueryParams: function() {
		var i, fName, ind,
			valSeparator = '~', 
			fieldSeparator = ')(',
			query = '', queryEncoded = '';			
			
		// add search params for each field
		for (fName in this.ctrlsShowMap) {
			// loop through all ctrls, except cached and deleted
			for (ind in this.ctrlsShowMap[ fName ]) {	
				var fMap = this.ctrlsShowMap[ fName ][ ind ], // get ctrls map for field name
					ctrl1 = Runner.controls.ControlManager.getAt( this.tName, ind, fName, fMap[0] ),
					srchCombo = $('#' + this.getComboId( fName, ind )),
					cachedRow = $("#" + this.getFilterRowId( fName, ind, this.srchWinShowStatus )),
					srchCheckBox = $('#' + this.getCheckBoxId( fName, ind )),
					fieldQuery = '', fieldQueryEncoded = '',
					comboVal, fieldArray;
					
				if ( !ctrl1.appearOnPage() ) { 
					continue;
				}
				//get the control's searh option 
				comboVal = srchCombo.length ? srchCombo.val() : this.getInflexSearchOption( fName );
					
				// add only non empty and not cashed vals
				if ( ctrl1.isEmpty() && comboVal.indexOf('Empty') == -1 || cachedRow.css('display') == 'none' ) {
					continue;
				}
				
				// define first value and type
				fieldArray = ['', this.searchEscape( ctrl1.getStringValue() ), ctrl1.ctrlType, ''];
				
				// define option
				if (comboVal != '') {
					if ( srchCheckBox.length && srchCheckBox.prop("checked") ) {
						comboVal = "NOT " + comboVal;
					}
					fieldArray[0] = Runner.pages.constants.SEARCH_OPTIONS[ comboVal ];
				}
				
				// if search type contains between and second ctrl exists
				if ( comboVal.toLowerCase().indexOf('between') !== -1 && fMap[1] ) {
					var ctrl2 = Runner.controls.ControlManager.getAt(this.tName, ind, fName, fMap[1]), 
						ctrl2Val = ctrl2.getStringValue();
						
					fieldArray[3] = this.searchEscape( ctrl2Val ); 
				}
				
				for (i = fieldArray.length; i--; ) {
					fieldQuery = fieldArray[i] + (fieldQuery == '' ? '' : valSeparator) + fieldQuery;
					fieldQueryEncoded = encodeURIComponent( fieldArray[i] ) + (fieldQueryEncoded == '' ? '' : valSeparator) + fieldQueryEncoded;
				}
				// add fName to query
				query += (query != '' ? fieldSeparator : '(') + this.searchEscape( fName ) + valSeparator + fieldQuery;
				queryEncoded += (queryEncoded != '' ? fieldSeparator : '(') + encodeURIComponent( this.searchEscape( fName ) ) + 
					valSeparator + fieldQueryEncoded;
			}
		}
		
		return {
			query: query === '' ? query : query + ')',
			queryEncoded: queryEncoded === '' ? queryEncoded : queryEncoded + ')'
		};
	},
	
	/**
	 * Add filters' params to the form
	 */
	addFilterParams: function() { 
		var i, ctrl, filterValue, filterValueEncoded, 
			query = '',	queryEncoded = '';
		
		if ( !this.filterControls || !this.filterControls.length ) {
			return;
		}
		
		for (i = 0; i < this.filterControls.length; i++) {
			ctrl = this.filterControls[i];

			filterValue = ctrl.getFilterValue();
			if ( filterValue ) {	
				query += filterValue;
				
				filterValueEncoded = ctrl.getFilterValueEncoded();
				queryEncoded += filterValueEncoded;
			}
		}
		
		if ( query === '' ) {
			queryEncoded = query ='all';
		}
		this.srchForm.addToForm( 'f', query );
		this.srchForm.addToSearchForm( 'f', encodeURIComponent( decodeURIComponent( queryEncoded ) ) );
	},
	
	/**
	 * @param {Mixed} value
	 * @param {Boolean} searchSimple
	 */
	searchEscape: function( value, searchSimple ) {
		if (typeof value == "object") {
			var formObj = this;
			$.each(value, function(index, element) {
				value[index] = formObj.searchEscape(value[index], searchSimple);
			});
			return value;
		} 
		value = value.replace("\\","\\\\").replace("~","\\~");
		if (searchSimple) {
			return value;
		}
		return value.replace(")(","\\)(");
	},
	
	/**
	 * Add params for crosstable report
	 */
	addCrossParams: function() {
		var grfunc_value, $grfunc;
		
		if ( !this.pageObj || !$("#select_group_x" + this.pageObj.id).length )	{
			return;
		}
		
		this.srchForm.addToForm( 'axis_x', $("#select_group_x" + this.pageObj.id).val() );
		this.srchForm.addToForm( 'axis_y', $("#select_group_y" + this.pageObj.id).val() );
		this.srchForm.addToForm( 'field', $("#select_data" + this.pageObj.id).val() );		
		
		$grfunc = $("input[name='group_func" + this.pageObj.id + "']:checked");
		
		if ( !$grfunc.length ) {
			grfunc_value = $("#group_func_hidden").val();
		} else {
			grfunc_value = $grfunc.val();
		}
		
		grfunc_value = grfunc_value === undefined ? 0 : grfunc_value;
		this.srchForm.addToForm('group_func', grfunc_value);
	},
		
	/**
	 * Register ctrl in show map
	 * @param {string} fName
	 * @param {number} ind
	 * @param {array} ctrlMap	A search control's indices array
	 */
	addToShowMap: function( fName, ind, ctrlMap ) {
		this.ctrlsShowMap[ fName ] = this.ctrlsShowMap[ fName ] || {};
		this.ctrlsShowMap[ fName ][ ind ] = ctrlMap;
	},
	
	/**
	 * Adds block to map, regs its components and ands HTML
	 * @param {string} fName
	 * @param {number} ind
	 * @param {array} ctrlMap
	 */
	addRegCtrlsBlock: function( fName, ind, ctrlMap ) {
		if ( ctrlMap ) {
			this.addToShowMap( fName, ind, ctrlMap );
		}
		this.initCombo( ind, fName, ctrlMap );
	},
	
	/**
	 * Return search type combo id
	 * @param {string} fName
	 * @param {int} ind
	 * @return {string}
	 */
	getComboId: function( fName, ind ) {
		return "srchOpt_" + ind + "_" + Runner.goodFieldName( fName );
	},
	
	/**
	 * Return filter div id
	 * @param {string} fName
	 * @param {int} ind
	 * @return {string}
	 */
	getFilterRowId: function( fName, ind ) {
		return "filter_" + ind + "_" + Runner.goodFieldName( fName );
	},
	
	/**
	 * Return search checkbox id
	 * @param {string} fName
	 * @param {int} ind
	 * @return {string}
	 */
	getCheckBoxId: function( fName, ind ) {
		return "not_" + ind + "_" + Runner.goodFieldName( fName );
	},
	
	/**
	 * Submit the 'Show all' search
	 */
	showAllSubmit: function() {
		this.srchForm.clearForm();
		this.srchForm.addToForm('a', 'showall');
		this.addCrossParams();

		this.prepareForShowAllSubmit();
		this.srchForm.submit();
	},
	
	/**
	 * Prepare search controller props for 'search all' submit
	 */
	prepareForShowAllSubmit: function() {
		this.usedSrch = false;
		
		this.simpleSearchActive = false;
		this.clearSimpleSearch();
		
		this.clearCtrls();
	},
	
	/**
	 * Submit the search form to return to the list page
	 */
	returnSubmit: function() {
		this.srchForm.clearForm();
		this.srchForm.addToForm('a', 'return');
		this.srchForm.submit();
	},
	
	/**
	 * Resets the form controls
	 */
	clearCtrls: function() {
		var $defaultOption, $select, i;
		Runner.controls.ControlManager.clearControlsForTable( this.tName );		
		for (i = 0; i < this.optCombosArr.length; i++) {
			$select = this.optCombosArr[i];
			if ( !$select.length ) {
				continue;
			}
			
			$defaultOption = $select.find('option[data-default-option]');
			$defaultOption = $defaultOption.length ? $defaultOption : $select.find('option').eq(0);
			
			$defaultOption.prop('selected', true);
			$select.change();
		}
		
		$("input[id^=not_]").prop('checked', false);
		this.conditionRadioTop.prop('checked', true);
	}, 
	
	/**
	 * Check there are a not empty search control on the page
	 * @return {Boolean}
	 */
	hasNotEmptyControl: function() {
		var fName, searchFields, i;
		
		for (fName in this.searchFields) {
			searchFields = this.searchFields[ fName ];
			
			for (i = 0; i < searchFields.length; i++) {
				if ( searchFields[i].checkIfCtrlsValuesSet() ) {
					return true;
				}
			}
		}
		
		return false;
	},
	
	/**
	 * Reset the Simple search controls' elements values
	 */
	clearSimpleSearch: function() {
		var defaultOption;
		
		this.smplSrchBox.val('');

		if ( this.simpleSrchFieldsCombo.length ) {
			defaultOption = $("option:visible:eq(0)", this.simpleSrchFieldsCombo).val(); 
			this.simpleSrchFieldsCombo.val( defaultOption );
		}
		if ( this.simpleSrchTypeCombo.length ) {
			defaultOption = $("option:visible:eq(0)", this.simpleSrchTypeCombo).val(); 
			this.simpleSrchTypeCombo.val( defaultOption );
		}
	},
	
	/**
	 * Init SearchFields object for all search fields
	 */
	initSearchFields: function() {
		for (var i = 0; i < this.fNamesArr.length; i++) {
			this.searchFields[ this.fNamesArr[i] ] = [];
		}
	},
	
	/**
	 * Creates a new SearchField object and adds it to 
	 * the SearchController's searchFields object
	 * @param {string} fName
	 * @param {integer} id
	 */
	addSearchField: function( fName, id ) {
		if ( !this.searchFields[ fName ] ) {
			return;
		}
				
		this.searchFields[fName].push( new Runner.search.SearchField({
				id: id,
				fName: fName,
				searchObj: this
			}) );
	},
	
	/**
	 * Set "change" event's handler for visible Search panel's ctrls
	 * @param {Object} ctrl
	 */
	setHandlerForRequiredField: function( ctrl ) {
		var searchController = this,
			$ctrlElem;
		
		if ( !this.isFieldRequired( ctrl.fieldName ) ) {
			return false;
		}		
		ctrl.on("editing", function() {
			searchController.toggleSearhButtonStatus();
		});
		// since the chosen search suggest fires the 'change' event
		ctrl.on("edited", function() {
			searchController.toggleSearhButtonStatus();
		});		
		
		$ctrlElem = ctrl.getDispElem(); // #8064
		if ( $ctrlElem instanceof jQuery ) {
			// #8064 it allows to handle the IE10 clear-button click
			$ctrlElem.on("input", function() {
				searchController.toggleSearhButtonStatus();
			});	
		}
	},
	
	/**
	 * Check if the field is search required or not 
	 * @param {String} fName
	 * @return {Boolean}
	 */ 
	isFieldRequired: function( fName ) {
		if ( $.inArray(fName, this.requiredSearchFields) === -1 ) {
			return false;
		}
		return true;
	},

	/**
	 * Set Search Button enabled/disabled basing on 
	 * the required search fields' ctrls values
	 */
	toggleSearhButtonStatus: function() {
		var requiredFieldsLength = this.requiredSearchFields.length,
			i, j, rfName, rfSearchFields, disable;
		
		if (!requiredFieldsLength) {
			return;
		}
		
		for (i = 0; i < requiredFieldsLength; i++) {	
			rfName = this.requiredSearchFields[i];
			rfSearchFields = this.searchFields[rfName];
			disable = true;
			
			for (j = 0; j < rfSearchFields.length; j++) {
				if ( rfSearchFields[j].checkIfCtrlsValuesSet() ) {
					disable = false;
					break;
				}
			}		
			
			if ( disable && ( this.simpleSrchFieldsCombo.val() !== rfName || this.smplSrchBox.val() === '' ) ) { 
				break;
			}
		}
		
		this.searchButton.closest('.rnr-button').toggleClass('disabled', disable);
	},

	/**
	 * If "Required Search to show data" is turned on 
	 * add "change" handlers to the simple search controls and
	 * and set the Search button enabled/disabled
	 */
	initSearchButtonStatus: function() {
		var searchController = this;
		
		if ( !this.requiredSearchFields.length ) {
			return false;
		}
	
		this.toggleSearhButtonStatus();
		
		this.simpleSrchFieldsCombo.on("change", function(e) {
			searchController.toggleSearhButtonStatus();
		});
		
		this.smplSrchBox.on("change", function(e) {
			searchController.toggleSearhButtonStatus();
		});	
	},
	
	/**
	 * Get the search params for a dashboard search page
	 * @param {boolean} showAllMode
	 * @return {object}
	 */
	getDashSearchParams: function( showAllMode ) {
		var searchParams = {},
			searchQueryParams;
		
		if ( showAllMode ) {
			searchParams['a'] = 'showall';
		} else {
			searchQueryParams = this.getSearchControlsQueryParams();
							
			if ( searchQueryParams['query'] ) {
				searchParams['q'] = searchQueryParams['query'];
				searchParams['criteria'] = this.getSearchCriterion();
			}
		}
		
		return searchParams;
	}	
});

Runner.search.options = {
	CONTAINS: "Contains",
	EQUALS: "Equals",
	STARTS_WITH: "Starts with",
	MORE_THAN: "More than",
	LESS_THAN: "Less than",
	BETWEEN: "Between",
	EMPTY: "Empty",
	
	NOT_CONTAINS: "NOT Contains",
	NOT_EQUALS: "NOT Equals",
	NOT_STARTS_WITH: "NOT Starts with",
	NOT_MORE_THAN: "NOT More than",
	NOT_LESS_THAN: "NOT Less than",
	NOT_BETWEEN: "NOT Between",
	NOT_EMPTY: "NOT Empty"
};

Runner.search.optionsText = {

	"Contains": Runner.lang.constants.CONTAINS,
	"Equals": Runner.lang.constants.EQUALS,
	"Starts with": Runner.lang.constants.STARTS_WITH,
	"More than": Runner.lang.constants.MORE_THAN,
	"Less than": Runner.lang.constants.LESS_THAN,
	"Between": Runner.lang.constants.BETWEEN,
	"Empty": Runner.lang.constants.EMPTY,
	
	"NOT Contains": Runner.lang.constants.NOT_CONTAINS,
	"NOT Equals": Runner.lang.constants.NOT_EQUALS,
	"NOT Starts with": Runner.lang.constants.NOT_STARTS_WITH,
	"NOT More than": Runner.lang.constants.NOT_MORE_THAN,
	"NOT Less than": Runner.lang.constants.NOT_LESS_THAN,
	"NOT Between": Runner.lang.constants.NOT_BETWEEN,
	"NOT Empty": Runner.lang.constants.NOT_EMPTY
};

/**
 * Global object for 
 * @object
 */
Runner.search.SearchField = Runner.extend(Runner.emptyFn, {
	/**
	 * Field name
	 * @type {string}
	 */
	fName: "",
	/**
	 * Field id
	 * @type {integer}
	 */
	id: 0,
	/**
	 * Select element with search options
	 * @type {object}
	 */
	opt: null,
	/**
	 * Search controller object
	 * @type {object}
	 */
	searchObj: null,
	
	constructor: function(cfg) {
		Runner.apply(this, cfg);
		this.init();
	},
	
	init: function() {
		this.opt = $('#' + this.searchObj.getComboId(this.fName, this.id)).get(0);
	},
	
	reInit: function() {
		if (!this.id) {
			this.getId();
		}
		this.init();
	},
	/**
	 * Is reinit was implemented successful
	 */
	isReInitSuccess: function() {
		if (typeof this.opt == 'undefined') {
			this.reInit();
			if (!this.id) {
				return false;
			}
		}
		return true;
	},
	/**
	 * Get field name
	 * @return {string}
	 */
	getName: function() {
		return this.fName;
	},
	/**
	 * Get field id
	 * @return {integer}
	 */
	getId: function() {
		if (!this.id) {
			var id = this.searchObj.getLastAddedInd(this.fName);
			if (!this.searchObj.isFieldShownById(this.fName, id)) {
				this.id = id;
			}
		}
		return this.id;
	},
	/**
	 * Get field control object
	 * @return {object}
	 */
	getControl: function() {
		return Runner.controls.ControlManager.getAt(this.searchObj.tName, this.id, this.fName);
	},
	/**
	 * Get second control object
	 * @return {object}
	 */
	getSecondControl: function() {
		return Runner.controls.ControlManager.getAt(this.searchObj.tName, this.id, this.fName, 1);
	},
	/**
	 * Get selected option value
	 * @param {string}
	 * @return {string}
	 */
	getOption: function() {
		if ( !this.isReInitSuccess() || !this.opt ) {
			return false;
		}
		for (var j = 0; j < this.opt.options.length; j++) {
			if (this.opt.options[j].selected) {
				return this.opt.options[j].value;
			}
		}
	},
	/**
	 * Set option value
	 * @param {string}
	 */
	setOption: function(value) {
		if (typeof value == 'undefined' || !value) {
			return;
		}
		if (!this.isReInitSuccess()) {
			return;
		}
		for (var j = 0; j < this.opt.options.length; j++) {
			if (this.opt.options[j].value == value) {
				this.opt.selectedIndex = j;
				$(this.opt).change();
				break;
			}
		}
	},
	/**
	 * Add new option 
	 * @param {string}
	 */
	addOption: function(value) {
		if (typeof value == 'undefined' || !value) {
			return;
		}
		if (!this.isReInitSuccess()) {
			return;
		}
		var text = Runner.search.optionsText[value];
		var opt = new Option(text, value);
		$(opt).html(text);
		$(this.opt).append(opt);
	},
	/**
	 * Get all options
	 * @param {string}
	 * @return {array}
	 */
	getOptions: function() {
		if (!this.isReInitSuccess()) {
			return false;
		}
		return this.opt.options;
	},
	/**
	 * Remove option
	 * @param {string}
	 */	
	removeOption: function(value) {
		if (!this.isReInitSuccess()) {
			return;
		}
		if (this.opt.options.length == 1) {
			this.searchObj.hideCtrlTypeCombo();
			return;
		}
		for (var j = 0; j < this.opt.options.length; j++) {
			if (this.opt.options[j].value == value) {
				if (this.opt.options[j].selected) {
					if (j == 0) {
						this.opt.selectedIndex = j + 1;
					} else {
						this.opt.selectedIndex = j - 1;
					}
				}
				this.opt.remove(j);
				break;
			}
		}
	},
	/**
	 * Remove field from serach panel
	 * @param {string}
	 */
	remove: function() {
		this.searchObj.deleteField(this.fName, this.id);
	},
	
	/**
	* Clear first and second search field's controls
	*/
	clearFieldCtrls: function() {
		var ctrl;
		
		ctrl = this.getControl();
		if (ctrl) {
			ctrl.clear();
		}
		
		ctrl = this.getSecondControl();
		if ( ctrl && !ctrl.spanContElem.is(":visible") ) {
			ctrl.clear();
		}
	},
	
	/**
	* Cheks if the Search field's controls are not empty 
	* @return {Boolean} 
	*/
	checkIfCtrlsValuesSet: function() {
		var ctrl, ctrl1,
			option = this.getOption();
		
		if ( option === "Empty" || option === "NOT Empty" ) {
			return true;
		}
		
		ctrl = this.getControl();
		if ( ctrl && ctrl.isEmpty() ) {
			return false;
		}
		
		ctrl1 = this.getSecondControl();
		if ( ctrl1 && ctrl1.spanContElem.is(":visible") && ctrl1.isEmpty() ) {
			return false;
		}
		
		return ctrl || ctrl1;
	}
});
/**
 * The method creating a Filter control basing on its format and other params
 *
 * @param {object} baseCfg
 * @param {object} searchController		The searchController obejct reference
 */
Runner.controls.FilterControlFabric = function( baseCfg, searchController ) {
	//add to the filter Control's config the link to the Search Controller object
	var cfg = {
		searchController: searchController
	};
	cfg = Runner.apply( cfg, baseCfg );
	
	switch ( cfg.filterFormat ) {
		case Runner.controls.constants.FILTER_FORMAT_VALUES_LIST:
		case Runner.controls.constants.FILTER_FORMAT_INTERVAL_LIST:
			switch ( cfg.multiSelect ) {
				case Runner.controls.constants.FILTER_MULTISELECT_NONE:
				return new Runner.controls.SimpleFilterControl( cfg ); 	

				case Runner.controls.constants.FILTER_MULTISELECT_ON_DEMAND:
				return new Runner.controls.OnDemandFilterControl( cfg ); 			

				case Runner.controls.constants.FILTER_MULTISELECT_ALWAYS:
				return new Runner.controls.MultiSelectFilterControl( cfg );
				
				default:
					throw( "Invalid multiselect param(" + cfg.multiSelect + ") for the " + cfg.filterFormat + " format. Cannot create control!" );
				return;	
			}
		
		case Runner.controls.constants.FILTER_FORMAT_BOOLEAN:
		return new Runner.controls.SimpleFilterControl( cfg ); 
		
		case Runner.controls.constants.FILTER_FORMAT_INTERVAL_SLIDER:
			if ( cfg.isFieldDateType ) {
				return new Runner.controls.DateSliderFilterControl( cfg );
			}
			if ( cfg.isFieldTimeType ) {
				return new Runner.controls.TimeSliderFilterControl( cfg );
			}			
		return new Runner.controls.SliderFilterControl( cfg ); 
		
		default:
			throw( "Invalid filter control's format = " + cfg.filterFormat + ". Cannot create control!" );
	}
}


/**
 * The base abstract class for filter controls
 */
Runner.controls.FilterControl = Runner.extend( Runner.emptyFn, {
	/**
	 * It Stores the contol's value for non-multiselect filter contorls 
	 * @type {String | Number}
	 */
	ctrlValue: '',
	
	/**
	 * Filter control field's name	 
	 * @type {String}
 	 */
	fieldName: '',
	
	/**
	 * Filter contorl "good" field's name
	 * @type {String}
	 */
	gfieldName: '',
	
	/**
	 * Filter contorl's format
	 * @type {String}
	 */	
	filterFormat: '',
	
	/**
	 * The number indicating if a contol allows
	 * multiselection always, "on demand" or never
	 * @type {number}
	 */
	multiSelect: 0,
	
	/**
	 * The indicator if the control's field is filtered
	 * @type {Boolean}
	 */
	filtered: false,
	
	/**
	 * If the control is filters it stores values 
	 * used for the contol field's filtration
	 * @type {Array}
	 */
	defaultValuesArray: [],
	
	/**
	 * The name of the Filter panel container's class
	 * @type {String}
	 */
	filterPanelContainerClass: "filterPanelContainer",
	
	/**
	 * The jQuery object representing the Filter panel's div container
	 * @type {object}
	 */
	filterPanelContainer: {},

	/**
	 * The jQuery object representing the filter control's container
	 * @type {object}
	 */
	filterContainer: {},
	
	/**
	 * The the link to the search Controller intance 
	 * (that is the same for all filter controls)
	 * @type {Object} 
	 */
	searchController: {},

	/**
	 * The name of the Filter "Apply" button's class
	 * @type {String}
	 */
	btnApplyClass: "filter-btn-apply",

	/**
	 * The class of the element toggling control visibility
	 * @type {String}
	 */
	btnExpanderClass: "filter-expander",

	/**
	 * The class of the element showing whether filter is hidden or displayed
	 * @type {String}
	 */
	btnExpanderIndicatorClass: "filter-indicator",

	/**
	 * The jQuery object representing the filter control's expander element
	 * @type {object}
	 */
	expanderElem: {},
	
	/**
	 * The name of the filter's hidden values class
	 * @type {String}
	 */	
	hiddenValuesClass: "filter-hidden",

	/**
	 * The name of the filter's collapsed values class
	 * @type {String}
	 */	
	collapsedValuesClass: "filter-collapsed",

	/**
	 * The name of the filter value block container's class
	 * @type {String}
	 */
	filterValueBlockContainerClass: "filter-values",
	
	/**
	 * The filter's URL params separator
	 * @type {String}
	 */
	separator: "",
	
	/**
	 * The flag indicating if the filter control is dependent
	 * @type {Boolean}
	 */
	dependent: false,
	
	/**
	 * The flag indicating if the filter control has any dependent filters	
	 * @type {Boolean}
	 */	
	hasDependent: false,
	
	/**
	 * The name of the outermost parent filter
	 * It's not equal to an empty string for dependent filters only
	 * @type {String}
	 */
	goodOutermostParentName: "",

	/**
	 * The name of the immediate parent filter
	 * It's not equal to an empty string for dependent filters only
	 * @type {String}
	 */	
	goodParentName: "",
	
	/**
	 * An array storing the parent filters names 
	 * for a dependent filter control
	 * @param {Array}
	 */
	parentFilterNames: null,	
	
	/**
	 * @type {string}
	 */
	hiddenFilterItemClass: "filter-item-hidden",
	
	
	constructor: function( cfg ) {
		this.defaultValuesArray = [];
		
		Runner.apply( this, cfg );
		
		this.filterPanelContainer = $("." + this.filterPanelContainerClass);
		this.filterContainer = $(".filter-" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) + "-container");
		this.expanderElem = $("." + this.btnExpanderClass, this.filterContainer);
		
		this.init();
	},

	/**
	 * The stub preventing children objects that don't have 
	 * any 'init' method from undefined method invocations
	 */
	init: Runner.emptyFn,
	
	/**
	 * Add the Apply, 'Clear' and Expander buttons' click event handlers
	 * to the Filter panel's container.
	 */
	initButtons: function() {
		this.initBasicButtons();
		this.initClearButtons();
		this.initShowMoreButton();	
	},

	/**
	 * Initialize the basic filter buttons
	 * A dependatn control doesn't have its own expander and apply button
	 */
	initBasicButtons: function() {	
		if ( this.dependent ) {
			return;
		}
		
		var ctrl = this,
			hiddenValuesClass = this.hiddenValuesClass,
			collapsedValuesClass = this.collapsedValuesClass,
			btnExpanderIndicatorClass = this.btnExpanderIndicatorClass;	

		// delegate clicks on a particular filter contriner	
		this.filterContainer
			.on('click', '.' + this.btnApplyClass, function(e) {
				$( this ).data( 'activated', true ); 
				ctrl.searchController.submitSearch();
				
				return false;
			})
			.on('click', '.' + this.btnExpanderClass, function(e) {
				var expander = $( this ),
					siblings = expander.siblings(':not(.' + hiddenValuesClass + ')'),
					goingToHide = siblings.not('.' + collapsedValuesClass).length !== 0,
					expanderIndicator = expander.children('.' + btnExpanderIndicatorClass);
				
				//set the right 'expand/collapse' sign for the filer
				expanderIndicator.html( goingToHide ? '&#x25BC;' : '&#x25B2;' );	
				
				//show/hide the filter's content. The last collapsed sibling is actually visible 1px height element due to collapsedValuesClasss styles	
				siblings.slideToggle( 100 ).promise().done( function() {
					siblings
						.css('display', '')
						.toggleClass( collapsedValuesClass, goingToHide );
				});
				
				return false;
			});	
	},
	
	/**
	 * Init the 'Clear' buttons
	 */
	initClearButtons: function() {
		if ( !this.filtered ) {
			return;
		}
			
		var ctrl = this,
			clearBtnClass = 'filter-clear-' + ( this.dependent ? this.goodOutermostParentName : this.gfieldName );			
			
		$('.' + clearBtnClass).on('click', function(e) {
			ctrl.clearControl();
			ctrl.clearDependentFilters();		
			
			ctrl.searchController.submitSearch();
			return false;
		});
	},
	
	/**
	 * Initialize the 'Show N more' button's functionality
	 */
	initShowMoreButton: function() {
		var ctrl = this;
		
		$(".filterShowMore_" + this.gfieldName).on("click", function(e) {
			var $showMoreElement = $(this).parent();
	
			$showMoreElement.siblings("." + ctrl.hiddenFilterItemClass)
				.removeClass( ctrl.collapsedValuesClass )
				.removeClass( ctrl.hiddenFilterItemClass );
				
			$showMoreElement.hide();
			return false;
		});		
	},
	
	/**
	 * Clear dependent filters
	 * @param {Boolean} notMultiSelected
	 */
	clearDependentFilters: function( notMultiSelected ) {
		if ( !this.hasDependent ) {
			return;
		}
		this.searchController.clearDependentFilters( this.dependentFilterNames, notMultiSelected );
	},
	
	/**
	 * Set the control's value
	 * @param {String | Number} value
	 */
	setValue: function( value ) {
		this.ctrlValue = value;
	},
	
	/**
	 * Get the control's value
	 * @return {String}
	 */	
	getValue: function() {
		return this.ctrlValue;
	},
	
	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * @param {String | Number} value
	 * @param {Boolean} encoded
	 */ 
	getPreparedValue: function( value, encoded ) {
		if ( encoded && typeof value === "string" ) {
			return this.searchController.searchEscape( value );
		}
		return value;
	},
	
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the encoded param is defined and equal to true 
	 * It returns the encoded value
	 * @param {Boolean} encoded
	 * @return {String}
	 */
	getFilterValue: function( encoded ) {
		var value;
		
		if ( this.ctrlValue === '' ) {
			return '';
		}
		
		value = this.getPreparedValue( this.ctrlValue, encoded );
		return '(' + this.searchController.searchEscape( this.fieldName ) + this.separator + value + ')';
	},

	/**
	 * Get filter's encoded value ready to use in the field's filtration
	 * @return {String}
	 */
	getFilterValueEncoded: function() {
		return this.getFilterValue( true ); 	
	},
	
	/**
	 * Check if the filter control is visible	
	 * @return {Boolean}
	 */	
	isVisible: function() {
		return this.filterContainer.is(":visible");
	},
	
	/**
	 * Check if the filter control is collapsed or not	
	 * @return {Boolean}
	 */
	isCollapsed: function() {
		return this.expanderElem.siblings().not(".filter-collapsed").length === 0;
	},
	
	/**
	 * Adjust the flter's expander sign basing on the its state (expanded/collapsed).
	 * @pamam {Boolean} collapsed	
	 * @return {Boolean}
	 */
	adjustExpander: function( collapsed ) {
		var sign = collapsed ? "&#x25BC;" : "&#x25B2;";
		$("." + this.btnExpanderIndicatorClass, this.expanderElem).html( sign );
	},
	
	/**
	 * Clear the filter control's value
	 * the 'Clear' buttons 'click' handler
	 */
	clearControl: function() {
		this.setValue('');
	},

	/**
	 * Set a single value to the filter control
	 * @param {Mixed}
	 */
	updateValue: function( value ) {
		this.setValue( value );	
	},
	
	/**
	 * Check if the filter control is dependent
	 * @return {Boolean}
	 */
	isDependent: function() {
		return this.dependent;
	},
	
	/**
	 * Check if the filter control is multiselected
	 * @return {Boolean}
	 */
	isMultiSelected: function() {
		return false;
	}
});


Runner.controls.SimpleFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * The link to the Runner.controls.OnDemandFilterControl's base class
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	superclass: {},
		
	/**
	 * The filter values links class name
	 * @type {String}
	 */		
	valueLinkClass: "",
	

	constructor: function( cfg ) {
		Runner.controls.SimpleFilterControl.superclass.constructor.call( this, cfg );	
	},
	
	/**
	 * Set the control's default value and init contol's buttons and links
	 */
	init: function() {	
		this.superclass = Runner.controls.SimpleFilterControl.superclass ;
		this.valueLinkClass = this.gfieldName + "-filter-value";
		
		this.setValue( this.defaultValuesArray.join(', ') );
		this.initButtons();
	},
	
	/**
	 * Init the control's buttons and links
	 */
	initButtons: function() {
		var ctrl = this,
			delBtnClass = "delFilterCtrlButt_" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) + "_" + this.searchController.id;
				
		this.filterPanelContainer
			.on("click", "." + delBtnClass, function(e) {
				var $delButton = $(this);
					valueToDelete = $(this).data('delete').toString(); 
				
				ctrl.clearFilterValue( valueToDelete, $delButton.parent(".filter-values") );
				ctrl.searchController.submitSearch();
				return false;	
			})
			.on("click", "." + this.valueLinkClass, function(e) {		
				var $valueLink = $(this);
				
				ctrl.ctrlValue = $valueLink.data("filtervalue");
				
				ctrl.updateParentFilters( $valueLink.data("parentFiltersValues") );
				ctrl.clearDependentFilters();							
				ctrl.searchController.submitSearch();
				
				return false;
			});
				
		//call the base class method
		this.superclass.initButtons.call( this );	
	},
	
	/**
	 * Update parent filters' values
	 * @param {Object} parentFiltersValuesData
	 */
	updateParentFilters: function( parentFiltersValuesData ) {
		if ( !this.dependent ) {
			return;
		}
		this.searchController.updateParentFilters( parentFiltersValuesData );
	},

	/**
	 * Delete a particular value from the filter's submit-values
	 * @param {String} valueToDelete
	 * @param {jQuery object} $container
	 */
	clearFilterValue: function( valueToDelete, $container ) {
		this.setValue('');
	}
}); 


Runner.controls.MultiSelectFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * It stores the array of the filter checkboxes' jQuery objects
	 * @type {Array}
	 */
	checkboxes: [],
	
	/**
	 * The name of the filter checkboxes' class
	 * @type {String}
	 */
	checkboxClass: '',
	
	/**
	 * The link to the Runner.controls.OnDemandFilterControl's base class
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	superclass: {},
	
	/**
	 * The common multiselect checkbox class name
	 * @type {String}	
	 */
	commonCheckboxClass: "multifilter-checkbox",
	
	/**
	 * The parent filter checkbox class name
	 * @param {String}
	 */
	parentCheckboxClass: "",
	
	
	constructor: function( cfg ) {
		this.checkboxes = [];
		
		Runner.controls.MultiSelectFilterControl.superclass.constructor.call( this, cfg );
	},
	
	/**
	 * Init the checkboxes array with the array of the filter checkboxes' jQuery objects.
	 * Set the control's default value and init contol's buttons and links. 
	 */
	init: function() {
		this.superclass = Runner.controls.MultiSelectFilterControl.superclass;

		this.applyButton = $( ".filter-apply-" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName) ); 
		
		this.checkboxClass = "filter_" + this.gfieldName + "_" + this.searchController.id;
		this.checkboxes = $("." + this.checkboxClass);	
		this.selectAllCheckbox = $( ".filter-selectAll-" + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) );
		this.parentCheckboxClass = this.dependent ? "filter_" + this.goodParentName + "_" + this.searchController.id : "";
				
		this.adjustSelectAllCheckbox();
		
		if ( this.filtered && !this.dependent ) {
			this.setValue( this.defaultValuesArray );
		}
		
		this.initButtons();
	},
		
	/**
	 * Adjust the flter's 'Select/Deselect All' checkbox basing on the filter's checkboxes state.
	 */	
	adjustSelectAllCheckbox: function() {
		var currentState = this.selectAllCheckbox.is(":checked"),
			allChecked = this.checkboxes.length === this.checkboxes.filter(":checked").length
		
		this.selectAllCheckbox.prop("checked", currentState && allChecked);
	},	
		
	/**
	 * Init the control's buttons
	 */	
	initButtons: function() {
		var ctrl = this;
				
		this.selectAllCheckbox
			.on("click", function(e) {
				e.stopPropagation();
			})
			.on("change", function(e) {
				ctrl.checkboxes.prop("checked", this.checked);
				ctrl.clearDependentFilters( true );
				return false;
			});
		
		this.checkboxes
			.on("click", function(e) {
				ctrl.adjustSelectAllCheckbox();
				ctrl.adjustDependentFilters( this );
				ctrl.adjustInvisibleCheckboxes( this );	
			})
			.on("change", function(e) {
				ctrl.adjustParentFilterCheckbox( this );
			});
			
		//call the base class method
		this.superclass.initButtons.call( this );	
	},
	
	/**
	 * Clear check boxes for multiselect dependent controls
	 * and clear values for not multiselected ones
	 * @param {DOM element} checkbox
	 */	
	adjustDependentFilters: function( checkbox ) {
		this.clearDependentFilters( true );
		this.adjustDependentFilterCheckboxes( checkbox );		
	},
	
	/**
	 * Update dependent filters checkboxes of the corresponding value blocks
	 * basing on the main filter's current checkbox state
	 * The method depends on the Filter panel value blocks markup
	 * @param {DOM element} checkbox
	 */
	adjustDependentFilterCheckboxes: function( checkbox ) {
		if ( !this.hasDependent ) {
			return;
		}
		
		var $checkbox = $( checkbox ),
			$filterValueBlock = $checkbox.parent( '.' + this.filterValueBlockContainerClass );
		
		$('.' + this.commonCheckboxClass, $filterValueBlock).prop('checked', $checkbox.is(':checked'));
	},
	
	/**
	 * Update the corresoinding parent filter's checkbox state
	 * basing on the value blocks's checkboxes state	
	 * The method depends on the Filter panel value blocks markup	 
	 * @param {DOM element} checkbox
	 */
	adjustParentFilterCheckbox: function( checkbox ) {
		if ( !this.dependent ) {
			return;
		}
		
		var $checkbox = $( checkbox ),
			$parentFilterValueBlock = $checkbox.parents( '.' + this.filterValueBlockContainerClass ).eq(1),
			checked = $checkbox.is(':checked') || $('.' + this.checkboxClass + ':checked', $parentFilterValueBlock).length > 0;

		
		$parentFilterValueBlock.find( '.' + this.parentCheckboxClass ).prop('checked', checked)
			.trigger('change');
	},	
	
	/**
	 * Update the corresponding checkboxes from invisible parent filters value blocks
	 * @param {DOM element} checkbox
	 */
	adjustInvisibleCheckboxes: function( checkbox ) {
		if ( !this.dependent ) {
			return
		}
		
		var $checkbox = $( checkbox ),
			checkboxValue = $checkbox.val(),
			parentValues = $checkbox.data('parentFiltersValues'),
			$similarHiddenBoxes = this.checkboxes.not(':visible').filter( function() {
				var $box = $(this),
					hiddenParentValues, pName;
					
				if ( $box.val() !== checkboxValue ) {
					return false;
				}				
				
				hiddenParentValues = $box.data('parentFiltersValues');
					
				for ( pName in hiddenParentValues ) {
					if ( hiddenParentValues[ pName ] !== parentValues[ pName ] ) {
						return false;
					}
				}
				
				return true; 
			});
			
		$similarHiddenBoxes.prop('checked', $checkbox.is(':checked'))
			.trigger('change');	
	},
	
	/**
	 * Checked the filter's checkboxes having the values contained in the array param
	 * @param {Array} arr
	 */
	setValue: function( arr ) {
		this.checkboxes.each( function(index, domCheckbox) {
			var checkbox = $( domCheckbox ),
				pos = $.inArray( checkbox.val(), arr );
			
			if ( pos !== -1 ) {
				checkbox.prop('checked', true);
				arr.splice(pos, 1); 
			} 
		});
		
	},
	
	/**
	 * Get the contorl's value as an array.
	 * The returned array contains all the cehcked control's cehckboxes' values 
	 * and some default values that are not represented among the contol's checkboxes
	 * (to the "filter" operation reversible)
	 *
	 * @return {Array} 
	 */
	getValue: function() {
		var arr = [], i,
			ctrl = this,
			$checked = $('.' + this.checkboxClass + ':checked'),
			onDemand = this instanceof Runner.controls.OnDemandFilterControl;
		
		if ( this.dependent ) {
			$checked = $checked.filter(':visible');
		}
		
		if ( this.filtered || this.applyButton.data('activated') || $checked.length !== this.checkboxes.length ) {	
			$checked.each( function( index, domCheckbox ) {		
				var $box = $( domCheckbox ),
					values = [ $box.val().replace('|', '\\|') ],
					parentFiltersValueData, i; 
				
				if ( ctrl.dependent ) {
					parentFiltersValueData = $box.data('parentFiltersValues');	
					
					for (i = 0; i < ctrl.parentFilterNames.length; i++) {
						values.push( parentFiltersValueData[ ctrl.parentFilterNames[i] ].toString().replace('|', '\\|') );
					}
				}
				
				arr.push( values.join('|') );				
			});			
		}
		
		return arr;
	},
	
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the encoded param is defined and equal to true 
	 * It returns the encoded value
	 * @param {Boolean} encoded
	 *
	 * @return {String}
	 */
	getFilterValue: function( encoded ) {
		var arr = this.getValue(),
			result = ''; 
		
		for (i = 0; i < arr.length; i++) {
			this.ctrlValue = this.getPreparedValue( arr[i], encoded );
						//call the base class method	
			result += this.superclass.getFilterValue.call( this, encoded );
		}
		
		return result;
	},
	
	/**
	 * Clear the filter control's value
	 */
	clearControl: function() {			
		this.checkboxes.prop('checked', false);
		this.selectAllCheckbox.prop('checked', false);		
	},
	
	/**
	 * Set a single value to the filter control
	 * @param {Mixed}
	 */
	updateValue: function( value ) {
		this.checkboxes.prop('checked', false);
		this.setValue( [value] );	
	},

	/**
	 * Check if the filter control is multiselected
	 * @return {Boolean}
	 */
	isMultiSelected: function() {
		return true;
	}	
});

/**
 * The class combaining the SimpleFilterControl and MultiSelectFilterControl functionalities
 */
Runner.controls.OnDemandFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * The indicator showing if control in multiselection mode ot not
	 * (this mode is turning on by clicking on the "Multiselect" button)
	 * @type {Boolean}
	 */
	multiSelection: false,
	
	/**
	 * It stores the array of the filter checkboxes' jQuery objects
	 * @type {Array}
	 */
	checkboxes: [],
	
	/**
	 * The name of the filter checkboxes' class
	 * @type {String}
	 */
	checkboxClass: '',
		
	/**
	 * The name of the Filter "Multiselect" button's class
	 * @type {String}
	 */
	btnMultiselectClass: "",
	
	/**
	 * The caption of the filter's "Apply" button
	 * @type {String}
	 */
	btnApplyCaption: Runner.lang.constants.TEXT_FILTER_APPLY,
		
	/**
	 * The link to the Runner.controls.OnDemandFilterControl's base class
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	superclass: {},

	/**
	 * The link to the Runner.controls.MultiSelectFilterControl
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	multiSelectFCtrl: {},
	
	/**
	 * The link to the Runner.controls.SimpleFilterControl
	 * It makes easier to borrow its methods
	 * @type {Object}
	 */
	simpleFCtrl: {},

	/**
	 * The class name of the filtered not multiselected filter's values
	 * @type {String}
	 */
	filteredValuesClass: "filter-ready-value",	
	
	/**
	 * The filter values links class name
	 * @type {String}
	 */	
	valueLinkClass: "",

	/**
	 * The common multiselect checkbox class name
	 * @type {String}	
	 */
	commonCheckboxClass: "multifilter-checkbox",
	
	/**
	 * The parent filter checkbox class name
	 * @param {String}
	 */
	parentCheckboxClass: "",	
	
	
	constructor: function( cfg ) {
		this.checkboxes = [];
		
		Runner.controls.OnDemandFilterControl.superclass.constructor.call( this, cfg );
	},
	
	/**
	 * Init the checkboxes array with the array of the filter checkboxes' jQuery objects.
	 * Set the control's default value and init contol's buttons and links. 
	 */
	init: function() {	
		this.superclass = Runner.controls.OnDemandFilterControl.superclass;
		this.multiSelectFCtrl = Runner.controls.MultiSelectFilterControl.prototype;
		this.simpleFCtrl = Runner.controls.SimpleFilterControl.prototype; 

		this.btnMultiselectClass = 'filter-' + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ) + '-btn-multiselect';		
		this.applyButton = $("." + this.btnMultiselectClass);
		
		this.checkboxClass = 'filter_' + this.gfieldName + "_" + this.searchController.id;
		this.checkboxes = $('.' + this.checkboxClass);		
		this.parentCheckboxClass = this.dependent ? 'filter_' + this.goodParentName + "_" + this.searchController.id : '';
		this.selectAllCheckbox = $('.filter-selectAll-' + ( this.dependent ? this.goodOutermostParentName : this.gfieldName ));	
		
		this.valueLinkClass = this.gfieldName + '-filter-value';
		
		this.setValue( this.defaultValuesArray.join(', ') );
		this.initButtons(); 		
	},
	
	/**
	 * Adjust the flter's 'Select/Deselect All' checkbox basing on the filter's checkboxes state.
	 */	
	adjustSelectAllCheckbox: Runner.controls.MultiSelectFilterControl.prototype.adjustSelectAllCheckbox,
	
	/**
	 * Clear check boxes for multiselect dependent controls
	 * and clear values for not multiselected ones
	 * @param {DOM element} checkbox
	 */	
	adjustDependentFilters: Runner.controls.MultiSelectFilterControl.prototype.adjustDependentFilters,
	
	/**
	 * Update dependent filters checkboxes of the corresponding value blocks
	 * basing on the main filter's current checkbox state
	 * The method depends on the Filter panel blocks markup
	 * @param {DOM element} checkbox
	 */
	adjustDependentFilterCheckboxes: Runner.controls.MultiSelectFilterControl.prototype.adjustDependentFilterCheckboxes,

	/**
	 * Update the corresoinding parent filter's checkbox state
	 * basing on the value blocks's checkboxes state	
	 * The method depends on the Filter panel value blocks markup	 
	 * @param {DOM element} checkbox
	 */
	adjustParentFilterCheckbox: Runner.controls.MultiSelectFilterControl.prototype.adjustParentFilterCheckbox,
	
	/**
	 * A stub for the Runner.controls.OnDemandFilterControl class
	 */
	adjustInvisibleCheckboxes: Runner.emptyFn,
	
	/**
	 * Init control's buttons and links
	 */
	initButtons: function() {
		var ctrl = this,
			anotherApplyButtonExists = !!$(".filter-apply-" + this.gfieldName).not( this.applyButton ).length;
		
		if ( this.dependent ) {
			anotherApplyButtonExists = !!$(".filter-apply-" + this.goodOutermostParentName).not( this.applyButton ).length;
		}
		
		this.applyButton.one("click", function(e) {
			var $button = $(this);

			if ( anotherApplyButtonExists ) { 
				$button.hide();
			}		
			
			$button
				.text( ctrl.btnApplyCaption )
				.addClass( ctrl.btnApplyClass )
				.removeClass( ctrl.btnMultiselectClass );			
						
			$("." + ctrl.valueLinkClass)
				.removeClass( ctrl.valueLinkClass )
				.addClass( "multiSelect-" + ctrl.valueLinkClass );
			
			ctrl.checkboxes.show();
			ctrl.addNewValueLinkFunctionality();
			ctrl.selectAllCheckbox.show();
			
			if ( !ctrl.dependent || ctrl.filtered ) {				
				$("." + ctrl.hiddenValuesClass, ctrl.filterContainer)
					.show()
					.removeClass( ctrl.hiddenValuesClass );
				
				$("." + ctrl.filteredValuesClass + ".ondemand", ctrl.filterContainer)
					.hide()
					.addClass( ctrl.hiddenValuesClass );
			}
			
			if ( ctrl.dependent && !ctrl.searchController.hasFilteredParentFilter( ctrl.parentFilterNames) ) {
				// hide the 'delete filter' button after switching ti the multiselect mode
				$(".delFilterCtrlButt_" + ( ctrl.dependent ? ctrl.goodOutermostParentName : ctrl.gfieldName ) + "_" + ctrl.searchController.id).hide();
			}
			
			ctrl.multiSelection = true;
			return false;
		});

		//call the SimpleFilterControl's method
		this.simpleFCtrl.initButtons.call( this );
		//call the MultiSelectFilterControl's method
		this.multiSelectFCtrl.initButtons.call( this );		
	},

	/**
	 * Update parent filters' values
	 * @param {Object} parentFiltersValuesData
	 */
	updateParentFilters: Runner.controls.SimpleFilterControl.prototype.updateParentFilters,
	
	/**
	 * Reassign the value-links click handler
	 */
	addNewValueLinkFunctionality: function() {
		var newValueLinkClass = 'multiSelect-' + this.gfieldName + '-filter-value';
		
		this.filterPanelContainer.on('click', '.' + newValueLinkClass, function(e) {
			var $link = $(this),
				linkValue = $link.data('filtervalue')
				$checkbox = $link.siblings().filter( function() {
						return this.value === linkValue; 
					});
				
			$checkbox.prop('checked', true);	
			return false;
		});
	},
	
	/**
	 * Get filter's value. 
	 * If the multiselection is turned on for the "on Demand" control or its field is filtered
	 * It uses the borrowed method "getFilterValue" from the MultiSelectFilterControl.
	 * Otherwise it borrows the superclass "getFilterValue" method
	 *
	 * @return {String}
	 */
	getValue: function() { 
		if ( this.multiSelection || this.filtered ) {
					//call the MultiSelectFilterControl's method
			return this.multiSelectFCtrl.getValue.call( this );
		}
				//call the base class method
		return this.superclass.getValue.call( this );
	},
	
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the multiselection is turned on for the "on Demand" control or its field is filtered
	 * It uses the borrowed method "getFilterValue" from the MultiSelectFilterControl.
	 * Otherwise it borrows the superclass "getFilterValue" method
	 *
	 * @return {String}
	 */
	getFilterValue: function( encoded ) {
		if ( this.multiSelection || this.filtered ) {
					//call the MultiSelectFilterControl's method
			return this.multiSelectFCtrl.getFilterValue.call( this, encoded );
		}
				//call the base class method
		return this.superclass.getFilterValue.call( this, encoded );
	},

	/**
	 * Clear the filter control
	 */
	clearControl: function() {
		if ( this.multiSelection || this.filtered ) {
			this.checkboxes.prop('checked', false);
			this.selectAllCheckbox.prop('checked', false);
		} 
		
		this.setValue('');
	},
	
	/**
	 * Delete a particular value from the filter's submit-values
	 * by unchecking the corresponding checkbox
	 * @param {Strging} valueToDelete
	 * @param {jQuery object} $container	 
	 */
	clearFilterValue: function( valueToDelete, $container ) {
		if ( !this.dependent ) {
			this.checkboxes
				.filter( function() {	
					return this.value === valueToDelete;
				})
				.prop('checked', false);
			
			return;
		}
		
		this.checkboxes
			.filter( function() {
				return !!$container.find( this ).length;
			})
			.prop('checked', false);
		
		if ( this.hasDependent ) {
			$('.' + this.commonCheckboxClass, $container).prop('checked', false); 			
		}			
	},
	
	/**
	 * Set a single value to the filter control
	 * @param {Mixed}
	 */
	updateValue: function( value ) {
		if ( this.multiSelection ) {
			this.checkboxes.prop('checked', false);
			this.setValue( [value] );
		} 
		
		this.setValue( value );
	},
	
	/**
	 * Check if the filter control is multiselected	
	 * @return {Boolean}
	 */
	isMultiSelected: function() {
		return this.multiSelection;
	}
});


/**
* The Slider Filter control class
*/
Runner.controls.SliderFilterControl = Runner.extend( Runner.controls.FilterControl, {
	/**
	 * The jQueryUI slider object 
	 * @type {Object}
	 */
	sliderElem: {},
	
	/**
	 * The jQueryUI slider's range param
	 * It could be assigned with a corresponding key from the config
	 * @type {Number}
	 */
	range: true,

	/**
	 * The jQueryUI slider's min value
	 * It could be assigned with a corresponding key from the config
	 * @type {String|Number}
	 */	
	minValue: 0,

	/**
	 * The jQueryUI slider's max value
	 * It could be assigned with a corresponding key from the config
	 * @type {String|Number}
	 */	
	maxValue: 0, 

	/**
	 * The jQueryUI slider's step value
	 * It could be assigned with a corresponding key from the config
	 * @type {Number}
	 */	
	step: 1,

	/**
	 * A param setting th slider type 
	 * ("min", "max", "both")
	 * @type {Number}
	 */
	knobsType: 0,
	
	/**
	 * The rounded max slider's value
	 * @type {Number}
	 */
	roundedMax: 0,
	
	/**
	 * The rounded min slider's value	
	 * @type {Number}
	 */	
	roundedMin: 0,
	
	/**
	 * The rounded max slider knob's value	
	 * @type {Number}
	 */		
	roundedMaxKnobValue: 0,
	
	/**
	 * The rounded min slider knob's value		
	 * @type {Number}
	 */		
	roundedMinKnobValue: 0,	
	
	/**
	 * An indicator showing if the 'Apply' 
	 * button is added to the filter 
	 * @type {Boolean}
	 */
	useApllyBtn: false,

	
	constructor: function( cfg ) {
		Runner.controls.SliderFilterControl.superclass.constructor.call( this, cfg );
	},

	/**
	 * Set default filter's values
	 */
	setDefaultValues: function() {
		this.ctrlValues = [ this.minKnobValue, this.maxKnobValue ];
	},

	/**
	 * Get the string representation of the control's value
	 * @return {String}
	 */
	getValue: function() {
		return this.getCaptionValue( this.ctrlValues[0] ) + " - " + this.getCaptionValue( this.ctrlValues[1] );
	},
	
	/**
	 * Init the slider control
	 */
	init: function() {
		var jQsliderValues, sliderParams;
		
		jQsliderValues= $("#slider_values_" + this.gfieldName);
		this.jQmax = $(".slider-max", jQsliderValues); 
		this.jQmin = $(".slider-min", jQsliderValues);	
	
		this.setDefaultValues();	
		this.range = this.getRange();
		
		sliderParams = this.getSliderParams();	
		this.sliderElem = $("#slider_" + this.gfieldName)
			.slider( sliderParams );
			
		this.setPageMaxZIndex();	
		
		this.initButtons();			
	},
	
	/**
	 * A stub
	 */
	initShowMoreButton: Runner.emptyFn,
	
	/**
	 * Set the Runner 'z-index' counter not lower that the slider's handle 'z-index' value
	 */ 
	setPageMaxZIndex: function() {
		var handleZIndex = parseInt( $('.ui-slider-handle', this.sliderElem).css('z-index'), 10 );
		Runner.setZindexMax( handleZIndex );	
	},
	
	/**
	 * Get the jQuery slider range param
	 */
	getRange: function() {
		if ( this.knobsType === Runner.controls.constants.FILTER_KNOBS_MIN_ONLY ) {
			return 'max';
		}		
		if ( this.knobsType === Runner.controls.constants.FILTER_KNOBS_MAX_ONLY ) {
			return 'min';
		}	
		return true;
	},
	
	/**
	 * Get jQuery slider params
	 * @return {object}
	 */
	getSliderParams: function() {
		var filter = this,
			sliderParams = {
				range: this.range,
				min: this.roundedMin,
				max: this.roundedMax,
				step: parseFloat( this.step )
			},
			typeBasedParams;
			
		typeBasedParams = this.getSliderParamsByType( this.range );
		Runner.apply( sliderParams, typeBasedParams );
		
		if ( !this.useApllyBtn ) {	
			sliderParams.stop = function() {
				filter.searchController.submitSearch();
			}			
		}	
		return sliderParams;
	},
	
	/**
	 * Get jQuery slider params basing on the slider's range type
	 * @param {string | boolean} range
	 * @return {object}
	 */
	getSliderParamsByType: function( range ) {
		var filter = this;
		
		switch ( this.range ) {
			case 'min':
			return {
				value: parseFloat( this.roundedMaxKnobValue ),
				slide: function( event, ui ) {
					filter.processMaxValue( ui.value, $(this).slider("option", "min") === ui.value );	
				}
			};

			case 'max':
			return {
				value: parseFloat( this.roundedMinKnobValue ),
				slide: function( event, ui ) {
					filter.processMinValue( ui.value, $(this).slider("option", "max") === ui.value );
				}
			};

			default:
			return {
				values: [ parseFloat( this.roundedMinKnobValue ), parseFloat( this.roundedMaxKnobValue ) ],	
				slide: function( event, ui ) {
					var oldValues = $( this ).slider( "values" ),
						min = ui.values[ 0 ],
						max = ui.values[ 1 ],
						oldMin = oldValues[ 0 ],
						oldMax = oldValues[ 1 ];
								
					if ( min !== oldMin ) {
						filter.processMinValue( min, min === max );
						return;			
					}
					if ( max !== oldMax ) {			
						filter.processMaxValue( max, min === max );
						return;							
					}
				}
			};
		}		
	},

	/**
	 * Set the conttol's min value and caption
	 * @param {number} min
	 * @param {boolean} minIsEqualToMax	 
	 */	
	processMinValue: function( min, minIsEqualToMax ) {
		var value = this.getSliderValue( min, true, minIsEqualToMax );
		
		this.setMinValue( value );
		this.setCaptions( value, true );
	},

	/**
	 * Set the conttol's max value and caption
	 * @param {number} max
	 * @param {boolean} minIsEqualToMax
	 */	
	processMaxValue: function( max, minIsEqualToMax ) {
		var value = this.getSliderValue( max, false, minIsEqualToMax );
					
		this.setMaxValue( value );
		this.setCaptions( value, false );	
	},
	
	/**
	 * Set the control's captions	
	 * @param {number} value	
	 * @param {boolean} isLower
	 */		
	setCaptions: function( value, isLower ) {
		var jQmainCaption = isLower ? this.jQmin : this.jQmax,
			caption = this.getCaptionValue( value );	
		
		jQmainCaption.html( caption );	
	},
	
	/**
	 * Replace the obtained slider's extreme value with
	 * the real corresponding database value		
	 * @param {number} value
	 * @param {boolean} isLower
	 * @param {boolean} minIsEqualToMax
	 * @return {number}
	 */
	getSliderValue: function( value, isLower, minIsEqualToMax ) {
		if ( value === this.roundedMin ) {
			return parseFloat( this.minValue );
		}
		
		if ( value === this.roundedMax ) { 
			return parseFloat( this.maxValue )
		}
		
		return value;
	},

	/**	
	 * Get the correct slider's caption	
	 * @param {number} value
	 * @return {number}
	 */
	getCaptionValue: function( value ) {
		if ( this.viewAsCurrency ) {
			return this.getCurrencyFormattedString( value, this.currencySettings );
		}
		
		if ( this.viewAsNumber ) {
			return this.getNumberFormattedString( value, this.numberSettings );
		}
		
		return value;
	},	
	
	/**
	 * Set the min slider control's value
	 * @param {number} minValue
	 */
	setMinValue: function( minValue ) {
		this.ctrlValues[0] = minValue;
	},
	
	/**
	 * Set the max slider control's value
	 * @param {number} maxValue
	 */
	setMaxValue: function( maxValue ) {
		this.ctrlValues[1] = maxValue;
	},
		
	/**
	 * Get filter's value ready to use in the field's filtration
	 * If the encoded param is defined and equal to true 
	 * It returns the encoded value
	 * @param {boolean} encoded 
	 * @return string
	 */
	getFilterValue: function( encoded ) {
		var value;
		
		if ( this.ctrlValues[0] === undefined && this.ctrlValues[1] === undefined ) {
			// the slider isn't activated
			return '';
		}
		
		if ( !this.filtered ) {
			this.prepareControlValues();
		}
		
		if ( this.knobsAreOnTheLimits() ) {
			// the knobs are set on the min and max slider's values
			return '';
		}
		
		value = this.getTypeBasedValue();
		return "(" + this.searchController.searchEscape( this.fieldName ) + this.separator + value + ")";
	},
	
	/**
	 * Get the control's value/values to add them 
	 * to the submit-string 
	 * @param {boolean} encoded
	 * @return {string}
	 */
	getTypeBasedValue: function( encoded ) {			
		switch ( this.range ) {
			case 'min':
			return this.getPreparedMaxValue( encoded );

			case 'max':
			return this.getPreparedMinValue( encoded );
				
			default:				
				var valueMin = this.getPreparedMinValue( encoded ),
					valueMax = this.getPreparedMaxValue( encoded );
					
			return valueMin + "~" + valueMax;
		}
	},

	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's min value string
	 * @param {boolean} encoded
	 * @return {string}
	 */		
	getPreparedMinValue: function( encoded ) {
		return this.getPreparedValue( this.ctrlValues[0], encoded );
	},

	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's max value string
	 * @param {boolean} encoded
	 * @return {string}
	 */		
	getPreparedMaxValue: function( encoded ) {
		return this.getPreparedValue( this.ctrlValues[1], encoded );
	},	
	
	/**
	 * Replace undefined filter's values with corresponding
	 * slider's min and max values
	 */	
	prepareControlValues: function() {
		if ( this.ctrlValues[0] === undefined ) {
			this.ctrlValues[0] = this.minValue;
		}
		if ( this.ctrlValues[1] === undefined ) {
			this.ctrlValues[1] = this.maxValue;
		}
	},
	
	/**
	 * Check if the slider's min and max knobs are equal to the
	 * the min and max slider's values respectively
	 * @return {boolean}
	 */
	knobsAreOnTheLimits: function() {
		return this.ctrlValues[0] === this.minValue && this.ctrlValues[1] === this.maxValue;
	},
	
	/**
	 * Get the formmated string representating the number: 
	 * insert the thousand separators,
	 * replace the decimal separator with correct one,
	 * format the number of decimal digits.
	 * If the number is negative the method returns 
	 * the formatted number's absolute value
	 * @param {number} number
	 * @return {string}
	 */		
	getNumberAbsoluteValueFormatted: function( number ) {
		var iDigits = this.commonFormatSettings['decimalDigits'],
			grouping = this.commonFormatSettings["grouping"], 
			ptr, i, outStart, outEnd;
		
		number = number.toFixed( iDigits ); 
		intPart = number >= 0 ? Math.floor( number ) : Math.floor( -number );
		fracPart = number >= 0 ? number - intPart : -number - intPart;
		out = intPart.toFixed(0);
		
		// add sousand separators to the integer part of the number
		if ( grouping.length && parseInt( grouping[0], 10 ) ) {
			ptr = out.toString().length;
			for (i = 0; i < grouping.length; i++) {
				if ( !parseInt( grouping[i], 10 ) ) {
					i--;
				}
				if ( ptr <= grouping[i] ) {
					break;
				}
				ptr = ptr - grouping[i];
				outStart = out.slice( 0, ptr );
				outEnd = out.slice( ptr );
				out = outStart + this.commonFormatSettings["thousandSep"] + outEnd;
			}
		}
		
		// add a decimal separator and the fractional part to the integer part 
		if ( iDigits > 0 ) {
			fracPart = ( fracPart * Math.pow(10, iDigits) ).toFixed(0);
			while ( fracPart.length < iDigits ) {
				fracPart = "0" + fracPart;
			}
			out += this.commonFormatSettings["decimalSep"] + fracPart;
		}
		return out;
	},
	
	/**
	 * Get the correct number format string for a slider's value
	 * @param {number} number
	 * @return {string}
	 */	
	getNumberFormattedString: function( number ) {
		var positiveSign = number >= 0,
			numberSettings = this.formatSettings,
			outString = this.getNumberAbsoluteValueFormatted( number );
		
		// add the positive/negative signs to the formatted number
		if ( positiveSign || parseInt(outString, 10) === 0 ) {
			return numberSettings["LOCALE_SPOSITIVESIGN"] + outString;
		}
		
		switch ( numberSettings["LOCALE_INEGNUMBER"] ) {
			case "0":
				return "(" + outString + ")";
			case "1":
				return "-" + outString;
			case "2":
				return "- " + outString;
			case "3":
				return outString + "-";
			case "4":
				return outString + " -";
			default:
				return outString;
		}
	},	
		
	/**
	 * Get the correct currency format string for a slider's value
	 * @param {number} number
	 * @return {string}
	 */	
	getCurrencyFormattedString: function( number ) {
		var positiveSign = number >= 0,
			currencySettings = this.formatSettings,
			outString = this.getNumberAbsoluteValueFormatted( number );

		if ( positiveSign || parseInt(outString, 10) === 0 ) {
			switch ( currencySettings["LOCALE_ICURRENCY"] ) {
				case "0":
					return currencySettings["LOCALE_SCURRENCY"] + outString;
				case "1":
				case "2":
					return currencySettings["LOCALE_SCURRENCY"] + " " + outString;
				case "3":
					return outString + " " + currencySettings["LOCALE_SCURRENCY"];
				default:
					return outString;			
			}					
		}
		
		switch ( currencySettings["LOCALE_INEGCURR"] ) {
			case "0":
				return "(" + currencySettings["LOCALE_SCURRENCY"] + outString + ")";			
			case "1":
				return "-" + currencySettings["LOCALE_SCURRENCY"] + outString;				
			case "2":
				return currencySettings["LOCALE_SCURRENCY"] + "-" + outString;
			case "3":
				return currencySettings["LOCALE_SCURRENCY"] + outString + "-";
			case "4":
				return "(" + outString + currencySettings["LOCALE_SCURRENCY"] + ")";		
			case "5":
				return "-" + outString + currencySettings["LOCALE_SCURRENCY"];
			case "6":
				return outString + "-" + currencySettings["LOCALE_SCURRENCY"];
			case "7":
				return outString + currencySettings["LOCALE_SCURRENCY"] + "-";
			case "8":
				return "-" + outString + " " + currencySettings["LOCALE_SCURRENCY"];				
			case "9":
				return "-" + currencySettings["LOCALE_SCURRENCY"] + " " + outString;	
			case "10":
				return outString + " " + currencySettings["LOCALE_SCURRENCY"] + "-";
			case "11":
				return currencySettings["LOCALE_SCURRENCY"] + " " + outString + "-";
			case "12":
				return currencySettings["LOCALE_SCURRENCY"] + " -" + outString;
			case "13":
				return outString + "- " + currencySettings["LOCALE_SCURRENCY"];
			case "14":
				return "(" + currencySettings["LOCALE_SCURRENCY"] + " " + outString + ")";	
			case "15":
				return "(" + outString + " " + currencySettings["LOCALE_SCURRENCY"] + ")";
			default:
				return outString;	
		}
	},
	
	/**
	 * Clear the filter control's values
	 */
	clearControl: function() {
		this.ctrlValues = [];
	}
});

/**
 * The Date Slider Filter control class
 */
Runner.controls.DateSliderFilterControl = Runner.extend( Runner.controls.SliderFilterControl, {
	/**
	 * @type {number}
	 */
	stepType: Runner.controls.constants.FILTER_STEP_DAY,

	/**
	 * @type {boolean}
	 */
	isFieldDateType: true,
	
	/**
	 * @type {boolean}
	 */	
	processWrappers: true,
	
	/**
	 * Array of month names
	 * @type {array}
	 */
	monthNames: [
		Runner.lang.constants.TEXT_MONTH_JAN,
		Runner.lang.constants.TEXT_MONTH_FEB,
		Runner.lang.constants.TEXT_MONTH_MAR,
		Runner.lang.constants.TEXT_MONTH_APR,
		Runner.lang.constants.TEXT_MONTH_MAY,
		Runner.lang.constants.TEXT_MONTH_JUN,
		Runner.lang.constants.TEXT_MONTH_JUL,
		Runner.lang.constants.TEXT_MONTH_AUG,
		Runner.lang.constants.TEXT_MONTH_SEP,
		Runner.lang.constants.TEXT_MONTH_OCT,
		Runner.lang.constants.TEXT_MONTH_NOV,
		Runner.lang.constants.TEXT_MONTH_DEC
	],	
	
	
	constructor: function( cfg ) {
		Runner.controls.DateSliderFilterControl.superclass.constructor.call( this, cfg ); 
	},

	/**
	 * Set default filter's values
	 * Elements of the ctrlValues array should have 
	 * the object (Date) or undefined type
	 */
	setDefaultValues: function() {
		var minKnob = this.minKnobValue,
			maxKnob = this.maxKnobValue;

		if ( minKnob ) {
			minKnob = this.parseDateTime( minKnob, this.dateFormat );
		}
		if ( maxKnob ) {
			maxKnob = this.parseDateTime( maxKnob, this.dateFormat );
		}
		this.ctrlValues = [ minKnob, maxKnob ];
	},
	
	/**
	 * Init the date-slider control
	 */
	init: function() {
		var jQsliderValues= $("#slider_values_" + this.gfieldName);
		this.jQcaptPrefix = $(".slider-caption-prefix", jQsliderValues);
		this.jQcaptPostfix = $(".slider-caption-postfix", jQsliderValues);
	
		this.dateFormat = Runner.pages.PageSettings.getGlobalData("locale").dateFormat;	
		this.dateDelimiter = Runner.pages.PageSettings.getGlobalData("locale").dateDelimiter;

		this.minDate = this.parseDateTime( this.minValue, this.dateFormat );
		this.minDateInMs = this.minDate.getTime();
		this.maxDate = this.parseDateTime( this.maxValue, this.dateFormat );
		this.maxDateInMs = this.maxDate.getTime();
		
		if ( this.stepType === Runner.controls.constants.FILTER_STEP_SEC 
			|| this.stepType === Runner.controls.constants.FILTER_STEP_MIN ) {
			
			this.realMaxDate = this.parseDateTime( this.realMaxValue, this.dateFormat );
			this.realMinDate = this.parseDateTime( this.realMinValue, this.dateFormat ); 
		}		
		
		Runner.controls.DateSliderFilterControl.superclass.init.call( this );		
	},
	
	/**
	 * Get date-time formatted string	
	 */
	printDateTime: Runner.controls.DateField.prototype.printDateTime,

	/**
	* Create the Date object from the string representation
	* basing on the date format
	*/
	parseDateTime: Runner.controls.DateField.prototype.parseDateTime,	
			
	/**
	 * Replace the obtained slider's extreme value with
	 * the corresponding corresponding Date object		
	 * @param {number} value
	 * @param {boolean} isLower
	 * @param {boolean} minIsEqualToMax
	 * @return {Date object}
	 */
	getSliderValue: function( value, isLower, minIsEqualToMax ) {
		var prepDate = new Date( this.minDateInMs ),
			year, month, day, unitStep;
		
		switch ( this.stepType ) {
			case Runner.controls.constants.FILTER_STEP_SEC :		
			case Runner.controls.constants.FILTER_STEP_MIN :	
				if ( value === this.roundedMax ) {
					prepDate = this.realMaxDate;
					break;
				}	
				if ( value === this.roundedMin ) {
					prepDate = this.realMinDate;
					break;	
				} 
				prepDate = new Date( this.minDateInMs + value * 1000 );	
			break;	
				
			case Runner.controls.constants.FILTER_STEP_MONTH :				
				month = prepDate.getMonth() + value;			
				prepDate.setMonth( month );
				
				if (!isLower) {
					prepDate.setDate( prepDate.getDate() - 1 );
				}

				if ( minIsEqualToMax ) {
					month = prepDate.getMonth();
					year = prepDate.getFullYear();
					
					month = isLower ? month - 1 : month + 2;					
					day = isLower ? 1 : 0;
					prepDate = new Date(year, month, day);
				}			
			break;			
		
			case Runner.controls.constants.FILTER_STEP_YEAR :				
				month = isLower ? 0 : 11;
				day = isLower ? 1 : 31
				
				if ( value === this.roundedMax ) {
					year = this.maxDate.getFullYear();
				} else {				
					unitStep = parseFloat( this.step ) === 1;
					year = prepDate.getFullYear() + value;
					
					if (!isLower) {
						year = ( minIsEqualToMax || unitStep ) ? year : year - 1;
					} else {
						year = ( minIsEqualToMax && !unitStep ) ? year - 1 : year;
					}
				}
				prepDate = new Date(year, month, day);		
			break;		
		
			default: 
				prepDate = new Date( this.minDateInMs + value * 1000 );	
		}
			
		return prepDate;
	},
	
	/**
	 * Set the control's captions	
	 * @param {Date object} prepDate	
	 * @param {boolean} isLower
	 */		
	setCaptions: function( prepDate, isLower ) {
		Runner.controls.DateSliderFilterControl.superclass.setCaptions.call( this, prepDate, isLower );
		
		if ( this.processWrappers ) {
			this.setWrapperCaption( isLower, prepDate );
		}
	},
	
	/**
	 * Set the captions for the sliders of the
	 * 'month', 'hours', 'minutes' or 'seconds' 
	 * step types basing on which knob was moving 
	 * @param {boolean} isLower
	 * @param {Date object} date
	 */	
	setWrapperCaption: function( isLower, date ) {
		this.setCaptionsVisibility( isLower, date );
		
		if ( !isLower && this.showTime ) {
			this.jQcaptPostfix.html( this.printTime(date) );
			return;
		}
		if ( isLower && this.stepType === Runner.controls.constants.FILTER_STEP_MONTH ) {
			this.jQcaptPrefix.html( this.monthNames[ date.getMonth() ] );
		}
	},
	
	/**
	 * Set the captions vsibility for the sliders of the
	 * 'month', 'hours', 'minutes' or 'seconds' step types 
	 * @param {boolean} isLower
	 * @param {Date object} date 
	 */	
	setCaptionsVisibility: function( isLower, date ) {
		var otherKnobDate = isLower ? ( this.ctrlValues[1] || this.maxDate ) : ( this.ctrlValues[0] || this.minDate ), 
			visible;
		
		if ( this.showTime ) {
			visible = this.checkDatesEqual( otherKnobDate, date );	
			this.jQcaptPostfix.toggle( visible );
		
			this.jQmax.toggle( !visible );
			return;	
		} 

		if ( this.stepType === Runner.controls.constants.FILTER_STEP_MONTH ) {
			visible = otherKnobDate.getFullYear() === date.getFullYear();			
			this.jQcaptPrefix.toggle( visible );
			
			this.jQmin.toggle( !visible );
		}
	},	
	
	/**
	 * Check if two dates passed are equal or not
	 * disregarding the time values
	 * @param {Date object} date1 
	 * @param {Date object} date2 
	 * @param {Boolean}
	 */
	checkDatesEqual: function( date1, date2 ) {
		return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
	},
	
	/**	
	 * Get the correct slider's caption
	 * @param {Date object} date
	 * @return {string}
	 */
	getCaptionValue: function( date ) {
		if ( this.stepType === Runner.controls.constants.FILTER_STEP_YEAR ) {
			return date.getFullYear();
		}
		
		if ( this.stepType === Runner.controls.constants.FILTER_STEP_MONTH ) {
			return this.monthNames[ date.getMonth() ] + " " + date.getFullYear();
		}
		
		return this.printDateTime( date, this.dateFormat, true );
	},	
	
	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's max knob value's string representation
	 * @param {boolean} encoded
	 * @return {string}
	 */
	getPreparedMaxValue: function( encoded ) {
		var date = this.ctrlValues[1], 
			stringValue = this.getStringValueFromDate( date );
			
		return Runner.controls.DateSliderFilterControl.superclass.getPreparedValue( stringValue, encoded );
		
	},
	
	/**
	 * Put backslashes in front of every search-syntax character (~,(,))
	 * in the slider's min knob value's string representation
	 * @param {boolean} encoded
	 * @return {string}
	 */	
	getPreparedMinValue: function( encoded ) {
		var date = this.ctrlValues[0],
			stringValue = this.getStringValueFromDate( date );
			
		return Runner.controls.DateSliderFilterControl.superclass.getPreparedValue( stringValue, encoded );
	},
	
	/**
	 * Replace undefined filter's values with corresponding
	 * slider's min and max date values
	 */	
	prepareControlValues: function() {
		var date;
		
		if ( this.ctrlValues[0] === undefined || this.ctrlValues[0] === null ) {
			date = this.realMinDate || this.minDate;
			if ( this.stepType === Runner.controls.constants.FILTER_STEP_YEAR ) {
				date = new Date( date.getFullYear(), 0, 1 );
			}			
			this.ctrlValues[0] = date;
		}
		
		if ( this.ctrlValues[1] === undefined || this.ctrlValues[1] === null ) {
			date = this.realMaxDate || this.maxDate;
			if ( this.stepType === Runner.controls.constants.FILTER_STEP_YEAR ) {
				date = new Date( date.getFullYear(), 11, 31 );
			} 				
			this.ctrlValues[1] = this.maxDate;
		}
	},

	/**
	 * Check if the slider's min and max knobs are equal to the
	 * the min and max slider's values respectively
	 * @return {boolean}
	 */
	knobsAreOnTheLimits: function() {
		if ( this.ctrlValues[0].toString() === ( this.realMinDate || this.minDate ).toString() &&
			 this.ctrlValues[1].toString() === ( this.realMaxDate || this.maxDate ).toString() ) {
			 
			return true;
		}
		return false;
	},
	
	/**
	 * Get the db-formatted date/date-time string
	 * @param {Date object} date
	 * @return {string}
	 */
	getStringValueFromDate: function( date ) {
		var dateString,
			day = date.getDate(),
			month = date.getMonth() + 1,
			year = date.getFullYear(),
			hours, minutes, seconds;
		
		dateString = year + '-' + month + '-' + day;
		
		if ( this.showTime ) {
			hours = date.getHours();
			hours = hours < 10 ? '0' + hours : hours;
			minutes = date.getMinutes();
			minutes = minutes < 10 ? '0' + minutes : minutes;
			seconds = date.getSeconds();
			seconds = seconds < 10 ? '0' + seconds : seconds;
			
			dateString += ' ' + hours + ':' + minutes + ':' + seconds;
		}
		
		return dateString;
	},
	
	/**
	 * Get the formated time string
	 * Here is the possible time formatch list:
	 * ("H:mm:ss","HH.mm.ss","HH:mm:ss","HH:mm:ss 'ch'","h::mm::ss tt","h:mm:ss tt","h:mm:ss.tt","hh:mm:ss tt","tt h:mm:ss","tt hh:mm:ss")	
	 *			 
	 * @param {Date object} date
	 * @return {string}
	 */
	printTime: function( date ) {
		var hours = date.getHours(),
			minutes = date.getMinutes(),
			seconds = date.getSeconds(),
			time = this.timeFormat,
			designator;
		
		if ( !this.is24hoursFormat ) {
			designator = hours >= 12 ? this.designators["pm"] : this.designators["am"];
			//designators are no added to 'hours' values greater than 23 
			designator = hours >= 24 ? "" : designator;
			time = time.replace( "tt", designator );
			
			//a correction is not applied to 'hours' values greater than 24 or lesser than 12
			hours = hours > 12 && hours < 24 ? hours - 12 : hours;
			hours = hours === 0 ? 12 : hours;
			
			hours = this.leadingZero && hours < 10 ? '0' + hours : hours;
			time = time.replace( this.leadingZero ? "hh" : "h", hours );
		} else {
			hours = this.leadingZero && hours < 10 ? '0' + hours : hours;
			time = time.replace( this.leadingZero ? "HH" : "H", hours );
		}
		
		time = time.replace( "mm", minutes < 10 ? '0' + minutes : minutes );
		
		if ( this.showSeconds ) {
			time = time.replace( "ss", seconds < 10 ? '0' + seconds : seconds );
		} else {
			time = time.replace( this.timeDelimiter + "ss", "" );
		}		

		return time;
	}
});

/**
 * The Time Slider Filter control class
 */ 
Runner.controls.TimeSliderFilterControl = Runner.extend( Runner.controls.DateSliderFilterControl, {
	/**
	 * @type {number}
	 */
	TimezoneOffsetInHours: 0,

	/**
	 * @type {boolean}
	 */
	isFieldTimeType: true,
	
	/**
	 * @type {number}
	 */
	offsetDaytimeHours: 24,

	/**
	 * @type {boolean}
	 */	
	processWrappers: false,	
	
	
	constructor: function( cfg ) {
		Runner.controls.TimeSliderFilterControl.superclass.constructor.call(this, cfg); 
	},
	
	/**
	 * Init the time-slider control
	 */	
	init: function() {
		this.TimezoneOffsetInHours = new Date().getTimezoneOffset() / 60;
		this.offsetDaytimeHours = 24 + this.TimezoneOffsetInHours;	
		
		Runner.controls.TimeSliderFilterControl.superclass.init.call( this ); 
	},	
	
	/**
	 * Get the real hours value for the date passed
	 * @param {Date object} date
	 * @return {number}
	 */	
	getHoursValue: function( date ) {
		var dateInHours = date.getTime() / 3600000;
		
		// process the case when the hours value could be greater then 24
		if ( dateInHours < this.offsetDaytimeHours ) {	
			return date.getHours();
		}
		return Math.floor( dateInHours - this.TimezoneOffsetInHours );
	},	
	
	/**
	 * Get the db-formatted time string
	 * @param {Date object} date
	 * @return {string}
	 */
	getStringValueFromDate: function( date ) {
		var hours = this.getHoursValue( date ), 
			minutes = date.getMinutes(), 
			seconds = date.getSeconds();

		hours = hours < 10 ? '0' + hours : hours;
		minutes = minutes < 10 ? '0' + minutes : minutes;
		seconds = seconds < 10 ? '0' + seconds : seconds;
		
		return hours + ':' + minutes + ':' + seconds;
	}, 	
	
	/**	
	 * Get the correct slider's caption
	 * @param {Date object} date
	 * @return {string}
	 */
	getCaptionValue: function( date ) {				
		return this.printTime( date );	
	}
});
/**
 * Search form with user interface.
 */
Runner.search.SearchFormWithUI = Runner.extend( Runner.search.SearchForm, {	
	/**
	 * Options panel show status indicator
	 * @type Boolean
	 */
	srchOptShowStatus: false,
	/**
	 * Search win show status indicator
	 * @type Boolean
	 */
	srchWinShowStatus: false,
	/**
	 * Show status indicator of div, which contains add filter buttons
	 * @type Boolean
	 */
	ctrlChooseMenuStatus: false,
	/**
	 * Show status indicator of search type combos
	 * @type Boolean
	 */
	ctrlTypeComboStatus: false,
	/**
	 * jQuery object of img-button options panel expander
	 * @type {object}
	 */
	srchOptExpander: null,

	/**
	 * jQuery object with div, that contains all search elements
	 * @type {object}
	 */
	srchBlock: null,
	
	/**
	 * The 'Show all' button object
	 * @type {jQuery object} 
	 */
	showAllButton: null,
	
	showAllButtStatus: false,
	
	/**
	 * jQuery object with div, that contains all search controls
	 * @type {object}
	 */
	srchCtrlsBlock: null,
	
	/**
	 * Show status indicator of search block
	 * @type Boolean
	 */
	srchBlockStatus: true,
	
	/**
	 * The list of search fields that can be added to the Search panel
	 * @type {jQuery object}
	 */
	ctrlChooseMenuList: null,

	/**
	 * Search panel icon switcher text
	 */
	showOptText: Runner.lang.constants.TEXT_SEARCH_SHOW_OPTIONS,
	
	/**
	 * Search panel icon switcher text
	 */
	hideOptText: Runner.lang.constants.TEXT_SEARCH_HIDE_OPTIONS,
	
	/**
	 * Search type combos switcher text
	 */
	showComboText: Runner.lang.constants.TEXT_SHOW_OPTIONS,
	
	/**
	 * Search type combos switcher text
	 */
	hideComboText: Runner.lang.constants.TEXT_HIDE_OPTIONS,
	
	/**
	 * Array of search type combos
	 * @type {array}
	 */
	searchTypeCombosArr: null,
	
	/**
	 * Array of divs, that used as containers for one search control with its combos, delete buttons etc.
	 * @type {array}
	 */
	srchFilterRowArr: null,
	
	/**
	 * The search fields labels array
	 * @type {object}
	 */
	searchFieldsLabels: null,
	
	/**
	 * The 'Show\Hide options' button that toggles search type combos
	 * @type {jQuery object}
	 */
	showHideSearchOptionsButton: null,

	/**
	 * The host page object reference
	 * @type {object} 
	 */
	pageObj: null,

	/**
	 * Array of bricks for search
	 * @type object 
	 */
	searchBricks: null,
	
	/**
	 * Criteria container
	 * @type object 
	 */
	topCritCont: null,
	
	/**
	 * Temporary array needed for floating/fixed panel reposition
	 * @type array 
	 */
	clonedContainers: [],
	
	/**
	 * Constructor
	 * @param {obj} cfg
	 */
	constructor: function( cfg ) {
		// recreate objects
		this.srchFilterRowArr = [];
		this.searchFieldsLabels = {};
		this.searchTypeCombosArr = [];
		
		// set search bricks array 
		this.searchBricks = ['search', 'vsearch2', 'searchpanel'];
	
		Runner.search.SearchFormWithUI.superclass.constructor.call(this, cfg);
	
		// get current page object
		this.pageObj = Runner.pages.PageManager.getAt( this.tName, this.id );

		this.srchOptExpander = $("a[id=showOptPanel" + this.id + "]");
		this.topCritCont = $('.srchCritTop', this.pageObj.pageCont);	
		this.srchBlock = $("#search_block" + this.id);	
		this.srchCtrlsBlock = $(".controlsBlock", this.pageObj.pageCont);
		
		this.showAllButton = $("a[id=showAll" + this.id + "]");
		this.showHideSearchOptionsButton = $('#showHideSearchType' + this.id);
		this.addSearchFieldButton = $("#showHideControlChooseMenu" + this.id);
		
		this.showAllButtStatus = this.usedSrch;
		
		this.initCtrlChooseMenu();
	},

	/**
	 * Create a Menu list filling it with the searchable fields' names.
	 * It allows users to add choosen ctrls to the Search Panel
	 */	
	initCtrlChooseMenu: function() {
		if ( this.ctrlChooseMenuList && !this.ctrlChooseMenuList.length ) {
			return;
		}
		
		var list = $('<ul class="rnr-list controlChooseMenu"></ul>'), 
			controller = this,
			i, li, fName;
		
		for (i = 0; i < this.fNamesArr.length; i++) {	
			li = $('<li></li>').appendTo( list );
			fName = this.fNamesArr[i];
			
			$('<a href="#" class="rnr-button link" >' + this.searchFieldsLabels[ fName ]  + '</a>')
				.attr( "id", "addSearchControl_" + fName )
				.appendTo( li )
				// 'touchend' safari + ios fix
				.bind( "click touchend", { fName: fName }, function(e) { 
					controller.addSearchFieldButton.parent()
						.addClass("hiddenButtonGroup");					
					
					controller.addFilter( e.data.fName );
					controller.hideCtrlChooseMenu();
					return false;
				});			
		}
		
		this.ctrlChooseMenuList = list.insertAfter( this.addSearchFieldButton );	
	},
	
	/**
	 * Return search type combo container ids
	 * @param {string} fName
	 * @param {int} ind
	 * @return {string}
	 */
	getComboContId: function( fName, ind ) {
		return "searchType_" + ind + "_" + Runner.goodFieldName( fName );
	},
	
	getComboId: function( fName, id ) {
		return "srchOpt_" + id + "_" + Runner.goodFieldName( fName );
	},
	
	/**
	 * Create flyDiv with search controls
	 * If used as onlick handler pass event object, for get click coords
	 * @param {Object} e	The event or popup window's state object
	 */
	showSearchWin: function(e) { 
		this.hideCtrlChooseMenu();
		this.pageObj.hideBrick("search_buttons");
		this.pageObj.hideBrick("vsearch1");
		
		var x = e ? (e.x || e.pageX) : 50, 
			y = e ? (e.y || e.pageY) : 50, 
			width = (e && e.w) ? e.w : 400,
			height = (e && e.h) ? e.h : (Runner.isIE ? 200 : 0),
			$window, windowWidth, windowHeight, args, diffWidth, diffHeight;
			
		if (e) {
			$window = $(window);
			windowWidth = $window.width();
			windowHeight = $window.height();
			diffWidth = windowWidth - width;
			diffHeight = windowHeight - height;
			
			x = diffWidth < x ? diffWidth - 15 : x;
			y = diffHeight < y ? diffHeight - 15 : y;
			
			if ( x < 0 ) {
				x = 0;
				//set width to the default
				width = 400;
			}

			if ( y < 0 ) {
				y = 0;
				height = windowHeight;
			}
		}				
				
		args = {
			xy: [x, y],
			width: width,
			headerContent: '<span style="color: white;">' + Runner.lang.constants.SEARCH_FOR + '</span>'
				+ '<span style="position:absolute; top:2px; right:23px;">'
				+ '<a id="pinSrchWin' + this.pageObj.id + '" class="rnr-button img" href="#" data-icon="panelunfloat" title="Floating window" >'
				+ '</a></span>'
		};
		if ( height ) {
			args.height = height;
		}
			
		//create fly win yui panel
		Runner.pages.PageManager.createFlyWin.call( this, args, false, $.proxy( this.afterCreateSearchFlyWinHandler, this ) );
	},

	/**
	 * the 'afterCreateFlyWin' callback function 
	 * for the Runner.pages.PageManager.createFlyWin method
	 * @param {YUI3 Panel object}
	 */
	afterCreateSearchFlyWinHandler: function( win ) {
		if ( !win ) {
			return;
		}
				
		var searchFormObj = this;
		
		// set the 'win' property
		this.win = win;
		// copy container and get bricks from parent page
		this.getBricksFromParent( win );
			
		this.srchWinShowStatus = true;
		this.showSearchOptions();
		this.initWinDelButtons( win );
		
		$("a[id='pinSrchWin" + this.pageObj.id + "']").bind("click", function(e) {
			searchFormObj.hideSearchWin( win );
			searchFormObj.showSearchOptions();
			return false;
		});			
		$( win.getButton("close").getDOMNode() ).on('click', function(e) {
			searchFormObj.hideSearchWin( win );
		});
		
		win.publish("searchFieldsNumberChanged");				
		win.on("searchFieldsNumberChanged", function() {				
			// set the popup window height so the all its content will be dispalyed
			Runner.pages.RunnerPage.prototype.adjustPopWindowHeightByContent.call( searchFormObj, "rnr-flycontainer" )
		});
		
		// correct YUI window size
		Runner.pages.PageManager.correctYUIWindowSize( win, false, this );
	},
	
	/**
	 * Add click event's handler to the pop up window's body node element
	 * @param {YUI3 Panel object}	 
	 */
	initWinDelButtons: function( win ) {	
		$( win.bodyNode.getDOMNode() ).bind('click', {srchController: this}, this.delButtonHandler);
	},
	
	/**
	 * Entry point for Page's hideSearchControllerContainers function
	 */
	hideSearchControllerContainers: function() {
		this.pageObj.hideSearchControllerContainers();
	},
	
	/**
	 * Add search controls HTML block to DOM
	 * @param {string} fName
	 * @param {string} ind
	 * @param {object} blockHTML
	 */
	addCtrlsHtml: function( fName, ind, blockHTML ) {
		this.addPanelHtml( fName, ind, blockHTML );
		// take tr container
		var rowCont = $('#' + this.getFilterRowId( fName, ind, this.srchWinShowStatus )),
			// put into cells block html
			cells = rowCont.children(),
			cellHTML = '<div class="rnr-searchtype">' + blockHTML.comboHtml + '</div>'
					+ '<div class="rnr-searchcontrol">' + blockHTML.control1 + '</div>'
					+ '<div class="rnr-searchcontrol">' + blockHTML.control2 + '</div>';
		
		if ( !Runner.isMobile ) {
			cells.eq(0).html( blockHTML.delButt );
			cells.eq(2).html( cellHTML );
		} else {
			cells.eq(1).html( cellHTML );
		}
	},	

	/**
	 * Get conainers and bricks for search window from parent page
	 * Containers clone
	 * Need bricks replace and unnecessary bricks remove
	 * @param {YUI3 Panel object} win		 
	 */
	getBricksFromParent: function( win ) {
		var bricksObjs = this.pageObj.getBricksObjs( this.searchBricks ),
			_self = this,
			newContents = $("<div class='rnr-flycontainer'></div>"),
			brickName;
			
		this.clonedContainers = [];	
		for (brickName in bricksObjs) {
			$.each( bricksObjs[brickName], function(index, _brick) {
				var alreadyCloned, clonedCont;
				
				alreadyCloned = $.grep(_self.clonedContainers, function(n, i) {
					return n.source.is(_brick.contObj);
				});
				if ( !alreadyCloned.length ) {
					clonedCont = _brick.contObj.cloneEmpty();
					_self.clonedContainers.push({
						source: _brick.contObj,
						clone: clonedCont,
						bricks: [_brick]
					});
				} else {
					clonedCont = alreadyCloned[0].clone;
					alreadyCloned[0].bricks.push(_brick);
				}
				_brick.moveTo(clonedCont);
				_brick.show();
			});
		}
		//	put cloned containers to search panel
		$.each( _self.clonedContainers, function(index, container) {
			container.clone.appendTo(newContents);
		});
		
		win.set("bodyContent", newContents.get(0));
	},

	/**
	 * Return bricks from search window to parent page
	 * @param {YUI3 Panel object} win	 
	 */
	setBricksToParent: function( win ) {
		$.each( this.clonedContainers, function(index, container) {
			var source = container.source;
			$.each( container.bricks, function(index, brick) {
				brick.moveTo(source);
			});
		});

		win.set("bodyContent", "");
	},

	/**
	 * Toggle the 'Show all' button
	 * @param {Boolean} toggler
	 */
	toggleShowAll: function( toggler ) {
		toggler ? this.showShowAll() : this.hideShowAll() ;
	},
	
	hideShowAll: function() {
		Runner.hideButton( this.showAllButton );
		this.showAllButtStatus = false;
	},
	
	showShowAll: function() {
		Runner.showButton( this.showAllButton );
		this.showAllButton.parent().show();
		this.showAllButtStatus = true;
	},
	
	/**
	 * Remove fly div and place controls to the search panel
	 * @param {YUI3 Panel object} win	 
	 */
	hideSearchWin: function( win ) {
		// return bricks from search window to parent page
		this.setBricksToParent( win );
		this.hideCtrlChooseMenu();
		this.hideSearchOptions();
		
		// hide button for toggle search panel
		this.pageObj.showBrick("search_buttons");
		this.pageObj.showBrick("vsearch1");
			
		this.pageObj.destroyWin.call(this);
		this.srchWinShowStatus = false;
	},

	/**
	 * Showes search options div and changes image expander 
	 */
	showSearchBlock: function() {
		this.srchBlock.show();
		this.srchBlockStatus = true;
	},

	/**
	 * Closes search options div and changes image expander 
	 */
	hideSearchBlock: function() {
		this.srchBlock.hide();
		this.srchBlockStatus = false;
	},
	
	/**
	 * Search options switcher
	 * opens and closes options in search panel
	 */
	toggleSearchBlock: function() {
		// can open panel, only if win is hidden
		this.srchBlockStatus && !this.srchWinShowStatus ? this.hideSearchBlock() : this.showSearchBlock();
	},
	
	/**
	 * Show the search options div and change the expander's image
	 */
	showSearchOptions: function() {
		this.pageObj.showBrick('searchpanel');
		
		// change image
		this.srchOptExpander
			.attr("title", this.hideOptText)
			.attr("data-icon", "panelup");
		
		this.srchOptShowStatus = true;
		this.recalculationGridSize();
	},
	
	/**
	 * Closes the search options div and change the expander's image 
	 */
	hideSearchOptions: function() {
		this.pageObj.hideBrick('searchpanel');

		$('.rnr-datepicker').hide();
		
		// change image		
		this.srchOptExpander
			.attr('title', this.showOptText)
			.attr("data-icon", "paneldown");
		
		this.srchOptShowStatus = false;
		this.recalculationGridSize();
	},
	
	/**
	 * Search options switcher
	 * opens and closes options in search panel
	 */
	toggleSearchOptions: function() {
		// can open panel, only if win is hidden
		this.srchOptShowStatus && !this.srchWinShowStatus ? this.hideSearchOptions() : this.showSearchOptions();
		this.hideCtrlChooseMenu();
	},

	/**
	 * Show the search options div and chang the expander's image
	 */
	showCtrlChooseMenu: function() { 
		return;
		if ( !this.ctrlChooseMenuList || !this.ctrlChooseMenuList.length ) {
			this.initCtrlChooseMenu();
		}

		var controller = this,
			hideHandler = function() {
				controller.hideCtrlChooseMenu();
			},
			showHandler = function() {
				controller.showCtrlChooseMenu();
			};
		this.showTask = new Runner.util.DelayedTask( showHandler );
		this.hideTask = new Runner.util.DelayedTask( hideHandler );
		
		this.ctrlChooseMenuList
			.bind('mouseover', function(e) {
				controller.hideTask.cancel();
				controller.showTask.delay(50, showHandler, null, [e]);
			})
			.bind('mouseout', function(e) {
				controller.showTask.cancel();
				controller.hideTask.delay(50, hideHandler, null, [e]);
			});

		this.showCtrlChooseMenu = function() {
			var buttonPosition = this.addSearchFieldButton.offset();
			this.hideTask.cancel();
			this.ctrlChooseMenuList.css({
				'top': buttonPosition.top + this.addSearchFieldButton.outerHeight() + 'px', 
				'left': buttonPosition.left + ( Runner.isDirRTL() ? this.addSearchFieldButton.outerWidth() - this.ctrlChooseMenuList.outerWidth() : 0 ) + 'px'
			}).show();
			
			if ( this.ctrlChooseMenuList.width() < this.addSearchFieldButton.width() ) {
				this.ctrlChooseMenuList.width( this.addSearchFieldButton.width() );
			}

			// set max z-index
			Runner.setZindexMaxToElem( this.ctrlChooseMenuList );
			this.ctrlChooseMenuStatus = true;
		}
		// call function, after lazy-init
		this.showCtrlChooseMenu();
	},
	
	/**
	 * Closes search options div and changes image expander 
	 */
	hideCtrlChooseMenu: function() {
		var _self = this;
		
		if ( !this.ctrlChooseMenuList || !this.ctrlChooseMenuList.length ) {
			this.initCtrlChooseMenu();
		}
		this.ctrlChooseMenuList.hide();
		
		// reset the inline display style to css ':hover' display rules will be applied 
		this.pageObj.resetButtonGroupDisplayStyle( this.ctrlChooseMenuList );

		
		this.ctrlChooseMenuStatus = false;
	},
	
	/**
	 * Search options switcher
	 * opens and closes options in search panel
	 */
	toggleCtrlChooseMenu: function() {
		this.ctrlChooseMenuStatus ? this.hideCtrlChooseMenu() : this.showCtrlChooseMenu();
	},
	
	/**
	 * Search type combos show handler
	 */
	showCtrlTypeCombo: function() {
		this.toggleSearchControlsOptionsCombo( true );
	},
	
	/**
	 * Search type combos hide handler
	 */
	 hideCtrlTypeCombo: function() {
		this.toggleSearchControlsOptionsCombo( false );
	},
	
	/**
	 * Toggle the seach controls' search options select elements
	 * Update the ctrlTypeComboStatus and changd the combo button's label.
	 * If toggler is falsy It hides the search options otherwise It shows them
	 * @param {boolean} toggler
	 */
	toggleSearchControlsOptionsCombo: function( toggler ) {
		var $select, selectValue;
		
		for (var i = 0; i < this.searchTypeCombosArr.length; i++) {
			$select = this.searchTypeCombosArr[i].find('select');
			selectValue = $select.val();
			
			if ( selectValue === 'Empty' || selectValue === 'NOT Empty' ) {
				this.updateControlSearchOptionsCombo( $select, toggler );			
				$select.val( selectValue );
				continue;
			} 
			
			this.searchTypeCombosArr[i].toggle( toggler );
			$select.toggle( toggler );
		}
		
		this.showHideSearchOptionsButton.html( toggler ? this.hideComboText : this.showComboText );
		this.showHideSearchOptionsButton.attr('title', toggler ? this.hideComboText : this.showComboText );
		this.ctrlTypeComboStatus = toggler;	
	},
	
	/**
	 * Update the search options list basing on the toggler value.
	 * If toggler is falsy the combo will show 'empty' and 'Is not empty' options empty
	 * otherwise It'll show all allowed contol's search options
	 * @param {jQuery object} $select	
	 * @param {boolean} toggler	
	 */
	updateControlSearchOptionsCombo: function( $select, toggler ) {
		var $options = $select.find('option'), 
			$emptyOptions;
		
		if ( !toggler && $options.not("[value='Empty'],[value='NOT Empty']").length ) {
			$select.data( "options", $options.clone() );
			$emptyOptions = $select.find("option[value='Empty'], option[value='NOT Empty']").clone();
			
			$options.remove();
			$select.append( $emptyOptions );
			return;
		} 
		
		if ( toggler && $select.data("options") ) {
			$options.remove();
			$select.append( $select.data("options") );		
			$select.data("options", null);
		}
	},
	
	/**
	 * Search type combos show\hide switcher
	 */
	toggleCtrlTypeCombo: function() {
		this.toggleSearchControlsOptionsCombo( !this.ctrlTypeComboStatus );
	},
	
	/**
	 * Show/hide the criteria block, the Search button and 
	 * the 'Show/Hide options' button basing on the number of 
	 * visible search field blocks on the Search panel
	 * @param {number} ctrlsCount
 	 */
	toggleSearchButtonsState: function( ctrlsCount ) {
		var topCriteriaController = this.topCritCont,
			optionsButton = this.showHideSearchOptionsButton,
			bottomSearchButt = $('.bottomSearchButt', this.pageObj.pageCont);

		this.toggleSearchButtonsState = function( ctrlsCount ) {
			topCriteriaController.toggle( ctrlsCount > 1 );
			bottomSearchButt.toggle( ctrlsCount > 0 );
			optionsButton.toggle( ctrlsCount > 0 );
		}

		this.toggleSearchButtonsState( ctrlsCount );
	},
	
	/**
	 * Recalculate the grid's size
	 * Change height on thead grid
	 */
	recalculationGridSize: function() {
		var scrollGridBody = this.pageObj.isScrollGridBody,
			recsPerRowList = this.pageObj.recsPerRowList,
			baseCalssPref = this.pageObj.oldLayout ? "runner-" : "rnr-",
			footer, bottomRow, newTheadHeight, scrollGridHeight, footerHeight, bottomHeight;
		
		if ( !scrollGridBody || recsPerRowList > 1 ) { 
			return;
		}
		
		newTheadHeight = $('thead tr th', this.pageObj.gridElem).height();
		if ( newTheadHeight == this.pageObj.gridElem.data('theadheight') ) {
			return;
		}
		scrollGridHeight = $("." + baseCalssPref + "scrollgrid-inner").height();
		
		footer = $('tr.footer td', this.pageObj.gridElem);
		bottomRow = $('.' + baseCalssPref + 'bottomrow', this.pageObj.gridElem);
		footerHeight = footer.height();
		bottomHeight = bottomRow.height();
		
		footer.css("top", (scrollGridHeight + newTheadHeight - footerHeight - bottomHeight) + "px");
		bottomRow.css("top", (scrollGridHeight + newTheadHeight - bottomHeight) + "px");	
		
		this.pageObj.gridElem.closest("." + baseCalssPref + "scrollgrid-wrap").css('padding', newTheadHeight + 'px 0 0');
		
		this.pageObj.gridElem.data('theadheight', newTheadHeight);
	}
});

/**
 * search panel controller. Used for manage search on the list page
 * for multiple search classes use id param.
 * @class
 * @param {object} cfg
 */
Runner.search.SearchController = Runner.extend( Runner.search.SearchFormWithUI, {
	/**
	 * Ajax add filter cache url
	 * @type String
	 */
	ajaxSearchUrl: "",
	
	/**
	 * Reusable style display none
	 * @type String
	 */
	styleDispNoneText: 'display: none;',
	
	/**
	 * Indicator: true when simple or google-like search is active
	 * @type {Boolean}
	 */
	simpleSearchActive: false,
	
	/**
	 * Indicator, that is true if the Search panel is flexible
	 */
	isSearchPanelInflexible: false,
	
	/**
	 * Array containing the Search panle fields' names
	 */
	panelSearchFields: [],
	
	/**
	 * Search options for all inflexible Search panel's fields
	 */
	inflexSearchOptions: {},
	
	/**
	 * The search table's name
	 */
	searchTableName: "",
	
	/**
	 * The array containg filter controls data
	 */
	filterContolsData: [], 
	
	/**
	 * The array of filter controls
	 */
	filterControls: [],
	
	/**
	 * Reference to timeout set up during the last keyup event
	 */
	submitTimeout: null,

	/**
	 * The 'Reset' button object
	 * @type {jQuery object} 
	 */
	resetButton: null,	
	
	
	/**
	 * Override parent contructor
	 * Add interaction with server
	 * @param {obj} cfg
	 */
	constructor: function( cfg ) {
		Runner.search.SearchController.superclass.constructor.call( this, cfg );

		this.ajaxSearchUrl = Runner.getPageUrl(this.shortTName, 'search');
		this.simpleSearchActive = Runner.pages.PageSettings.getTableData( cfg.tName, "simpleSearchActive" );
		this.resetButton = $("a[id=clearSearch" + this.id + "]");
	},
	
	init: function( ctrlsBlocks ) {
		Runner.search.SearchController.superclass.init.call( this, ctrlsBlocks );
		
		this.initFastSearch();
		this.initFilters();
		this.remindSearchPanelState();		
				
		this.savePanelsStateBeforeUnload();		
	},

	/**
	 * Add the rememberSearchPanelState and rememberFilterPanelState
	 * methods invocation to the 'onbeforeUnload' event's handler
	 */
	savePanelsStateBeforeUnload: function() {
		var serachController = this;
		 
		$(window).on('beforeunload', function() {
			serachController.rememberSearchPanelState();
			serachController.rememberFilterPanelState();
		}); 
	},
	
	/**
	 * Add 'keyup'/'keydown' listeners to the Simple search input element
	 */
	initFastSearch: function() {
		var searchController = this;
		
		this.smplSrchBox
			.on('keyup', function(e) {
				if ( Runner.isMobile || !Runner.isAcceptableKeyCode(e) ) {
					return;
				}
				
				if ( searchController.submitTimeout ) {
					clearTimeout( searchController.submitTimeout );
				}
				
				var srchBoxObj = this;
				searchController.submitTimeout = setTimeout( function() {
					if ( searchController.useSuggest ) { 
						searchSuggest(e, srchBoxObj, 'ordinary', Runner.getPageUrl('searchsuggest','','table=' + searchController.shortTName), 1);
					}	
				}, 500);
			})
			.on('keydown', function(e) {
				searchController.listenEvent(e, this);
			});
	},
	
	/**
	 * Initialize the search buttons
	 */	 
	initButtons: function() {
		var searchController = this;
		Runner.search.SearchController.superclass.initButtons.call(this);
		
		$("a#searchButtTop" + this.id).bind("click", function(e) {
			searchController.submitSearch();
			return false;	
		});
							
		this.resetButton.on("click", function(e) {
			searchController.clearSearch();
			return false;	
		}); 
		
		$("a#showOptPanel" + this.id).bind("click", function(e) {
			searchController.toggleSearchOptions();
			return false;
		});
		
		$("a#showSrchWin" + this.id).bind("click", function(e) {
			searchController.showSearchWin(e);
			return false;
		});

		
		this.addSearchFieldButton
			.on("click", function(e) {
				$(this).parent().removeClass("hiddenButtonGroup");	
				return false;
			})
			.on("mouseenter", function() {
				$(this).parent().removeClass("hiddenButtonGroup");	
			});

		this.showHideSearchOptionsButton.on("click", function(e) {
			searchController.toggleCtrlTypeCombo();
			return false;
		});
			
		this.showAllButton.on("click", function(e) {
			searchController.showAllSubmit();
			return false;
		}); 			
		
		this.initSearchButton();
		this.initDelButtons();
	},
	
	/**
	 * Toggle the 'Reset' button
	 * @param {Boolean} toggler
	 */
	toggleResetButton: function( toggler ) {
		toggler ? this.showResetButton() : this.hideResetButton() ;
	},
	
	hideResetButton: function() {
		Runner.hideButton( this.resetButton );
	},
	
	showResetButton: function() {
		Runner.showButton( this.resetButton );
		this.resetButton.parent().show();
	},
	
	/**
	 * Init the Search button functionality
	 */
	initSearchButton: function() {
		var searchController = this;
		
		this.searchButton.bind("click", function(e) {
			if ( !Runner.isDisabledButton(this) ) {
				searchController.submitSearch();
			}
			return false;			
		});
	},
	
	/**
	 * Add click event's handler to the Search panel's controls block element
	 */
	initDelButtons: function() {
		// 'touchend' safari + ios fix
		this.srchCtrlsBlock.bind('click touchend', {srchController: this}, this.delButtonHandler);
	},

	/**
	 * The click event handler that invokes the delCtrl method
	 * if the Delete Search Control button is clicked
	 * The event object's date property is augmented with 
	 * the srchController property pointing to this
	 * @params {object} e	
	 */
	delButtonHandler: function(e) {
		var srchController = e.data.srchController,
			$target = $( e.target ),
			fName = $target.attr("fName"), 
			ctrlId, i;
				
		if ( !$target.is("a") || !$target.is(".searchPanelButton") || !fName ) {
			return;
		}
		
		ctrlId = parseInt( $target.attr("ctrlId"), 10 );
		for (i = 0; i < srchController.fNamesArr.length; i++) {
			if ( fName == Runner.goodFieldName( srchController.fNamesArr[i] ) ) {
				fName = srchController.fNamesArr[i];
				break;
			}
		}
		
		srchController.delCtrl(fName, ctrlId);
		return false;
	},

	/**
	 * Get the string representation value of the any field engaged in the current search
	 * @return {String}
	 */
	getTheFirstSearchControlValue: function() {
		var i, fName, searchFields;
		
		if ( this.simpleSearchActive /*&& this.fNamesArr.length*/ ) {
			return this.smplSrchBox.val();
			//return this.fNamesArr[0];
		}
		
		for (i = 0; i < this.filterControls.length; i++) {
			if ( this.filterControls[i].filtered ) {
				return this.filterControls[i].getValue();
				//return this.filterControls[i].fieldName
			}
		}
		
		for (fName in this.searchFields) {
			searchFields = this.searchFields[ fName ];
			for (i = 0; i < searchFields.length; i++) {
				if ( searchFields[i].checkIfCtrlsValuesSet() ) {
					return searchFields[i].getControl().getStringValue();
					//return fName;
				}
			}
		}
		return "search";
	},
	
	/**
	 * Get an index of the last control added from cache. 
	 * @param {string} filterName
	 * @return {int}
	 */
	getLastAddedInd: function( filterName ) {
		// if no map for this field
		if ( !this.ctrlsShowMap[ filterName ] ) {
			return false;
		}
		// get last added and not cached ctrls block index
		var maxInd = 0, 
			beforeMaxInd = false, 
			i = 0,
			ind;
			
		for (ind in this.ctrlsShowMap[ filterName ]) {
			// need to convert to int from string. May be because object property name is string, typeof return string
			ind = parseInt( ind, 10 );
			// get max index, it will give last cached
			if ( maxInd < ind ) {
				beforeMaxInd = maxInd;
				maxInd = ind;
			}
			// at first time take maxInd, because 0 may not appear
			if ( i === 0 ) {
				beforeMaxInd = maxInd;
			}
			i++;
		}
		return beforeMaxInd;
	},
	
	/**
	 * Get the last added filter, usefull when add new
	 * @param {string} filterName field name
	 * @return {object} 
	 */
	getLastAdded: function( filterName ) {
		var beforeMaxInd = this.getLastAddedInd(filterName),
			filterObj;
			
		if (!beforeMaxInd) {
			return;
		}
		// get obj
		filterObj = $( '#' + this.getFilterRowId(filterName, beforeMaxInd) );
		if (filterObj.length) {
			return filterObj;
		}
	},
	
	addPanelHtml: function( fName, ind, blockHTML ) {
			// ctrl main container id
		var newSrchCtrlContId = this.getFilterRowId( fName, ind ),
			// add ctrl main container
			filterRowHtml = this.createTableRow( newSrchCtrlContId, 'srchPanelRow', this.styleDispNoneText, '' ),
			newSrchCtrlCont, fNameCellHtml, comboHtml;
		
		this.srchCtrlsBlock.append( filterRowHtml );
		// main container obj
		newSrchCtrlCont = $("#" + newSrchCtrlContId);
		// add del button
		if (!Runner.isMobile) {
			newSrchCtrlCont.append( this.createTableCell('srchPanelCell', '', '') );
			// add div with field name
			fNameCellHtml = this.createTableCell('srchPanelCell', '', blockHTML.fLabel + ':&nbsp;');
		} else {
			// add div with field name
			fNameCellHtml = this.createTableCell('srchPanelCell', '', blockHTML.delButt + '&nbsp;' + blockHTML.fLabel + ':&nbsp;');
		}
		newSrchCtrlCont.append( fNameCellHtml );
		// combo type container id
		comboHtml = this.createTableCell('srchPanelCell srchPanelCell2', (this.ctrlTypeComboStatus ? '' : this.styleDispNoneText), '');	
		newSrchCtrlCont.append( comboHtml );
	
		return newSrchCtrlCont;
	},
		
	/**
	 * Adds block to map, regs its components and ands HTML
	 * @param {string} fName
	 * @param {number} ind
	 * @param {number} ctrlIndArr
	 * @param {object} blockHTML
	 */
	addRegCtrlsBlock: function( fName, ind, ctrlIndArr, blockHTML ) {
		if ( blockHTML ) {
			//add ctrls block HTML to DOM
			this.addCtrlsHtml( fName, ind, blockHTML );
		}
		
		Runner.search.SearchController.superclass.addRegCtrlsBlock.call( this, fName, ind, ctrlIndArr );
			
		// reg combos
		this.searchTypeCombosArr.push( $("#" + this.getComboContId( fName, ind )) );
		// reg filter div block
		this.srchFilterRowArr.push( $("#" + this.getFilterRowId( fName, ind )) );
		// call crit controller
		this.toggleSearchButtonsState( this.getVisibleBlocksCount() );			
	},
	
	/**
	 * Creates table row and cell containers html
	 * @param {string} id
	 * @param {string} cssClass
	 * @param {string} style
	 * @param {string} innerHtml
	 * @return {string}
	 */
	createTableRow: function(id, cssClass, style, innerHtml) {
		if (!Runner.isMobile) {
			return '<tr class="' + cssClass+'" id="' + id + '" style="' + style + '">' + innerHtml + '</tr>';
		}
		return '<div class="' + cssClass + '" id="' + id + '" style="' + style + '">' + innerHtml + '</div>';
	},
	
	createTableCell: function(cssClass, style, innerHtml) {
		if (!Runner.isMobile) {
			return '<td class="' + cssClass + '" style="' + style + '">' + innerHtml + '</td>';
		}
		return '<div class="' + cssClass + '" style="' + style + '">' + innerHtml + '</div>';
	},
	
	/**
	 * Put block into right place depending on ctrl type. 
	 * If parent field name passed, ctrl will be placed bellow parent
	 * If no parent passed, ctrl will be placed above last added for this field
	 * @param {string} filterName
	 * @param {number} cachedInd
	 * @param {string} parentFieldName
	 */
	putCachedBlock: function( filterName, cachedInd, parentFieldName ) {
		// get control from cache
		var filterRowId = this.getFilterRowId( filterName, cachedInd ),
			cachedRow = $("#" + filterRowId),
			// move cached div to top, insert it after control choose menu
			lastAdded = this.getLastAdded( filterName ),
			lastAddedToParent = this.getLastAdded( parentFieldName );
		
		// if use parent
		if ( parentFieldName && lastAddedToParent ) {
			cachedRow.insertAfter( lastAddedToParent );
		} else if ( lastAdded && lastAdded.attr("id") != cachedRow.attr("id") ) {
			cachedRow.insertBefore( lastAdded );
		} else {
			this.srchCtrlsBlock.prepend( cachedRow );
		}
		// show row with controls
		cachedRow.show();
	},
	
	/**
	 * @param {string} filterName
	 * @return {jQuery object}
	 */
	createLoadingBox: function( filterName ) {
			// add tr for panel mode;
		var loadTr = $('<tr>').addClass('srchPanelRow'), 
			loadTd = $('<td>');
			
		loadTd.attr('colspan', '3')
			.addClass('cellBorderRightHovered')
			.addClass('cellBorderLeftHovered')
			.addClass('cellBorderCenterHovered')
			.html( '&nbsp;&nbsp;' + filterName + ':&nbsp;loading&nbsp;...&nbsp;' )		
			.appendTo( loadTr );
		
		return loadTr;
	},
	
	/**
	 * @param {jQuery object} loadBox
	 * @param {string} filterName
	 */
	putLoadingBox: function( loadBox, filterName ) {
		// move cached div to top, insert it after control choose menu
		var lastAdded = this.getLastAdded( filterName );
		
		if ( lastAdded ) {
			loadBox.insertBefore( lastAdded );
		} else {
			this.srchCtrlsBlock.append( loadBox );
		}
	},
	
	/**
	 * Set dependent and parent links to ctrls. 
	 * If the 'triggerReload' param is true the corresponding 
	 * event of parent ctrl will be invoked to reload dependent ctrls
	 * 
	 * @param {object} ctrl 	dependent control
	 * @param {boolean} triggerReload 	pass true to reload dependent ctrls
	 */
	setDependences: function( ctrl, triggerReload ) {
		var parentfName = ctrl.parentFieldName,
			parentInd, parentCtrl;
		
		if ( ctrl.cached || !ctrl.isLookupWizard || !parentfName || !this.ctrlsShowMap[ parentfName ] ) { 
			return;
		}
		
		// get parent index
		parentInd = this.getLastAddedInd( parentfName );
		
		if ( !this.ctrlsShowMap[ parentfName ][ parentInd ] ) {
			return;
		}
		// get parent ctrl
		parentCtrl = Runner.controls.ControlManager.getAt(this.tName, parentInd, parentfName, this.ctrlsShowMap[ parentfName ][ parentInd ][0]);
		
		// add link to child
		if ( parentCtrl.showStatus && parentCtrl.isLookupWizard ) {
			ctrl.setParentCtrl( parentCtrl );
			// add to dependent array
			parentCtrl.addDependentCtrls( [ctrl] );
			// reload all children
			if (triggerReload === true) {
				parentCtrl.fireEvent('change');
			} else if ( ctrl.preloadData ) {
				ctrl.preload( ctrl.preloadData.vals, ctrl.preloadData.fVal );
			}
			return;
		}
		
		ctrl.reload();
	},
	
	/**
	 * Get the open Search panel seach blocks' names
	 * @return {Array}
	 */
	getShownFilterNames: function() {
		var fNamesArr = [],
			fName, ind;
		
		for ( fName in this.ctrlsShowMap ) {
			for ( ind in this.ctrlsShowMap[ fName ] ) {
				// need to convert to int from string. May be because object property name is string, typeof return string
				ind = parseInt( ind, 10 );
				
				if ( this.isFieldShownById(fName, ind) ) { 
					fNamesArr.push( fName );
				}
			} 
		}
		return fNamesArr;
	},
	
	/**
	 * Show cached search field on the Search panel.
	 * If there is a cached search block for a field
	 * It shows the first control, sets focus on it and
	 * sets dependences for dropdowns
	 *
	 * @param {string} filterName
	 * @return {boolean} 
	 */
	showCached: function( filterName ) {
		if ( !this.ctrlsShowMap[ filterName ] ) { 
			return false;
		}
		
		var cachedInd, ind, cachedCtrlIndArr, 
			firstCtrlFromCache;
			
		for ( ind in this.ctrlsShowMap[ filterName ] ) {
			// Get index of the first cached search panel field's div
			// The object property name is string so It's need converting to int number
			ind = parseInt( ind, 10 );
			if ( !this.isFieldShownById( filterName, ind ) ) {
				// get max not shown index
				cachedInd = ind;
				break;
			}
		}
		// no cached ctrls, only already shown
		if ( cachedInd === undefined ) {
			return false;
		}
		
		// index of last cached ctrl for this field
		cachedCtrlIndArr = this.ctrlsShowMap[ filterName ][ cachedInd ];

		// get ctrl
		firstCtrlFromCache = Runner.controls.ControlManager.getAt( this.tName, cachedInd, filterName, cachedCtrlIndArr[0] );
		firstCtrlFromCache.cached = false;
		
		// show ctrl
		if ( !firstCtrlFromCache.hidden ) {
			firstCtrlFromCache.show();
		}

		// set dependeces between child and parent if these links could be
		this.setDependences( firstCtrlFromCache, true );
		// place ctrl depend on it's type: lookup or simple
		this.putCachedBlock( filterName, cachedInd, firstCtrlFromCache.parentFieldName );
		
		// show type combo, if it shown in others ctrl
		if ( this.ctrlTypeComboStatus ) {
			$( "#" + this.getComboContId(filterName, cachedInd) ).show();
		}

		// set focus to added ctrl, turned off in window mode, because it cause bad visual effects in bottom control in window mode
		if ( !this.srchWinShowStatus && !Runner.isMobile ) {
			firstCtrlFromCache.setFocus();
		}		
		
		return true;
	},
	
	/**
	 * Adds filter to panel or window, and loads another one for cache
	 * @param {string} filterName
	 * @param {function} callback user function
	 */
	addFilter: function( filterName, userCallBack ) {		
		var isShown = this.showCached( filterName ),
			controller = this,
			$loadBox, ajaxParams;
			
		if ( !isShown ) { //the contol isn't shown on the Search Panel
			$loadBox = this.createLoadingBox( filterName );
			this.putLoadingBox( $loadBox, filterName );
		} else {
			this.toggleSearchControlsOptionsCombo( this.ctrlTypeComboStatus );
		}
		
		ajaxParams = {
			isNeedSettings: this.isTableSearchable() ? !Runner.pages.PageSettings.checkSettings( this.tName, filterName, this.pageType ) : true,
			searchControllerId: this.id,
			mode: "inlineLoadCtrl",
			ctrlField: filterName,
			id: Runner.genId()
		};
		
		Runner.runnerAJAX( this.ajaxSearchUrl, ajaxParams, function( ctrlJSON, queryStatus ) {
			var i, ctrl, ind, sFInd;
			
			// register new ctrl block
			controller.addRegCtrlsBlock( filterName, ctrlJSON.divInd, (ctrlJSON.control2 ? [0, 1] : [0]), ctrlJSON );
			
			if ( ajaxParams.isNeedSettings ) {
				Runner.pages.PageSettings.addSettings( controller.searchTableName, ctrlJSON.settings );
			}
			
			for (i = 0; i < ctrlJSON.ctrlMap.length; i++) {
				//replacing the config's "table" property with the current table name guarantees the correct control saving for the non table's page Search panel
				ctrlJSON.ctrlMap[i].table = controller.tName;
				ctrlJSON.ctrlMap[i].cached = isShown;
				ctrl = Runner.controls.ControlFabric( ctrlJSON.ctrlMap[i], controller.pageType );
	
				//init SearchSuggest, set dependencies and add disablings/enabling Search button handlers for a required field
				controller.initSearchField( ctrl );
			}
			
			if ( !isShown ) { 
				//the contol wasn't cached before and It isn't shown on the Search Panel
				controller.showCached( filterName );
				
				$loadBox.remove();
				controller.toggleSearchButtonsState( controller.getVisibleBlocksCount() );
				// because ajax ctrl will shown with delay
				controller.toggleSearchControlsOptionsCombo( controller.ctrlTypeComboStatus );
				//controller.addSearchField( filterName, ctrlJSON.divInd );
			}
			$(".srchPanelCell2").show();
			
			//if the filterName loaded is shown on the Search panel, it has been alredy added to SearchController's searchFields in initSearchField
			if ( !controller.isFieldShownById( filterName, ctrlJSON.divInd ) ) {
				//the just loaded filterName is cashed and isn't show on the Search panel
				ind = controller.getLastAddedInd( filterName );
				//add the filterName search field's object that have just appeared to SearchController's searchFields 
				controller.addSearchField( filterName, ind );
			}
			
			if ( typeof userCallBack === 'function' ) {
				sFInd = controller.searchFields[ filterName ].length - 1;
				userCallBack( controller.searchFields[ filterName ][ sFInd ] );
			}
			
			if ( controller.win )	{
				controller.win.fire("searchFieldsNumberChanged");
			}			
		});
	},
	
	addFilterInNumber: function(filterName, number, userCallBack) {
		for (var i = 0; i < number; i++) {
			this.addFilter(filterName, userCallBack);
		}
	},
	
	isFieldShownById: function(fName, id) {
		var fieldId = this.getFilterRowId(fName, id);
		return $("#" + fieldId).is(":visible");
	},
	
	/**
	 * Delete controls objects add the corresponding html-markup from DOM
	 * @param {string} fName
	 * @param {int} ind
	 */
	delCtrl: function( fName, ctrlId ) {
		var ctrlsShowMap = this.ctrlsShowMap[ fName ][ ctrlId ],
			ctrl, i;
		
		// ureg ctrls, loop will delete also second ctrl, if it was created
		for (i = 0; i < ctrlsShowMap.length; i++) {
			ctrl = Runner.controls.ControlManager.getAt( this.tName, ctrlId, fName, ctrlsShowMap[i] );
			// for lookup ctrls, clear links from children and trigger reload them with all values
			if ( ctrl.isLookupWizard ) {
				ctrl.clearChildrenLinks( true );
			}
			Runner.controls.ControlManager.unregister( this.tName, ctrlId, fName, ctrlsShowMap[i] );
		}
		
		// remove element from dom
		this.removeComboById( this.getComboContId(fName, ctrlId) );
		this.removeFilterById( this.getFilterRowId(fName, ctrlId) );
		if ( this.win ) {
			this.win.fire("searchFieldsNumberChanged");
		}
		
		// call crit controller
		this.toggleSearchButtonsState( this.getVisibleBlocksCount() );
		// remove from ctrl show map
		delete this.ctrlsShowMap[ fName ][ ctrlId ];
		if ( this.useSuggest ) {
			DestroySuggestDiv();
		}
		
		//remove the corresponding search Field
		for (i = 0; i < this.searchFields[ fName ].length; i++) {
			if ( parseInt( this.searchFields[ fName ][i].id, 10 ) === ctrlId ) {
				this.searchFields[ fName ].splice(i, 1);
				break;
			}
		}
		
		this.toggleSearhButtonStatus();
	},
	
	/**
	 * Deletes filter by id, removes from array and DOM element
	 * @param {string} id
	 */
	removeFilterById: function( id ) {
		var controller = this;
		$.each( this.srchFilterRowArr, function( idx, $elem ) {
			if ( $elem.attr('id') === id ) {
				$elem.remove();
				controller.srchFilterRowArr.splice( idx, 1 );
				return false;
			}
		});
	},
	
	/**
	 * Deletes combo cont by id from, removes from array and DOM element
	 * @param {string} id
	 */
	removeComboById: function( id ) {
		var controller = this;
		$.each( this.searchTypeCombosArr, function( idx, $elem ) {
			if ( $elem.attr('id') == id ) {
				controller.searchTypeCombosArr.splice( idx, 1 );
				return false;
			}
		});
	},
	
	/**
	 * Get number of visible ctrls blocks
	 * @return {number}
	 */
	getVisibleBlocksCount: function() {
		var visCount = 0,
			// use tr arr if window mode, or div arr if panel
			rowArr = this.srchFilterRowArr,
			i;
			
		// loop through all filters to get which are visible
		for (i = 0; i < rowArr.length; i++) {
			//check on 'display' stype property, because the element
			//could have the visibility prop set to hidden 
			if ( rowArr[i].css('display') !== 'none' ) {
				visCount++;
			}
		}
		return visCount;
	},
	
	/**
	 * Resets form ctrls, for panel
	 * @return {Boolean}
	 */
	resetCtrls: function() {
		var objIndForCM, fName, ind, i, ctrl;
		
		for (fName in this.ctrlsShowMap) {
			for (ind in this.ctrlsShowMap[fName]) {
				for (i = 0; i < this.ctrlsShowMap[fName][ind].length; i++) {
					// index of object that stored in CM
					objIndForCM = this.ctrlsShowMap[fName][ind][i];
					// delete each object
					ctrl = Runner.controls.ControlManager.getAt(this.tName, this.id, fName, objIndForCM);
					ctrl.reset();
				}
			}
		}
		return false;
	},
	
	/**
	 * Save to document.cookie the open Search panel's controls,
	 * the search panel state ('open'/'closed'/'unpinned') 
	 * and the Search panel popup window's position and size
	 */
	rememberSearchPanelState: function() {	
		var cookieRoot = Runner.getCookieRoot(),
			searchPanelCookie = get_cookie('searchPanel'),
			panelStateObj = {
				srchPanelOpen: this.srchOptShowStatus, 
				srchCtrlComboOpen: this.ctrlTypeComboStatus, 
				srchWinOpen: this.srchWinShowStatus, 
				openFilters: []
			},
			searchPanel = {},
			widgetBox;
			
		if (this.srchWinShowStatus) {
			//sinc the current window position and the 'x', 'y' attributes' values
			this.win.syncXY();
			
			widgetBox = $( this.win.get('boundingBox').getDOMNode() );
			panelStateObj.winState = {
				x: this.win.get("x"),
				y: this.win.get("y"),
				h: widgetBox.height(),
				// Runner.pages.PageManager.correctYUIWindowSize added extra 18px
				w: widgetBox.width() - 18
			};
		}
		
		if (!this.usedSrch) {
			panelStateObj.openFilters = this.getShownFilterNames();
		}
		
		if (searchPanelCookie) {
			searchPanel = JSON.parse(searchPanelCookie);
		}
		searchPanel['panelState_' + this.shortTName +'_' + this.id] = panelStateObj;		
		set_cookie('searchPanel', JSON.stringify(searchPanel), '', cookieRoot);
	},
	
	/**
	 * Get form document.cookie the search panel state ('open'/'closed'/'unpinned')
	 * and the Search panel's popup window params (if the Search panel is unpinned)
	 * Adjust the Search panel in accordance with the obtained data
	 */
	remindSearchPanelState: function() {
		var panelStateString = get_cookie('searchPanel'),
			panelStateObj, searchPanel;
		
		if ( panelStateString ) {
			searchPanel = JSON.parse(panelStateString);
			panelStateObj = searchPanel['panelState_' + this.shortTName + '_' + this.id];
		}
		if ( !panelStateObj ) {
			if (this.panelSearchFields.length) {
				this.showSearchOptions();
			}		
			return;
		}
		
		if ( panelStateObj.srchWinOpen && this.isWinStateCorrect(panelStateObj.winState) ) {
			this.hideSearchOptions();
			this.showSearchWin(panelStateObj.winState);
			
		} else if (panelStateObj.srchPanelOpen) {
			this.showSearchOptions();
		}
		
		if (panelStateObj.srchCtrlComboOpen) {
			this.showCtrlTypeCombo();
			return;	
		} 
		
		this.hideCtrlTypeCombo();
	},
	
	/**
	 * Check if the popup windows param are correct or not
	 * @param {object} winState
	 * @return {boolean}
	 */
	isWinStateCorrect: function( winState ) {
		if (!winState || winState.x === undefined || winState.y === undefined || !winState.w || !winState.h) {
			return false;
		}
		return true;
	},
	
	getFieldIds: function(fName, disp) {
		var idsArr = [], id;
		
		if (this.ctrlsShowMap[fName]) {
			for ( id in this.ctrlsShowMap[fName] ) {
				if ( disp !== true || this.isFieldShownById(fName, id) ) {
					idsArr.push(id);
				}
			}		
		}
		return idsArr;
	},
	
	/**
	 * Get list of search panel fields
	 * User function
	 * @return {array}
	 */
	getSearchFields: function(fName) {
		var allFields, i, j, fName;
		
		if (typeof fName !== 'undefined') {
			return this.searchFields[fName];
		}
		
		allFields = [];
		//traverse the array, containing searchable fields' names, backwards to get the search fields in the right order 
		for (i = this.fNamesArr.length; i--; ) {
			fName = this.fNamesArr[i];
			
			for (j = 0; j < this.searchFields[fName].length; j++) {
				allFields.push( this.searchFields[fName][j] );
			}
		}
		return allFields;
	},
	
	/**
	 * Add field to search filter
	 * User function
	 * @param {string}
	 * @param {function} user callback
	 */
	addField: function(fName, callback) {
		if ( !fName ) {
			return;
		}
		this.addFilter(fName, callback);
	},
	
	/**
	 * Delete field from search filter
	 * User function
	 * @param {string}
	 * @param {integer}
	 */
	deleteField: function(fName, id) {
		if ( !fName ) {
			return;
		}

		if (typeof id !== 'undefined') {
			//delete only field with current id
			this.delCtrl(fName, id);
			return; 
		}
		
		//delete all fields with name like fName from search panel		
		var ids = this.getFieldIds(fName, true);
		for (var i = 0; i < ids.length; i++) {
			this.delCtrl(fName, ids[i]);
		}
		this.searchFields[fName] = [];
	},
	
	/**
	 * Clear search panel
	 * User function
	 */
	clear: function() {
		var shownFields = this.getShownFilterNames();
		
		for (var i = 0; i < shownFields.length; i++) {
			this.deleteField( shownFields[i] );
		}
	},
	
	/**
	 * Display search panel
	 * User function
	 * @param {string}
	 */
	display: function(as) {
		switch (as) {
			case "show":
				if (!this.srchWinShowStatus) {
					this.showSearchOptions();
				} else {
					this.hideSearchWin();
				}
				break;
			case "hide":
				if (this.srchWinShowStatus) {
					this.hideSearchWin();
				}
				this.hideSearchOptions();
				break;
			case "popup":
				this.showSearchWin();
				break;
		}
	}, 	
	
	/**
	 * Toggle options
	 * User function
	 */
	toggleOptions: function(as) {
		switch (as) {
			case "show":
				this.showCtrlTypeCombo();
				break;
			case "hide":
				this.hideCtrlTypeCombo();
				break;
		}
	},
	
	/**
	 * Toggle criteria
	 * User function
	 * @param {string}
	 */
	toggleCriteria: function(as) {
		switch (as) {
			case "all":
				$('#all_checkbox', this.pageObj.pageCont).prop('checked', true);
				break;
			case "any":
				$('#any_checkbox', this.pageObj.pageCont).prop('checked', true);
				break;
			case "show":
				this.topCritCont.show();
				break;
			case "hide":
				this.topCritCont.hide();
				break;
		}
	},
	
	/**
	 * Get a search option for a inflexible Search panel's field
	 * @param {String} fName	
	 */
	getInflexSearchOption: function( fName ) {
		return this.inflexSearchOptions[ fName ];
	},

	/**
	 * Reset all the Search panel settings to default
	 */
	clearSearchPanel: function() {
		var fName, i, fSearchFields,
			defaultOption;
	
		for (fName in this.searchFields) {
			fSearchFields = this.searchFields[fName];
			defaultOption = this.isSearchPanelInflexible ? this.getInflexSearchOption(fName) : Runner.lang.constants.CONTAINS;
	 
			for (i = 0; i < fSearchFields.length; i++) {
				fSearchFields[i].clearFieldCtrls();
				fSearchFields[i].setOption(defaultOption);
			}
		}

		this.toggleCriteria("all");	
	},
	
	/**
	 * Clear Simple search and Simple panel without the page reloading
	 */
	clearSearch: function() {
		this.clearSearchPanel();
		this.clearSimpleSearch();	
	},
	
	/**
	 * Init Search Suggest, add search field's object to the SearchFields,
	 * set disablings/enabling Search button handlers for a required field,
	 * set dependencies for a dependent lookup
	 * @param {Object} ctrl
	 */	
	initSearchField: function(ctrl) {
		if ( !ctrl ) {
			return;
		}
		
		//borrow the Runner.search.SearchForm initSearchField method
		Runner.search.SearchController.superclass.initSearchField.call(this, ctrl);
		this.setDependences(ctrl);	
	},

	/**
	 * Checks if the search panel is set on the table's page or not
	 * @return {boolean}
	 */	
	isTableSearchable: function() {
		return this.tName === this.searchTableName;
	},

	/**
	 * Init the filter panel
	 */
	initFilters: function() {
		this.initFilterControls();
		this.adjustExpanderSigns();

		this.updateFilterPanelVisibility();	
	},
	
	/**
	 * Create all filter controls and store them in filterControls array
	 */
	initFilterControls: function() {
		var i, filterControl;
	
		this.filterControls = [];
	
		for (i = 0; i < this.filterContolsData.length; i++) {
			filterControl = Runner.controls.FilterControlFabric(this.filterContolsData[i], this);
			if ( filterControl ) { 
				this.filterControls.push( filterControl );
			}		
		}
	},
	
	/**
	 * Hide the Filter panel if there are no visible filters
	 */
	updateFilterPanelVisibility: function() {
		var hidePanel = true, i;
		
		for (i = 0; i < this.filterControls.length; i++) {
			if ( this.filterControls[i].isVisible() ) {
				hidePanel = false;
				break;
			}
		}
		
		if ( hidePanel ) {
			this.pageObj.hideBrick("filterpanel");
		}
	},
	
	/**
	 * Save in document.cookie the filters' states (expanded/collapsed)
	 */
	rememberFilterPanelState: function() {
		if ( !this.filterControls.length ) {
			return;
		}
		
		var cookieRoot = Runner.getCookieRoot(),
			stateId = 'filtersState_' + this.shortTName + '_' + this.id,
			filterPanelCookie = get_cookie('filterPanel'),
			oldFiltersState = {},
			filtersState = {},
			filterPanel = {},
			filter, i;			

		if (filterPanelCookie) {
			filterPanel = JSON.parse( filterPanelCookie );
			oldFiltersState = filterPanel[ stateId ] || {};
		}
			
		for (i = 0; i < this.filterControls.length; i++) {
			filter = this.filterControls[i];
			filtersState[ filter.fieldName ] = filter.isVisible() ? filter.isCollapsed() : oldFiltersState[ filter.fieldName ];
		}
			
		filterPanel[ stateId ] = filtersState;
		set_cookie('filterPanel', JSON.stringify( filterPanel ), '', cookieRoot);
	},
	
	/**
	 * Adjust the filtes' expander signs basing on the document.coockie data
	 */	
	adjustExpanderSigns: function() {
		if ( !this.filterControls.length ) {
			return;
		}
		
		var filtersStateString = get_cookie('filterPanel'),
			filterPanel, filtersStateObj, filter, i, isCollapsed;
		
		if ( !filtersStateString ) {
			return;
		}
	
		filterPanel = JSON.parse( filtersStateString );
		filtersStateObj = filterPanel['filtersState_' + this.shortTName +'_' + this.id];
		
		if ( !filtersStateObj ) {
			return;
		}
			
		for (i = 0; i < this.filterControls.length; i++) {
			filter = this.filterControls[i];
			isCollapsed = filtersStateObj[ filter.fieldName ];
			filter.adjustExpander( isCollapsed );
		}
	},
	
	/**
	 * Update some filters controls' values basing on data passed
	 * @param {object} parentFiltersData	The object's keys are parent filters' names,
	 * the object's values are the corresponding filters' values 
	 */
	updateParentFilters: function( parentFiltersData ) {
		var i, filter, filterValue;
		
		for (i = 0; i < this.filterControls.length; i++) {
			filter = this.filterControls[i];
			filterValue = parentFiltersData[ filter.fieldName ];
			
			if ( filterValue !== undefined ) {
				filter.updateValue( filterValue );
			}			
		}
	},	
	
	/**
	 * Clear controls' values for paticular filters
	 * @param {array} dependentFiltersNames		The array of filters controls names
	 * @param {boolean} notMultiSelected
	 */	
	clearDependentFilters: function( dependentFiltersNames, notMultiSelected ) {
		var i, filter;
		
		for (i = 0; i < this.filterControls.length; i++) {
			filter = this.filterControls[i];
			
			if ( filter.isDependent() && $.inArray( filter.fieldName, dependentFiltersNames) !== -1 && ( !notMultiSelected || !filter.isMultiSelected() ) ) {
				filter.clearControl(); 
			}
		}
	},
	
	/**
	 * Check if there is filtered one among the filters with the names passed
	 * @param {array} parentFiltersNames
	 * return boolean
	 */
	hasFilteredParentFilter: function( parentFiltersNames ) {
		var i, filter;
		for (i = 0; i < this.filterControls.length; i++) {
			filter = this.filterControls[i];
			if ( $.inArray( filter.fieldName, parentFiltersNames) !== -1 && filter.filtered ) {
				return true;
			}
		}
		
		return false;	
	}	
});

/**
 * The SearchParamsLogger class provides the base search saving functionality.
 * Instances are strongly connected with the page's Search controller and
 * invoke its methods through the proxy searchControllerConnector
 * object without spoiling its state.
 */
Runner.search.SearchParamsLogger = Runner.extend( Runner.emptyFn, {
	/**
	 * The object that stores the saved searches' names
	 * and the corresponding search params data
	 */
	savedSearches: {},
	
	/**
	 * The jQuery element representing
	 * the 'Save search' button	
	 * @type {jQeury object}
	 */
	saveSearchButton: null,
	
	/**
	 * The jQuery element representing
	 * the 'Saved searches' button	
	 * @type {jQeury object}
	 */	
	savedSearchesButton: null,
	
	/**
	 * The proxy instance to provide a particular Search 
	 * controller object functionality without spoiling
	 * the page's search controller state
	 * @type {Object}
	 */
	searchControllerConnector: null,
	
	/**
	 * The page's id value
	 */
	id: -1,	
	
	/**
	 * The page's table name
	 */
	tName: "",
	
	/**	
	 * The page's type
	 */
	pageType: "",

	/**
	 * The name of the  Saved search link class
	 */
	savedSeachLinkClass: "savedSearch",
	
	/**
	 * The name of Delete saved search button 	
	 */
	deleteSearchBtnClass: "deleteSearch",
	
	
	constructor: function( cfg ) {
		Runner.apply( this, cfg );
	},
	
	/**
	 * The method returns the reference to itself
	 * to provide an instance with lazy init syntax	 
	 * @return {Object}
	 */
	init: function( searchController ) {
		this.initSearchControllerConntector( searchController );
		this.initSearchSavingButtons();
		this.initSavedSearchesList();
		
		return this;
	},

	/**
	 * Create the searchControllerConnector instance to provide a particular Search 
	 * controller object functionality without spoiling the page's search controller state.
	 * The Lazy Function Definition is used to prevent the connector creating code from
	 * being invoked more than once.
	 *
	 * @param {Object} searchController		The page's Search controller obejct reference
	 */
	initSearchControllerConntector: function( searchController ) {
		// define a search controller proxy object constructor
		var Connector = function() {
			/** 
			 * Get the search controller property value
			 * @param {String} propertyName
			 * @return {Mixed}
			 */
			this.getProperty = function( propertyName ) {
				return searchController[ propertyName ];
			}
			/** 
			 * Submit the saved search through the search controller 
			 * @param {Object}
			 */
			this.submitSavedSearch = function( searchParams ) {
				searchController.submitSavedSearch( searchParams );
			}
			/**
			 * Get a sting value of the first controller involved in the current search
			 * @return {String}
			 */
			this.getTheFirstSearchControlValue = function() {
				return searchController.getTheFirstSearchControlValue();
			}
		}
		
		this.searchControllerConnector = new Connector();
		this.initSearchControllerConntector = Runner.emptyFn;
	},	
	
	/**
	 * Init the 'Search saving' buttons
	 */
	initSearchSavingButtons: function() {
		var logger = this;
		
		// add click handler for the 'Search save' button
		this.saveSearchButton = $( "a#saveSearch" + this.id ).on("click", function(e) {
			if ( !Runner.isDisabledButton( this ) ) {
				Runner.addDisabledClass( this );
				logger.saveSearchClickHandler(e);	
			}			
			return false;
		});
		
		this.savedSearchesButton = $( "a#savedSearches" + this.id )
			.on("click", function(e) {
				return false;
			});
	},	

	/**
	 * The 'Save search' button's jQuery click handler
	 * @param {jQeury Event object}
	 */	 
	saveSearchClickHandler: function(e) {
		if ( !e ) { 
			return;
		}
		
		var logger = this,
			searchNameId = "searchName" + this.id,
			searchName = this.getDefaultSearchName(), 
			args = {
				modal: true,
				centered: true,
				headerContent: Runner.lang.constants.TEXT_SEARCH_SAVING,
				bodyContent: this.getSaveSearchDialogContent( searchName, searchNameId )
			};
			
		Runner.pages.PageManager.createFlyWin( args, false, function( win ) {
			var Y = Runner.Y;
			
			win.bodyNode.setStyle("textAlign", "center");
			
			win.addButton({ 
				label : Runner.lang.constants.TEXT_SAVE,
				name : "saveButton", // getter : win.getButton("saveButton")
				template: "<a />",
				classNames : "rnr-button main",
				section: Y.WidgetStdMod.BODY,
				action : function(e) {
					var bodyDomNode = win.bodyNode.getDOMNode(),
						searchName = Y.DOM.byId( searchNameId, bodyDomNode ).value;
						
					e.preventDefault();				
					logger.saveSearch( searchName );
					win.destroy( true );
				}
			}); 

			win.addButton({
				label : Runner.lang.constants.TEXT_CANCEL,
				template: "<a />",
				classNames : "rnr-button",
				section: Y.WidgetStdMod.BODY,
				action : function(e) {
					e.preventDefault();
					win.destroy( true );
				}
			});
			
			win.on('destroy', function() {
				Runner.delDisabledClass( logger.saveSearchButton );
			});
			
			Runner.pages.PageManager.correctYUIWindowSize( win, true );
		});
	},	

	/**
	 * Save the current search under a particular name
	 * @param {String} searchName
	 */
	saveSearch: function( searchName ) {		
		var	logger = this,
			ajaxURL = Runner.pages.getUrl( this.tName, this.pageType ),
			ajaxParams = {
				saveSearch: true,
				searchName:	searchName
			};
			
		Runner.runnerAJAX( ajaxURL, ajaxParams, function( params ) {
			if ( !logger.savedSearches[ searchName ] ) {
				logger.addSearchToSavedSearchesList( searchName );
			}
			logger.savedSearches[ searchName ] = params
			logger.savedSearchesButton.show();
		});
		
		this.saveSearchButton.remove();		
	},
	
	/**
	 * Get the unique name for the saving search
	 * @return {String}
	 */
	getDefaultSearchName: function() {
		var searchName = this.searchControllerConnector.getTheFirstSearchControlValue(),
			re = /(.+_)(\d+)$/,
			matches; 
		
		while ( this.savedSearches[ searchName ] ) {
			matches = re.exec( searchName );
			
			if ( matches ) {
				searchName = matches[1] + ( parseInt( matches[2], 10 ) + 1 );
			} else {
				searchName += '_1'; 
			}
		}
		
		return searchName;
	},

	/**
	 * Get the Search save dialog html markup
	 * @param {String} searchName
	 * @param {String} searchNameId
	 * @return {String} markup
	 */
	getSaveSearchDialogContent: function( searchName, searchNameId ) {
		return '<div class="rnr-searchname">'
				+ '<label for="searchName">' + Runner.lang.constants.TEXT_SEARCH_NAME + '&nbsp</label>'
				+ '<input id="' + searchNameId + '" type="text" value="' + searchName + '" name="searchName">'
			+ '</div>';
	},
	
	/** 
	 * Create the saved searches list's markup
	 */	 
	initSavedSearchesList: function() {
		var searchName,
			logger = this;
			
		this.savedSearchesList = $('<ul id="savedSearchedList' + this.id + '" class="rnr-list"></ul>')
			.addClass('rnr-saved-searches');
			
		
		for ( searchName in this.savedSearches ) {
			if ( this.savedSearches.hasOwnProperty( searchName ) ) {
				this.addSearchToSavedSearchesList( searchName );
			}
		}
		
		this.savedSearchesList.insertAfter( this.savedSearchesButton )
			.on('click', '.' + this.savedSeachLinkClass, function(e) {
				var searchName = $(this).parent('li').data('search'),
					searchParams = logger.savedSearches[ searchName ];
				
				logger.searchControllerConnector.submitSavedSearch( searchParams ); 
				return false;
			})
			.on('click', '.' + this.deleteSearchBtnClass, function() {
				var deleteSearch = $(this),
					searchName;
					
				if ( deleteSearch.hasClass('disabled') ) {
					return;
				}				
				
				searchName = deleteSearch.parent('li').data('search');
				logger.deleteSavedSearch( searchName );
				deleteSearch.addClass('disabled');
				return false;
			});
			
		Runner.setZindexMaxToElem( this.savedSearchesList );	
	},
	
	/** 
	 * Get the saves searches list item's markup
	 * @param {String} searchName
	 */ 
	addSearchToSavedSearchesList: function( searchName ) {
		var item = $('<li></li>')
				.data('search', searchName)
				.appendTo( this.savedSearchesList );
			
		$('<a data-icon="remove" href="#"></a>')
			// safari + ios fix
			.on("touchend", function() { 
				$(this).trigger("click")
			})
			.addClass( this.deleteSearchBtnClass )	
			.appendTo( item );
		
		$('<a href="#"></a>')
			// safari + ios fix
			.on("touchend", function() { 
				$(this).trigger("click")
			})		
			.addClass( this.savedSeachLinkClass )
			.html( searchName )
			.appendTo( item );	
	},
	
	/**
	 * Delete a saved search with a particular name
	 * @param {String} searchName
	 */
	deleteSavedSearch: function( searchName ) {	
		if ( !this.savedSearches[ searchName ] ) {
			return;
		}
		
		var	logger = this,
			args = {
				modal: true,
				centered: true,
				headerContent: Runner.lang.constants.TEXT_DELETE_SEARCH_CAPTION,
				bodyContent: this.getDeleteSearchDialogContent()
			};

		Runner.pages.PageManager.createFlyWin( args, false, function( win ) {
			var Y = Runner.Y;
			
			win.bodyNode.setStyle("textAlign", "center");
			
			win.addButton({ 
				label : Runner.lang.constants.TEXT_YES,
				name : "yesButton", // getter : win.getButton("yesButton")
				template: "<a />",
				classNames : "rnr-button main",
				section: Y.WidgetStdMod.BODY,
				action : function(e) {						
					e.preventDefault();				
					
					var ajaxURL = Runner.pages.getUrl( logger.tName, logger.pageType ),
						ajaxParams = {
							deleteSearch: true,
							searchName:	searchName
						};
						
					Runner.runnerAJAX( ajaxURL, ajaxParams );	
					
					logger.removeSavedSearchesListItem( searchName );
					delete logger.savedSearches[ searchName ];
					if ( $.isEmptyObject( logger.savedSearches ) ) {
						logger.savedSearchesButton.hide();
					}
					win.destroy( true );	
				}
			}); 

			win.addButton({
				label : Runner.lang.constants.TEXT_NO,
				template: "<a />",
				classNames : "rnr-button",
				section: Y.WidgetStdMod.BODY,
				action : function(e) {
					e.preventDefault();
					win.destroy( true );
				}
			});
			
			win.on('destroy', function() {
				logger.getSavedSearchesListItem( searchName )
					.children('.' + logger.deleteSearchBtnClass)
				.removeClass('disabled');
			});
			
			Runner.pages.PageManager.correctYUIWindowSize( win, true );
		});		
	},
	
	/**
	 * Get the Delete saved search dialog html markup
	 * @return {String} markup
	 */	
	getDeleteSearchDialogContent: function() {
		return '<div class="rnr-delete-search">'
					+ Runner.lang.constants.TEXT_DELETE_SEARCH
			+ '</div>';
	},
	
	/**
	 * Remove the saved searches list's item with a particular search name
	 * @param {String} searchName
	 */
	removeSavedSearchesListItem: function( searchName ) {
		 this.getSavedSearchesListItem( searchName ).remove();
	},
	
	/**
	 * Get the saved searches list's item by its search name
	 * @param {String} searchName
	 * @return {jQuery object}
	 */
	getSavedSearchesListItem: function( searchName ) {
		return $('li', this.savedSearchesList).filter( function() {
					return $(this).data('search') === searchName;
				});
	}
});
// create namespace
Runner.namespace('Runner.form');

Runner.form.BasicForm = Runner.extend( Runner.util.Observable, {
	
	id: -1,

	/**
	 * @type {object}
	 */
	baseParams: null,	
	
	isFileUpload: false,
	
	/**
	 * A flag indicating if to submit a form element
	 * without using iframe
	 * @type {boolean}
	 */
	standardSubmit: false,
	
	/**
	 * @type {object}
	 */
	ajaxForm: null,
	
	/**
	 * @type {object}
	 */	
	searchForm: null,
	
	isSearchForm: false,

	searchSubmit: false,
	
	/**
	 * An array objects created with Runner.controls.ControlFabric method
	 * @type {array}
	 */
	fieldControls: null,
	
	/**
	 * An array of DOM element (or jQuery object)
	 * that will be added to the form element
	 * @ytpe {array}
	 */
	addElems: null,
	
	/**
	 * The form element	
	 * @type {jQuery object}
	 */
	formEl: null,

	/**
	 * The form's iframe io element	
	 * @type {jQuery object}
	 */
	ioEl: null,
	
	/**
	 * The form's iframe id
	 * @type {string}
	 */
	ioElId: '',
	
	/**
	 * The request URL
	 * @type {string}
	 */
	submitUrl: '',
	
	/**
	 * The form method attribute value
	 * @type {string}
	 */
	method: 'POST',
	
	/**
	 * The form element's target attribute value
	 * @type {string}
	 */
	target: '',	
	
	/**
	 * A flag indicating if to add to request url
	 * a random value param to prevent caching
	 * @type {boolean}
	 */
	addRndVal: true,
	
	/**
	 * A flag indicating if to add 'enctype' attribute 
	 * with 'multipart/form-data' value to the form
	 * @type {boolean}
	 */
	useMultipart: false,
	
	/**
	 * A flag indicating if to destroy the form and iframe elements
	 * and unregister fields controls after submit
	 * @type {boolean}
	 */
	deleteAfterSubmit: false,
	
	/**
	 * @type {boolean}
	 */
	initImmediately: false,
	
	/**
	 * @type {boolean}
	 */
	isFormReady: false,	
	
	/**
	 * Set focus on the first invalid control or not
	 * Need for Save All inline Add/Edit grid's records
	 * @type {boolean}
	 */
	setFocus: true,
	
	/**
	 * @constructor
	 */
	constructor: function( cfg ) {
		this.addElems = [];
		this.ajaxForm = {};
		this.baseParams = {};
		this.fieldControls = [];

		Runner.apply(this, cfg);
		
		this.addEvents('beforeSubmit', 'successSubmit', 'submitFailed', 'validationFailed');			
		
		if ( this.beforeSubmit ) {
			this.on( {'beforeSubmit': this.beforeSubmit} );
		}
		
		if ( this.successSubmit ) {
			this.on( {'successSubmit': this.successSubmit} );
		}
		
		if ( this.submitFailed ) {
			this.on( {'submitFailed': this.submitFailed} );
		}
		
		if ( this.validationFailed ) {
			this.on( {'validationFailed': this.validationFailed} );
		}
		
		Runner.form.BasicForm.superclass.constructor.call( this, cfg );
		
		if ( this.initImmediately ) {
			this.initForm();
		}
	},
	
	/**
	 * Destroy the form element
	 * @param {boolean} destroyControls
	 */
	destructor: function( destroyControls ) {
		if ( destroyControls === true ) {
			for (var i = 0; i < this.fieldControls.length; i++) {
				this.fieldControls[i].unregister();
			}
		}
		
		if ( this.ioEl && this.ioEl.length ) {
			var $iframe = this.ioEl;
			setTimeout( function() {
				$iframe.remove();
			}, 0);
		}
		
		if ( this.formEl && this.formEl.length ) {
			this.formEl.remove();
		}
	},
	
	/**
	 * Submit the form
	 * @return {boolean}
	 */
	submit: function() {
		this.triedToSubmit = true;
		
		var beforeSubmitRes = this.fireEvent('beforeSubmit', this),
			formObj = this;
		
		if ( beforeSubmitRes === false || !this.validate() ) {
			return false;
		}
		
		if ( this.isFileUpload || this.standardSubmit ) {
			if (this.searchSubmit && Runner.charSet == "utf-8") {
				var queryStr, i,
					queryParts = [],
					vars = {}, 
					paramsStr = window.location.href,
					paramNames = ['rname', 'cname'];
				
				$.each( this.searchForm, function( formParameter, parameterValue ) {
					queryParts.push( formParameter + '=' + parameterValue );
				});
				
				if ( paramsStr.substr(paramsStr.length - 1) == '#' ) {
					paramsStr = paramsStr.substr(0, paramsStr.length - 1);
				}	
				paramsStr.replace(/[?&]+([^=&]+)=([^&]*)/gi, function( m, key, value ) {
					vars[ key ] = value;
				});
				
				for (i = 0; i < paramNames.length; i++) {
					if ( vars[ paramNames[i] ] ) {
						queryParts.push( paramNames[i] + '=' + encodeURIComponent( vars[ paramNames[i] ] ) );
					}	
				}

				queryStr = queryParts.join('&');
				queryStr = this.submitUrl + ( queryStr ? '?' + queryStr : queryStr );
				
				if ( queryStr.length < 2040 ) {
					location.href = queryStr;
					return true;
				} 
				
				this.formEl.attr('method', 'POST');
			}
			
			this.initForm();
			this.addFormSubmit();
			this.formEl.submit();
		} else {
			this.addFormSubmit();

			Runner.runnerAJAX(this.submitUrl, this.ajaxForm, function( respObj ) {
				formObj.fireEvent("successSubmit", respObj, formObj, formObj.fieldControls);
			});
		}
		
		return true;
	},
	
	/**
	 * Initialize the form element
	 */
	initForm: function() {
		if ( this.isFormReady ) {
			return;
		}
		
		if ( this.isFileUpload && !this.standardSubmit ) {
			this.createIFrame();
			this.createForm();
		} else if ( this.standardSubmit ) {
			this.createForm();
		}
		
		this.isFormReady = true;
	},
	
	/**
	 * Clear the form element
	 */
	clearForm: function() {
		if ( this.formEl && this.formEl.length ) {
			this.formEl.children().remove();
		}
		this.ajaxForm = {};
		this.searchForm = {};
	},

	/**
	 * Add submited elements to the form
	 */	 
	addFormSubmit: function() {
		var arrClns, i, j, param;
		
		if ( this.isFormReady && !this.isSearchForm ) {
			this.clearForm();
		}
		
		if ( this.addRndVal ) {
			this.baseParams[ "rndVal" ] = Math.random();
		}
		
		if ( this.formEl && this.formEl.length ) {
			for (i = 0; i < this.fieldControls.length; i++) {
				arrClns = this.fieldControls[i].getForSubmit();
				
				for (j = 0; j < arrClns.length; j++) { 
					$( arrClns[j] ).appendTo( this.formEl );
				}
			}
			
			for (param in this.baseParams) {
				this.addToForm( param, this.baseParams[ param ] );
			}
			
			for (i = 0; i < this.addElems.length; i++) {
				$( this.addElems[i] ).appendTo( this.formEl );
			}
			return;
		} 
		
		this.ajaxForm = Runner.apply( this.ajaxForm, this.baseParams );
		
		for (i = 0; i < this.fieldControls.length; i++) {
			this.ajaxForm[ this.fieldControls[i].fieldName ] = this.fieldControls[i].getStringValue(); 
		}
		
		for (i = 0; i < this.addElems.length; i++) {
			$( this.addElems[i] ).appendTo( this.formEl );			
			this.addToForm( this.addElems[i].attr("id") || this.addElems[i].attr("name"), this.addElems[i].val() );
		}
	},
	
	/**
	 * Add param to form elements
	 * @param {string} id
	 * @param {string} val	 
	 */
	addToForm: function( id, val ) {
		if ( val === undefined || id === undefined || val === null || id === null ) {
			return;
		}
		
		if ( this.isFileUpload || this.standardSubmit ) {
			if ( !this.formEl ) { 
				this.initForm();
			}
			
			$('<input id="' + id + '" name="' + id + '" type="hidden"></input>')
				.val( val.toString() )
				.appendTo( this.formEl );

			if ( this.searchSubmit ) {
				this.ajaxForm[ id ] = val;
			}
		} else {
			this.ajaxForm[ id ] = val;
		}
	},
	
	/**
	 * Add param to the search form
	 * @param {string} id
	 * @param {string} val
	 */
	addToSearchForm: function( id, val ) {
		if ( val !== undefined && id !== undefined && val !== null & id !== null ) {
			this.searchForm[ id ] = val;
		}
	},
	
	/**
	 * Validate form controls
	 * @return {boolean}
	 */
	validate: function() {
		var invalidControls = Runner.pages.RunnerPage.prototype.getInvalidControls.call(this, this.fieldControls)
		
		if ( invalidControls.length ) {
			if ( this.setFocus ) {
				Runner.pages.RunnerPage.prototype.setFirstFocus.call(this, this.id, invalidControls);
			}
			
			this.fireEvent("validationFailed", this, this.fieldControls, invalidControls);
			return false;
		}	
		return true;
	},
	
	/**
	 * Create the form's iframe io element
	 */
	createIFrame: function() {
		if ( this.ioEl ) {
			return false;
		}
		var frameId = 'uploadFrame_' + this.id,
			basicForm = this,
			$iframe = $('<iframe id="' + frameId + '" name="' + frameId + '"/>')
				.css({
					border: '0', 
					height: '1px', 
					width: '1px',
					display: 'none'
				})
				.appendTo('body');
		
		$iframe.bind('load', function(e) {
			var bodyElem = $(this).contents().find('body').get(0),
				response, responseObj;
			
			if ( bodyElem.innerHTML !== '' ) {
				try {
					response = $('<div>' + bodyElem.innerHTML + '</div>').text();
					responseObj = JSON.parse(response);
				} catch(e) {
					// if response contain PHP error
					basicForm.fireEvent('submitFailed', bodyElem.innerHTML, basicForm, basicForm.fieldControls);
					if ( basicForm.deleteAfterSubmit ) {
						basicForm.destructor(true);
					}
					return;
				}
				
				basicForm.fireEvent('successSubmit', responseObj, basicForm, basicForm.fieldControls);
			} else {
				basicForm.fireEvent('submitFailed', null, basicForm, basicForm.fieldControls);
			}
			
			if ( basicForm.deleteAfterSubmit ) {
				basicForm.destructor(true);
			}
		});
		
		this.ioEl = $iframe;
		this.ioElId = frameId;	
	},
	
	/**
	 * Create the form element
	 */
	createForm: function() {
		if ( this.formEl ) {
			return false;
		}
		
		var $form =  $('<form/>')
			.attr({
				action: this.submitUrl,
				method: this.method
			})
			.css('display', 'none')
			.appendTo('body');
				
		if ( this.target ) {
			$form.attr('target', this.target);
		}
		if ( this.ioEl ) {
			$form.attr('target', this.ioElId);
		}
		
		if ( this.isFileUpload || this.useMultipart ) {
			$form.attr('enctype', 'multipart/form-data');
		}
		
		this.formEl = $form;			
	},
	
	/**
	 * Set all the Runner controls added to the form to the read-only state
	 */
	makeReadonly: function() {
		for (var i = 0; i < this.fieldControls.length; i++) {
			this.fieldControls[ i ].makeReadonly();
		}
	},
	
	/**
	 * Set all the Runner controls added to the form to the normal (no read-only) state
	 */
	makeReadWrite: function() {
		for (var i = 0; i < this.fieldControls.length; i++) {
			this.fieldControls[ i ].makeReadWrite();
		}
	}
});

/**
 * @param {string} submitUrl
 * @param {object} baseParams
 * @param {function} succesHandler
 */
Runner.runnerAJAX = function( submitUrl, baseParams, succesHandler ) {
	var basicForm = new Runner.form.BasicForm({
		id: Runner.genId(),	
		standardSubmit: false,
		isFileUpload: true,
		submitUrl: submitUrl,
		method: 'POST',
		baseParams: baseParams,
		deleteAfterSubmit: true,
		successSubmit: {
			fn: succesHandler,
			scope: window
		}
	});
	basicForm.submit();
	
	// could be rewritten as
	//Runner.submitRunnerFormInIframe( submitUrl, { baseParams: baseParams }, succesHandler ) ;
};


/**
 * @param {string} submitUrl
 * @param {object} cfgParams
 * @param {function} succesSubmitHandler
 * @param {function} submitFailedHandler
 * @return {Runner.form.BasicForm object}
 */
Runner.submitRunnerFormInIframe = function( submitUrl, cfgParams, succesSubmitHandler, submitFailedHandler ) {
	var basicForm,
		formParams = {
			method: 'POST',
			id: Runner.genId(),	
			standardSubmit: false,
			isFileUpload: true,
			submitUrl: submitUrl,
			deleteAfterSubmit: true
		};
	
	if ( cfgParams.baseParams && typeof cfgParams.baseParams === "object" ) {
		formParams.baseParams = cfgParams.baseParams
	}
	
	if ( Runner.isArray( cfgParams.addElems ) ) {
		formParams.addElems = cfgParams.addElems;
	}

	if ( typeof succesSubmitHandler === "function" ) {
		formParams.successSubmit = {
			fn: succesSubmitHandler,
			scope: window
		}
	}	
	
	if ( typeof submitFailedHandler === "function" ) {
		formParams.submitFailed = {
			fn: submitFailedHandler,
			scope: window			
		}
	}
	
	basicForm = new Runner.form.BasicForm( formParams );
	basicForm.submit();
}
// create namespace
Runner.namespace('Runner.util.details');

/**
 * Base abstract class for details preview
 * provides base functionality and event handling
 * @class Runner.util.details.DP
 */
Runner.util.details.DP = Runner.extend( Runner.util.Observable, {
	/**
	 * Detail data source table name
	 * @type {string}
	 */
	tName: "",
	/**
	 * Detail short table name
	 * @type {string}
	 */
	shortTName: "",
	/**
	 * Master data source table name
	 * @type {string}
	 */
	masterTName: "",
	/**
	 * Master short table name
	 * @type {string}
	 */
	masterShortTName: "",
	/**
	 * Ajax request url
	 * @type {string}
	 */
	ajaxRequestUrl: "",
	
	/**
	 * Detail page type
	 * @type {string}
	 */
	pageType: "",
	
	/**
	 * A property indicating how to display a detail page
	 * ('in popup', 'inline')
	 */
	dpShowType: Runner.pages.constants.DP_NONE,
	
	/**
	 * Detail page id
	 * @type {string}
	 */
	id: 0,
	
	/**
	 * Parent page id
	 * @type {string}
	 */
	parId: 1,
	
	/**
	 * The indicator showing if the layout 
	 * of a new or old version is used 
	 * @type {boolean}
	 */	
	oldLayout: false,
	
	/**
	 * The layout's main class prefix
	 * @type {string}
	 */	
	classBasePrefix: "",
	
	
	constructor: function( cfg ) {
		Runner.apply( this, cfg );
		Runner.util.details.DP.superclass.constructor.call( this, cfg );
		
		this.shortTName = Runner.pages.PageSettings.getShortTName( this.tName );
		this.masterShortTName = Runner.pages.PageSettings.getShortTName( this.masterTName );
		
		this.ajaxRequestUrl = Runner.getPageUrl( this.shortTName, this.pageType );
		this.classBasePrefix = this.oldLayout ? "runner-" : "rnr-"; 
	},
	
	init: Runner.emptyFn
});

/**
 * @class Runner.util.details.InlineDP
 * Provides base functionality for inline details
 */
Runner.util.details.InlineDP = Runner.extend( Runner.util.details.DP, {
	/**
	 * Current row object
	 * @type {array}
	 */
	rows: null,
	
	/**
	 * Main master page type
	 * For example:
	 * We have master page add with detail table1, which has detail table2
	 * For detail table2 main master page type will be add
	 * @type {string}
	 */
	mainMasterPageType: "",
	
	/**
	 * Records per row on list
	 * @type {integer}
	 */
	recsPerRowList: 1,
	
	/**
	 * Hide child link or not 
	 * @type {boolean}
	 */
	hideChild: false,
	
	/**
	 * A reference to the parent page's object
	 * @type {object}
	 */
	parPageObj: null,
	
	/**
	 * The host page's context
	 * @type {Mixed}
	 */
	pageContext: null,
	
	
	constructor: function( cfg ) {
		this.rows = [];
		this.dpShowType = Runner.pages.constants.DP_INLINE;
		
		Runner.util.details.InlineDP.superclass.constructor.call( this, cfg );
		this.addEvents("beforeShow", "afterShow");
		
		this.parPageObj = Runner.pages.PageManager.getById( this.parId );
		
		this.listGridLayout = Runner.pages.PageSettings.getTableData( this.masterTName, "listGridLayout" );
		this.recsPerRowList = Runner.pages.PageSettings.getTableData( this.masterTName, "recsPerRowList" );
	},
	
	init: function() {
		this.initRows();
		
		if ( this.parPageObj ) {
			this.mainMasterPageType = this.parPageObj.pageType;
		}
	},
	
	initRows: function() {
		for (var i = 0; i < this.rows.length; i++) {
			this.rows[i] = Runner.apply( {}, this.rows[i] );
			this.initRow( this.rows[i] );
		}
	},
	
	/**
	 * @param {object} row
	 * @param {boolean} setHref
	 */
	initRow: function( row, setHref ) {
		if ( !row.row || !row.row.length ) {
			row.row = $("#gridRow" + row.id, this.pageContext);
			
			if ( !row.row.length ) {
				row.row = $("#master_" + this.shortTName + row.id, this.pageContext);
			}
			if ( !row.row.length ) {
				row.row = $("#" + this.shortTName + "_preview" + row.id, this.pageContext).closest('tr[id^=gridRow]');
			}
		}
		
		row.masterKeys = row.masterKeys[ this.tName ] || row.masterKeys;

		this.initLink( row, setHref );
		this.setDetailLinksIds( row );
	},
	
	/**
	 * Assign the 'row' object's 'detLinksId' property 
	 * with the array of detail links id values 
	 * @param {object} row
	 */
	setDetailLinksIds: function( row ) {
		if ( this.recsPerRowList <= 1) {
			return;
		}
		
		row.detLinksId = [];
		
		var pattern = this.shortTName + "_preview";
		$("a[id^=" + pattern + "]", row.row).each( function() {
			row.detLinksId.push( this.id.substr( pattern.length ) );
		});
	},
	
	/**
	 * Set event handler for detail preview links 
	 * @param {object} row
	 * @param {boolean} setHref set attr href or not
	 */
	initLink: function( row, setHref ) {
		var dpObj = this,
			href, mKeys, key;
		
		if ( !Runner.isMobile ) {
			$("#" + this.shortTName + "_preview" + row.id).bind("click", function(e) {
				if ( row.isShown ) {
					dpObj.closeDetails( row );
				} else {
					dpObj.getDetails( row );
					dpObj.parPageObj.hideBrick("message");
				}
				
				return false;
			});
		}
		
		if ( setHref === true ) {
			mKeys = [];
			for (key in row.masterKeys) {
				mKeys.push( row.masterKeys[ key ] );
			}
			
			href = Runner.pages.getUrl( this.tName, this.pageType, mKeys, "masterkey" ) + "&mastertable=" + this.masterShortTName;
			$("#" + this.shortTName + "_preview" + row.id).attr('href', href);
		}
	},
	
	/**
	 * Add new master row, added with inlineAdd
	 * @param {object} new added row
	 */
	addRow: function( row ) {
		this.rows.push(row);
		row.rowInd = this.rows.length - 1;
		// init new added row
		this.initRow(row, true);
		// set correct det num
		var childRecNum = this.getChildCountBySameKeys( row );
		this.setChildRecNum( row, childRecNum );
	},
	
	getChildCountBySameKeys: function(row) {
		var mKeysAsString = JSON.stringify(row.masterKeys);
		for (var i = 0; i < this.rows.length; i++) {
			if (this.rows[i].id != row.id && mKeysAsString == JSON.stringify(this.rows[i].masterKeys)) {
				return this.rows[i].childNum;
			}
		}
		return "0";
	},
	
	/**
	 * Get the inline details page's data and show details	
	 * @param {object} row 
	 */
	getDetails: function( row ) {
		if ( row.isShown === true || row.startRequest === true ) {
			return;
		}

		var params = this.getParams( row ),
			dt = this;

		this.fireEvent('beforeShowDetails', this, row);
		row.startRequest = true;
		
		Runner.runnerAJAX( this.ajaxRequestUrl, params, function( respObject ) {
			dt.showDetails( respObject, row, params );
		});
	},
	
	/**
	 * @param {object} row
	 */
	getParams: function( row ) {
		return Runner.apply({
			id: Runner.genId(),
			mode: Runner.pages.constants.MODE_LIST_DETAILS,
			rndVal: Math.random(),
			mastertable: this.masterTName,
			masterid: this.id,
			masterpagetype: this.pageType,
			mainmasterpagetype: this.mainMasterPageType,
			goto: 1
		}, row.masterKeys);
	},

	/**
	 * Create the html markup to show the details preview
	 * @param {object} row
	 */
	createPreviewRow: function( row ) {
		var $lastRecordRow = row.row.filter(":last"),
			$nextGridRow = $lastRecordRow.next(),
			previewCellName = this.masterShortTName + "_previewcell",
			$childrenTd = $lastRecordRow.children('td'),
			detTdselector, colspan, colSpanArr, start, i; 
		
		if ( $nextGridRow.hasClass( this.classBasePrefix + 'dpreviewrow' ) ) {
			row.detTr = $nextGridRow;
			detTdselector = this.recsPerRowList > 1 ? "#" + previewCellName + row.id : '.dpinline';
			row.detTd = $( detTdselector, $nextGridRow );
			return;
		}
		
		//create new row		
		row.detTr = $("<tr></tr>").addClass( this.classBasePrefix + 'dpreviewrow' )
			.insertAfter( $lastRecordRow );
		
		if ( this.recsPerRowList > 1 ) {		
			colSpanArr = [];
			start = 0;
				
			$childrenTd.each( function( i, td ) {
				if ( $(td).attr("colid") == "endrecord" ) {
					colSpanArr.push( i - start );
					start = i + 1;
				}
			});
			colSpanArr.push( $childrenTd.length - start );
			
			for (i = 0; i < colSpanArr.length; i++) {
				$("<td></td>").addClass('dpinline dpframe-cl dpframe-cc dpframe-cr')
					.attr('colspan', colSpanArr[ i ]).attr('id', previewCellName + row.detLinksId[ i ])
					.appendTo( row.detTr );
				
				$("<td></td>").addClass( this.classBasePrefix + 'cs' ).attr('colid', "endrecord")
					.appendTo( row.detTr );
			}
			row.detTd = $("#" + previewCellName + row.id, row.detTr);
			
		} else {
			colspan = 0;
			$childrenTd.each( function( i, td ) {
				colspan += $childrenTd[i].colSpan;
			});

			colspan = this.oldLayout ? $childrenTd.length - 2 : colspan;		
			row.detTd = $("<td></td>").addClass('dpinline dpframe-cc').appendTo( row.detTr )		
				.attr('colspan', colspan );
			
			if ( this.listGridLayout == Runner.pages.constants.VERTICAL_LAYOUT ) {
				row.detTd.addClass('dpframe-cl dpframe-cr');
				return;
			}	
			if ( this.oldLayout ) {
				$("<td></td>").addClass( this.classBasePrefix + 'cl dpframe-cl' ).prependTo( row.detTr );
				$("<td></td>").addClass( this.classBasePrefix +'cr dpframe-cr' ).appendTo( row.detTr );
			}
		}
	},

	/**
	 * Show inline details
	 * @param {object} respObj
	 * @param {object} row
	 * @param {object} params
	 */	
	showDetails: function( respObj, row, params ) {
		if ( respObj.success === false ) {
			return;
		}
		
		Runner.setIdCounter( respObj.idStartFrom );
		Runner.pages.PageSettings.addSettings( this.tName, respObj.settings, false );
		
		// show html
		this.createPreviewRow( row );
		
		var dpObj = this, 
			newId = params.id,
			baseParams, cfg, jsFile;
		
		row.detCont = $("<div></div>")
			.attr('id', 'detailPreview' + newId)
			.addClass( this.classBasePrefix + 'pagewrapper' )
			.addClass( Runner.pages.PageSettings.getTableData(this.tName, "pageSkinStyle")[ this.pageType ] )
			.appendTo( row.detTd.empty() )
			.html( respObj.html )
			.before(
				'<div id="dpHide' + newId + '" align="' + (Runner.isDirRTL() ? 'right' : 'left') + '">'
					+ '<a id="dpClose' + newId + '" data-icon="' + Runner.pages.constants.CLOSE_RED_GIF + '" href="#" style="margin-right: 10px;"></a>'
					+ '<a href="' + $("#" + this.shortTName+"_preview" + row.id).attr('href') + '" name="dp' + newId + '">'
						+ Runner.lang.constants.TEXT_PROCEED_TO + ' ' + Runner.pages.PageSettings.getTableData(this.tName, "strCaption", "") 
					+ '</a>'
				+ '</div>'
			);
		
		$("#dpClose" + newId).on("click", function(e) {
			dpObj.closeDetails( row );
		});
		
		row.isShown = true;
		row.startRequest = false;
		
		baseParams = {
			id: newId,
			mode: Runner.pages.constants.MODE_LIST_DETAILS,
			rndVal: Math.random(),
			masterpagetype: this.pageType,
			mastertable: this.masterTName,
			mainmasterpagetype: this.mainMasterPageType
		};
		
		// create detailsPageObj
		cfg = {
			tName: this.tName,
			pageId: newId,
			pageType: this.pageType,
			controlsMap: respObj.controlsMap[ this.tName ][ this.pageType ][ newId ] || {}, 
			viewControlsMap: respObj.viewControlsMap[ this.tName ][ this.pageType ][ newId ] || {},
			pageMode: Runner.pages.constants.MODE_LIST_DETAILS,
			detCont: row.detCont,
			masterKeys: row.masterKeys,
			parId: this.parId,
			afterSaveDetails: {
				fn: function( allVals, fields, allKeys, allRowIds, isEdited ) {
					this.submitMade = true;
					this.submitSucceded = true;
					if ( !isEdited ) {
						this.updateChildRecNum( row.masterKeys );
					}
					this.fireEvent("detailsSaved", this, allVals, fields, allKeys, allRowIds);
				},
				scope: this	
			},
			afterDeleteDetails: {
				fn: function() {
					this.updateChildRecNum( row.masterKeys );
				},
				scope: this	
			},
			saveFailed: {
				fn: function( respObj, formObj, fieldControls ) {
					this.submitMade = true;
					this.submitSucceded = false;
					this.fireEvent("saveFailed", this, respObj, formObj);
				},
				scope: this	
			},
			afterInit: {
				fn: function() {
					this.fireEvent('afterInit', this, this.proxy, this.id);	
					this.fireEvent('afterShowDetails');
				},
				scope: this
			},
			baseParams: Runner.apply( baseParams, row.masterKeys )
		};
		
		if ( respObj.additionalCSS ) {
			Runner.util.ScriptLoader.loadCSS( respObj.additionalCSS );
		}
		
		if ( respObj.CSSFiles ) { // 8.1 version fix #9925
			Runner.util.ScriptLoader.loadCSS( respObj.CSSFiles );
		}		
		
		if ( respObj.additionalJS ) {
			for ( jsFile in respObj.additionalJS ) {
				Runner.util.ScriptLoader.addJS( [ jsFile ], respObj.additionalJS[ jsFile ] );
			}
			
			Runner.util.ScriptLoader.onFilesLoaded( function() { 
				row.detPage = Runner.pages.PageManager.initPage( cfg ); 
			}, dpObj );
				
			Runner.util.ScriptLoader.load();
		} else {
			row.detPage = Runner.pages.PageManager.initPage( cfg );
		}
	},
	
	/**
	 * Update the number of details displayed in the main table's 'details' link
	 * @param {object} masterKeys
	 * @param {number} rowId
	 */
	updateChildRecNum: function( masterKeys, rowId ) {
		var dp = this,
			mKeys = [], 
			reqParams, k;
		
		for (k in masterKeys) {
			mKeys.push( masterKeys[ k ] );
		}
		
		reqParams = {
			mKeys: JSON.stringify( mKeys ),
			dTable: this.tName,
			dSTable: this.shortTName,
			pageType: this.pageType,
			mTable: this.masterTName,
			mSTable: this.masterShortTName
		}
		
		Runner.runnerAJAX( Runner.getPageUrl("detreccount"), reqParams, function( respObj ) {
			if ( !respObj.success ) {
				return;
			}
			
			if ( rowId != undefined ) {
				dp.updateChildRecNumById( masterKeys, respObj.recsCount, rowId );
			} else {
				dp.updateChildRecNumByKeys( masterKeys, respObj.recsCount );
			}
		});
	},
	
	/**
	 * @param {object} masterKeys
	 * @param {string} detNum
	 * @param {number} rowId
	 */
	updateChildRecNumById: function( masterKeys, detNum, rowId ) {
		for (var i = 0; i < this.rows.length; i++) {
			if ( this.rows[i].id == rowId ) {
				this.setChildRecNum( this.rows[i], detNum );
				this.rows[i].masterKeys = masterKeys;
			}
		}
	},
	
	/**
	 * @param {object} masterKeys
	 * @param {string} detNum
	 */	
	updateChildRecNumByKeys: function( masterKeys, detNum ) {
		var mKeysAsString = JSON.stringify( masterKeys );
		
		for (var i = 0; i < this.rows.length; i++) {
			if ( mKeysAsString == JSON.stringify( this.rows[i].masterKeys ) ) {
				this.setChildRecNum( this.rows[i], detNum );
			}
		}
	},
	
	/**
	 * Update the 'details' link appearance and the
	 * number of details displayed within this link
	 * @param {object} row
	 * @param {string} detNum
	 */
	setChildRecNum: function( row, detNum ) {
		var $detNumberSpan = $("#cntDet_" + this.shortTName + "_" + row.id),
			numberOfDetails = parseInt( detNum, 10 );
		
		if ( !$detNumberSpan.length ) {
			$detNumberSpan = row.row.find('#' + this.shortTName + '_preview' + row.id).find('span').attr('id', "#cntDet_" + this.shortTName + "_" + row.id);
			if ( !$detNumberSpan.attr('id') ) {
				$detNumberSpan = row.row.find('#master_' + this.shortTName + "_" + row.id).find('span').attr('id', "#cntDet_" + this.shortTName + "_" + row.id);
			}
		}
		
		if ( !numberOfDetails ) {
			$detNumberSpan.html("")
				.parent()
				.toggle( !this.hideChild );
			return;
		}
		
		$detNumberSpan.html("(" + numberOfDetails + ")")
			.parent().show();
	},
	
	/**
	 * @param {number} ind
	 */
	closeDetailsByInd: function( ind ) {
		var row = this.getRowByInd( ind );
		if ( row ) {
			this.closeDetails( row );
		}
	},
	
	/**
	 * @param {number} rowId
	 */
	closeDetailsById: function( rowId ) {
		var row = this.getRowById( rowId );
		if ( row ) {
			this.closeDetails( row );
		}
	},
	
	/**
	 * Close the inline details, destroy detail's page
	 * @param {object} row
	 */
	closeDetails: function( row ) {
		if ( !row.isShown ) {
			return;
		}
		
		Runner.pages.PageManager.unregister( row.detPage.tName, row.detPage.pageId );
		
		if ( this.recsPerRowList > 1 && !this.isTdReset( row ) ) {
			this.resetCell( row );
		} else {
			row.detTr.remove();
			delete row.detTr;
			
			row.detTd.remove();
			delete row.detTd;
		}
		
		row.detCont.remove();
		delete row.detCont;
		
		row.isShown = false;
	},
	
	/**
	 * @param {object} row
	 */
	isTdReset: function(row) {
		var removeTd = false;
		for (var i = 0; i < row.detLinksId.length; i++) {
			var dpTd = $("#" + this.masterShortTName + "_previewcell" + row.detLinksId[i]);
			if (row.detLinksId[i]!=row.id) {
				if (dpTd.html()=='') {
					removeTd = true;
				} else {
					return false;
				}
			}
		}
		return removeTd;
	},
	
	/**
	 * Set the details preview container empty
	 * @param {object} row
	 */
	resetCell:function( row ) {
		row.detTd.empty();
	},
	
	/**
	 * Show the 'loading' message 
	 * while switching to another details preview
	 * @param {object} row
	 */
	loadingCell:function( row ) {
		row.isShown = false;
		Runner.runLoading( "", row.detTd );
	},
	
	getRowByInd: function( ind ) {
		for (var i = 0; i < this.rows.length; i++) {
			if (this.rows[i].rowInd == ind) {
				return this.rows[i];
			}
		}
		return false;
	},
	
	getRowById: function( id ) {
		for (var i = 0; i < this.rows.length; i++) {
			if (this.rows[i].id == id) {
				return this.rows[i];
			}
		}
		return false;
	},
	
	saveRow: function() {
		this.initRow( row );
	},
	
	destructor: function() {
		for (var i = 0; i < this.rows.length; i++) {
			this.closeDetails( this.rows[i] );
		}
	}
})

/**
 * @class Runner.util.details.InlineDP
 * provides base functionality for popup details on list page
 */
Runner.util.details.DPPopUp = Runner.extend( Runner.util.details.InlineDP, {
	
	timeout: null,
	
	masterDetails: null,
	
	/**
	 * Previously handled link
	 */
	prevLink: null,
	
	constructor: function( cfg ) {
		Runner.util.details.DPPopUp.superclass.constructor.call( this, cfg );
		
		this.dpShowType = Runner.pages.constants.DP_POPUP;
		this.masterDetails = {
			show: false,
			flag: "",
			counter: 0
		};
	},	
	
	init: function() {
		Runner.util.details.DPPopUp.superclass.init.call(this);
	},
	

	initLink: Runner.emptyFn,
	
	setDetailLinksIds: Runner.emptyFn,
	
	/**
	 * showPopup
	 * Show detail preview in popup
	 * @param {object} link 	details link
	 * @param {string} url		request url
	 * @param {string} mastertable
	 * @param {object} masterKeys
	 */
	showPopup: function( link, url, mastertable, masterKeys ) {
		var urlsDiff = false,
			pageObj = this,
			//cash the jQuery object
			detailsPopupEl = $("." + this.classBasePrefix + "details-popup");
			
		if (url && url !== detailsPopupEl.data("url")) {
			urlsDiff = true;
			detailsPopupEl.data("url", url);
		}
		//clearTimeout(this.timeout);
		clearTimeout( detailsPopupEl.data("timeout") );

		if ( detailsPopupEl.css("display") == 'none' || (url != undefined && this.prevLink != link) || urlsDiff ) {
			this.timeout = setTimeout(function() {
				pageObj.prevLink = link;
				pageObj.masterDetails.flag = url;
				pageObj.masterDetails.show = true;
				pageObj.masterDetails.counter++;
				
				Runner.runnerAJAX( url, {
						counter: pageObj.masterDetails.counter,
						mastertable: mastertable,
						masterKeys: JSON.stringify( masterKeys ),
						mode: 'listdetailspopup'
					}, 	
					function( respObj ) {
						var detailsPopup, linkPosition;
							
						if (!respObj.success || !pageObj.masterDetails.show) {
							return;
						}
						
						//cash the jQuery object
						detailsPopup = $("." + pageObj.classBasePrefix + "details-popup");
						if ( !detailsPopup.length ) {
							detailsPopup = $('<div class="' + pageObj.classBasePrefix + 'details-popup" style="display:none; position: absolute; left: 0px; top: 0px;"> </div>')
								.appendTo('body');
						}
						
						detailsPopup.bind({
							mouseenter: function() {
									pageObj.showPopup();
								},
							mouseleave: function() {
									pageObj.hidePopup();
								}
							});					
						
						if ( pageObj.masterDetails.counter == respObj.counter ) {
							detailsPopup.html( respObj.body );
							if ( respObj.CSSFiles ) {
								detailsPopup.addClass("page-detailspreview " + pageObj.classBasePrefix + "pagewrapper ");
								Runner.util.ScriptLoader.loadCSS( respObj.CSSFiles );
							}
						}
						
						linkPosition = $(link).offset();
						detailsPopup.css({
							top: linkPosition.top + "px",
							left: linkPosition.left + ( Runner.isDirRTL() ? -detailsPopup.outerWidth() : $(link).outerWidth() ) + "px"
						})
						.show();	
						}
				);
			}, 100);
			$("." + this.classBasePrefix + "details-popup").data("timeout", this.timeout);
		}
	},
	
	/**
	 * hidePopup
	 * Hide popup with details preview 
	 */
	hidePopup: function() {
		var detailPopup = $('.' + this.classBasePrefix + 'details-popup');
		this.masterDetails.show = false;
		
		if ( detailPopup.css("display") == 'none' || !detailPopup.length ) {
			clearTimeout( detailPopup.data("timeout") );
			return;
		}

			this.timeout = setTimeout( function() {
				detailPopup.hide();
				detailPopup.html("");
			}, 200);
			detailPopup.data("timeout", this.timeout);
			$(".runner-details-popup").data("timeout", this.timeout);
		}
});

/**
 * @class Runner.util.details.recDP
 * The base class for the details preview list pages
 * hosted on the non-list pages
 */
Runner.util.details.recDP = Runner.extend( Runner.util.details.DP, {
	/**
	 * A page object representing the details preview page
	 * @type {object}
	 */
	detailsPageObj: null,
	
	id: -1,
	
	submitMade: false,
	
	submitSucceded: true,
	
	useChildCount: false,
	
	
	init: function() {
		Runner.util.details.recDP.superclass.init.call( this );
		this.initButton();
		this.initDpPage();
		
		this.addEvents('detailsSaved');
		
		if ( this.detailsSaved ) {
			this.on( {'detailsSaved': this.detailsSaved} );
		}
		
		if ( this.saveFailed ) {
			this.on( {'saveFailed': this.saveFailed} );
		}
		
		if ( this.afterDeleteDetails ) {
			this.on( {'afterDeleteDetails': this.afterDeleteDetails} );
		}
	},
	
	/**
	 * Init the Detail preview list page object
	 * @param {object} cfg
	 */
	initDpPage: function() {
		var cfg = this.getPageConfig();
		this.detailsPageObj = Runner.pages.PageManager.initPage( cfg );
	},
	
	/**
	 * Get the detail preview page's config
	 * @paran {object}
	 * @return {object}
	 */	
	getPageConfig: function( cfg ) {
		return Runner.apply(cfg || {}, {
			tName: this.tName, 
			pageType: this.pType, 
			pageParams: this.pParam, 
			pageId: this.id, 
			controlsMap: this.controlsMap,
			viewControlsMap: this.viewControlsMap,
			masterTName: this.masterTName,
			detCont: $("#detailPreview" + this.id),
			useChildCount: this.useChildCount,
			childRecNum: 0,
			parId: this.parId,
			pageMode: Runner.pages.constants.MODE_LIST_DETAILS,
			baseParams: {
				id: this.id,
				mode: Runner.pages.constants.MODE_LIST_DETAILS,
				rndVal: Math.random(),
				masterpagetype: this.pageType
			},
			afterSaveDetails: {
				fn: function(allVals, fields, allKeys, allRowIds, isEdit) {
					this.submitMade = true;
					this.submitSucceded = true;
					this.fireEvent("detailsSaved", this, allVals, fields, allKeys, allRowIds);
				},
				scope: this	
			},
			saveFailed: {
				fn: function(respObj, formObj, fieldControls) {
					this.submitMade = true;
					this.submitSucceded = false;
					this.fireEvent("saveFailed", this, respObj, formObj);
				},
				scope: this	
			},
			afterDeleteDetails: {
				fn: function() {
					this.fireEvent("afterDeleteDetails");
				},
				scope: this	
			},			
			validationFailed: this.validationFailed
		});
	},
	
	/**
	 * A stub
	 * Details inlineAdd/InlineEdit rows' validationFailed event handler
	 */
	validationFailed: Runner.emptyFn,
	
	/**
	 * Initialize the show/hide details preview button
	 */
	initButton: function() {
		var id = this.id,
			$button = $('#dpMinus' + id);

		$button.on('click', function(e) {			
			if ( $button.is(':visible') ) { 
				$('.projekktor', '#detailPreview' + id).each(function() {
					projekktor( this.id ).setStop();
				});
			}
			setTimeout( function() {
				var src = $button.attr('src'),
					newSrc = src == Runner.pages.constants.MINUS_GIF ? Runner.pages.constants.PLUS_GIF : Runner.pages.constants.MINUS_GIF;
				
				$('#detailPreview' + id).toggle();
				$button.attr('src', newSrc);
			}, 100);
		});
	},
	
	/**
	 * Save list details
	 * @param {array} mKeys (optional)
	 */
	saveDetails: function( mKeys ) {
		if ( this.detailsPageObj.pageType !== Runner.pages.constants.PAGE_LIST ) {
			return;
		}
		
		this.submitSucceded = false;
		this.submitMade = false;
		return this.detailsPageObj.saveAll( mKeys );
	},

	/**
	 * Validate added/edited list details
	 */
	validate: function() {
		if ( this.detailsPageObj.pageType !== Runner.pages.constants.PAGE_LIST ) {
			return;
		}
			
		var addValidRes = this.detailsPageObj.inlineEdit ? this.detailsPageObj.inlineEdit.validate() : true,
			editValidRes = this.detailsPageObj.inlineAdd ? this.detailsPageObj.inlineAdd.validate() : true;
					
		return editValidRes && addValidRes;
	},
	
	destructor: function() {
		if ( this.detailsPageObj ) {
			this.detailsPageObj.destructor();
		}
	}
});


/**
 * @class Runner.util.details.AddDP
 * provides base functionality for details on add page
 */
Runner.util.details.AddDP = Runner.extend( Runner.util.details.recDP, {
	constructor: function( cfg ) {
		this.pageType = Runner.pages.constants.PAGE_ADD;
		Runner.util.details.AddDP.superclass.constructor.call( this, cfg );	
	},
	
	/**
	 * Init the Detail preview page object
	 */
	initDpPage: function() {
		Runner.util.details.AddDP.superclass.initDpPage.call( this );
		
		this.detailsPageObj.on('beforeSave', function( row, inlineObj, formObj ) {
			if ( inlineObj.inlineAddChangeContent !== true ) {
				inlineObj.cancelAll();
				
				return false;
			}
		}, this);
	},
	
	/**
	 * Get the Add page's detail preview page's config
	 * @return {object}
	 */
	getPageConfig: function() {
		var cfg = {
			hideSaveButt: true,
			afterInit: {
				fn: function( pageObj, proxy, pageId ) {
					if ( !pageObj.inlineAdd ) {
						return;
					}
					
					pageObj.inlineAdd.inlineAdd( true, true );
						
					pageObj.inlineAdd.on("createControls", function( row, ctrls ) {
						if ( this.inlineAddChangeContent ) {
							return true;
						}

						var inlineAddContentChangeHandler = function() {
							this.fireEvent('inlineAddContentChange', row);
						}					

						this.inlineAddChangeContent = false;
						this.on('inlineAddContentChange', this.showCancelButton, this, { single: true });
						
						for (var i = 0; i < ctrls.length; i++) {
							ctrls[i].on('editing', inlineAddContentChangeHandler, { single: true }, this);
						}
					}, pageObj.inlineAdd );
				},
				scope: this
			}
		};
		
		return Runner.util.details.AddDP.superclass.getPageConfig.call( this, cfg );
	}
});

/**
 * @class Runner.util.details.EditDP
 * provides base functionality for details on edit page
 */
Runner.util.details.EditDP = Runner.extend( Runner.util.details.recDP, {
	constructor: function( cfg ) {
		this.pageType = Runner.pages.constants.PAGE_EDIT;
		Runner.util.details.EditDP.superclass.constructor.call( this, cfg );
	}
});

/**
 * @class Runner.util.details.ViewDP
 * provides base functionality for details on view page
 */
Runner.util.details.ViewDP = Runner.extend( Runner.util.details.recDP, {
	constructor: function( cfg ) {
		this.pageType = Runner.pages.constants.PAGE_VIEW;
		Runner.util.details.ViewDP.superclass.constructor.call( this, cfg );	
	}
});
	

